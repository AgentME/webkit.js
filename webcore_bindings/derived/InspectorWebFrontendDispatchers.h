// File is generated by JavaScriptCore/inspector/scripts/CodeGeneratorInspector.py

// Copyright (c) 2013 Apple Inc. All Rights Reserved.
// Copyright (c) 2011 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
#ifndef InspectorWebFrontendDispatchers_h
#define InspectorWebFrontendDispatchers_h

#include "InspectorWebTypeBuilders.h"
#include <inspector/InspectorFrontendChannel.h>
#include <inspector/InspectorValues.h>
#include <wtf/PassRefPtr.h>
#include <wtf/text/WTFString.h>

namespace Inspector {

#if ENABLE(INSPECTOR)

class  InspectorApplicationCacheFrontendDispatcher {
public:
    InspectorApplicationCacheFrontendDispatcher(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
    void applicationCacheStatusUpdated(const Inspector::TypeBuilder::Network::FrameId& frameId, const String& manifestURL, int status);
    void networkStateUpdated(bool isNowOnline);
private:
    InspectorFrontendChannel* m_inspectorFrontendChannel;
};

class  InspectorCSSFrontendDispatcher {
public:
    InspectorCSSFrontendDispatcher(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
    void mediaQueryResultChanged();
    void styleSheetChanged(const Inspector::TypeBuilder::CSS::StyleSheetId& styleSheetId);
    void namedFlowCreated(PassRefPtr<Inspector::TypeBuilder::CSS::NamedFlow> namedFlow);
    void namedFlowRemoved(int documentNodeId, const String& flowName);
    void regionLayoutUpdated(PassRefPtr<Inspector::TypeBuilder::CSS::NamedFlow> namedFlow);
    void regionOversetChanged(PassRefPtr<Inspector::TypeBuilder::CSS::NamedFlow> namedFlow);
    void registeredNamedFlowContentElement(int documentNodeId, const String& flowName, int contentNodeId, int nextContentNodeId);
    void unregisteredNamedFlowContentElement(int documentNodeId, const String& flowName, int contentNodeId);
private:
    InspectorFrontendChannel* m_inspectorFrontendChannel;
};

class  InspectorCanvasFrontendDispatcher {
public:
    InspectorCanvasFrontendDispatcher(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
    void contextCreated(const Inspector::TypeBuilder::Network::FrameId& frameId);
    void traceLogsRemoved(const Inspector::TypeBuilder::Network::FrameId* const frameId, const Inspector::TypeBuilder::Canvas::TraceLogId* const traceLogId);
private:
    InspectorFrontendChannel* m_inspectorFrontendChannel;
};

class  InspectorConsoleFrontendDispatcher {
public:
    InspectorConsoleFrontendDispatcher(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
    void messageAdded(PassRefPtr<Inspector::TypeBuilder::Console::ConsoleMessage> message);
    void messageRepeatCountUpdated(int count);
    void messagesCleared();
private:
    InspectorFrontendChannel* m_inspectorFrontendChannel;
};

class  InspectorDOMFrontendDispatcher {
public:
    InspectorDOMFrontendDispatcher(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
    void documentUpdated();
    void setChildNodes(int parentId, PassRefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::DOM::Node> > nodes);
    void attributeModified(int nodeId, const String& name, const String& value);
    void attributeRemoved(int nodeId, const String& name);
    void inlineStyleInvalidated(PassRefPtr<Inspector::TypeBuilder::Array<int> > nodeIds);
    void characterDataModified(int nodeId, const String& characterData);
    void childNodeCountUpdated(int nodeId, int childNodeCount);
    void childNodeInserted(int parentNodeId, int previousNodeId, PassRefPtr<Inspector::TypeBuilder::DOM::Node> node);
    void childNodeRemoved(int parentNodeId, int nodeId);
    void shadowRootPushed(int hostId, PassRefPtr<Inspector::TypeBuilder::DOM::Node> root);
    void shadowRootPopped(int hostId, int rootId);
private:
    InspectorFrontendChannel* m_inspectorFrontendChannel;
};

class  InspectorDOMStorageFrontendDispatcher {
public:
    InspectorDOMStorageFrontendDispatcher(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
    void domStorageItemsCleared(PassRefPtr<Inspector::TypeBuilder::DOMStorage::StorageId> storageId);
    void domStorageItemRemoved(PassRefPtr<Inspector::TypeBuilder::DOMStorage::StorageId> storageId, const String& key);
    void domStorageItemAdded(PassRefPtr<Inspector::TypeBuilder::DOMStorage::StorageId> storageId, const String& key, const String& newValue);
    void domStorageItemUpdated(PassRefPtr<Inspector::TypeBuilder::DOMStorage::StorageId> storageId, const String& key, const String& oldValue, const String& newValue);
private:
    InspectorFrontendChannel* m_inspectorFrontendChannel;
};

#if ENABLE(SQL_DATABASE)
class  InspectorDatabaseFrontendDispatcher {
public:
    InspectorDatabaseFrontendDispatcher(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
    void addDatabase(PassRefPtr<Inspector::TypeBuilder::Database::Database> database);
private:
    InspectorFrontendChannel* m_inspectorFrontendChannel;
};

#endif // ENABLE(SQL_DATABASE)
class  InspectorHeapProfilerFrontendDispatcher {
public:
    InspectorHeapProfilerFrontendDispatcher(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
    void addProfileHeader(PassRefPtr<Inspector::TypeBuilder::HeapProfiler::ProfileHeader> header);
    void addHeapSnapshotChunk(int uid, const String& chunk);
    void finishHeapSnapshot(int uid);
    void resetProfiles();
    void reportHeapSnapshotProgress(int done, int total);
private:
    InspectorFrontendChannel* m_inspectorFrontendChannel;
};

class  InspectorLayerTreeFrontendDispatcher {
public:
    InspectorLayerTreeFrontendDispatcher(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
    void layerTreeDidChange();
private:
    InspectorFrontendChannel* m_inspectorFrontendChannel;
};

class  InspectorNetworkFrontendDispatcher {
public:
    InspectorNetworkFrontendDispatcher(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
    void requestWillBeSent(const Inspector::TypeBuilder::Network::RequestId& requestId, const Inspector::TypeBuilder::Network::FrameId& frameId, const Inspector::TypeBuilder::Network::LoaderId& loaderId, const String& documentURL, PassRefPtr<Inspector::TypeBuilder::Network::Request> request, double timestamp, PassRefPtr<Inspector::TypeBuilder::Network::Initiator> initiator, PassRefPtr<Inspector::TypeBuilder::Network::Response> redirectResponse, Inspector::TypeBuilder::Page::ResourceType::Enum* type);
    void requestServedFromCache(const Inspector::TypeBuilder::Network::RequestId& requestId);
    void responseReceived(const Inspector::TypeBuilder::Network::RequestId& requestId, const Inspector::TypeBuilder::Network::FrameId& frameId, const Inspector::TypeBuilder::Network::LoaderId& loaderId, double timestamp, Inspector::TypeBuilder::Page::ResourceType::Enum type, PassRefPtr<Inspector::TypeBuilder::Network::Response> response);
    void dataReceived(const Inspector::TypeBuilder::Network::RequestId& requestId, double timestamp, int dataLength, int encodedDataLength);
    void loadingFinished(const Inspector::TypeBuilder::Network::RequestId& requestId, double timestamp, const String* const sourceMapURL);
    void loadingFailed(const Inspector::TypeBuilder::Network::RequestId& requestId, double timestamp, const String& errorText, const bool* const canceled);
    void requestServedFromMemoryCache(const Inspector::TypeBuilder::Network::RequestId& requestId, const Inspector::TypeBuilder::Network::FrameId& frameId, const Inspector::TypeBuilder::Network::LoaderId& loaderId, const String& documentURL, double timestamp, PassRefPtr<Inspector::TypeBuilder::Network::Initiator> initiator, PassRefPtr<Inspector::TypeBuilder::Network::CachedResource> resource);
    void webSocketWillSendHandshakeRequest(const Inspector::TypeBuilder::Network::RequestId& requestId, double timestamp, PassRefPtr<Inspector::TypeBuilder::Network::WebSocketRequest> request);
    void webSocketHandshakeResponseReceived(const Inspector::TypeBuilder::Network::RequestId& requestId, double timestamp, PassRefPtr<Inspector::TypeBuilder::Network::WebSocketResponse> response);
    void webSocketCreated(const Inspector::TypeBuilder::Network::RequestId& requestId, const String& url);
    void webSocketClosed(const Inspector::TypeBuilder::Network::RequestId& requestId, double timestamp);
    void webSocketFrameReceived(const Inspector::TypeBuilder::Network::RequestId& requestId, double timestamp, PassRefPtr<Inspector::TypeBuilder::Network::WebSocketFrame> response);
    void webSocketFrameError(const Inspector::TypeBuilder::Network::RequestId& requestId, double timestamp, const String& errorMessage);
    void webSocketFrameSent(const Inspector::TypeBuilder::Network::RequestId& requestId, double timestamp, PassRefPtr<Inspector::TypeBuilder::Network::WebSocketFrame> response);
private:
    InspectorFrontendChannel* m_inspectorFrontendChannel;
};

class  InspectorPageFrontendDispatcher {
public:
    InspectorPageFrontendDispatcher(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
    void domContentEventFired(double timestamp);
    void loadEventFired(double timestamp);
    void frameNavigated(PassRefPtr<Inspector::TypeBuilder::Page::Frame> frame);
    void frameDetached(const Inspector::TypeBuilder::Network::FrameId& frameId);
    void frameStartedLoading(const Inspector::TypeBuilder::Network::FrameId& frameId);
    void frameStoppedLoading(const Inspector::TypeBuilder::Network::FrameId& frameId);
    void frameScheduledNavigation(const Inspector::TypeBuilder::Network::FrameId& frameId, double delay);
    void frameClearedScheduledNavigation(const Inspector::TypeBuilder::Network::FrameId& frameId);
    void javascriptDialogOpening(const String& message);
    void javascriptDialogClosed();
    void scriptsEnabled(bool isEnabled);
private:
    InspectorFrontendChannel* m_inspectorFrontendChannel;
};

#if ENABLE(JAVASCRIPT_DEBUGGER)
class  InspectorProfilerFrontendDispatcher {
public:
    InspectorProfilerFrontendDispatcher(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
    void addProfileHeader(PassRefPtr<Inspector::TypeBuilder::Profiler::ProfileHeader> header);
    void addHeapSnapshotChunk(int uid, const String& chunk);
    void finishHeapSnapshot(int uid);
    void setRecordingProfile(bool isProfiling);
    void resetProfiles();
    void reportHeapSnapshotProgress(int done, int total);
private:
    InspectorFrontendChannel* m_inspectorFrontendChannel;
};

#endif // ENABLE(JAVASCRIPT_DEBUGGER)
class  InspectorTimelineFrontendDispatcher {
public:
    InspectorTimelineFrontendDispatcher(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
    void eventRecorded(PassRefPtr<Inspector::TypeBuilder::Timeline::TimelineEvent> record);
private:
    InspectorFrontendChannel* m_inspectorFrontendChannel;
};

class  InspectorWorkerFrontendDispatcher {
public:
    InspectorWorkerFrontendDispatcher(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
    void workerCreated(int workerId, const String& url, bool inspectorConnected);
    void workerTerminated(int workerId);
    void dispatchMessageFromWorker(int workerId, PassRefPtr<Inspector::InspectorObject> message);
    void disconnectedFromWorker();
private:
    InspectorFrontendChannel* m_inspectorFrontendChannel;
};



#endif // ENABLE(INSPECTOR)

} // namespace Inspector

#endif // !defined(InspectorWebFrontendDispatchers_h)
