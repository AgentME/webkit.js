// File is generated by JavaScriptCore/inspector/scripts/CodeGeneratorInspector.py

// Copyright (c) 2013 Apple Inc. All Rights Reserved.
// Copyright (c) 2011 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
#ifndef InspectorWebBackendDispatchers_h
#define InspectorWebBackendDispatchers_h

#include "InspectorWebTypeBuilders.h"
#include <inspector/InspectorBackendDispatcher.h>
#include <wtf/PassRefPtr.h>
#include <wtf/text/WTFString.h>

namespace Inspector {

typedef String ErrorString;

class  InspectorApplicationCacheBackendDispatcherHandler {
public:
    virtual void getFramesWithManifests(ErrorString*, RefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::ApplicationCache::FrameWithManifest> >& out_frameIds) = 0;
    virtual void enable(ErrorString*) = 0;
    virtual void getManifestForFrame(ErrorString*, const String& in_frameId, String* out_manifestURL) = 0;
    virtual void getApplicationCacheForFrame(ErrorString*, const String& in_frameId, RefPtr<Inspector::TypeBuilder::ApplicationCache::ApplicationCache>& out_applicationCache) = 0;
protected:
    virtual ~InspectorApplicationCacheBackendDispatcherHandler();
};

class  InspectorCSSBackendDispatcherHandler {
public:
    virtual void enable(ErrorString*) = 0;
    virtual void disable(ErrorString*) = 0;
    virtual void getMatchedStylesForNode(ErrorString*, int in_nodeId, const bool* in_includePseudo, const bool* in_includeInherited, RefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::CSS::RuleMatch> >& opt_out_matchedCSSRules, RefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::CSS::PseudoIdMatches> >& opt_out_pseudoElements, RefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::CSS::InheritedStyleEntry> >& opt_out_inherited) = 0;
    virtual void getInlineStylesForNode(ErrorString*, int in_nodeId, RefPtr<Inspector::TypeBuilder::CSS::CSSStyle>& opt_out_inlineStyle, RefPtr<Inspector::TypeBuilder::CSS::CSSStyle>& opt_out_attributesStyle) = 0;
    virtual void getComputedStyleForNode(ErrorString*, int in_nodeId, RefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::CSS::CSSComputedStyleProperty> >& out_computedStyle) = 0;
    virtual void getAllStyleSheets(ErrorString*, RefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::CSS::CSSStyleSheetHeader> >& out_headers) = 0;
    virtual void getStyleSheet(ErrorString*, const String& in_styleSheetId, RefPtr<Inspector::TypeBuilder::CSS::CSSStyleSheetBody>& out_styleSheet) = 0;
    virtual void getStyleSheetText(ErrorString*, const String& in_styleSheetId, String* out_text) = 0;
    virtual void setStyleSheetText(ErrorString*, const String& in_styleSheetId, const String& in_text) = 0;
    virtual void setStyleText(ErrorString*, const RefPtr<Inspector::InspectorObject>& in_styleId, const String& in_text, RefPtr<Inspector::TypeBuilder::CSS::CSSStyle>& out_style) = 0;
    virtual void setPropertyText(ErrorString*, const RefPtr<Inspector::InspectorObject>& in_styleId, int in_propertyIndex, const String& in_text, bool in_overwrite, RefPtr<Inspector::TypeBuilder::CSS::CSSStyle>& out_style) = 0;
    virtual void toggleProperty(ErrorString*, const RefPtr<Inspector::InspectorObject>& in_styleId, int in_propertyIndex, bool in_disable, RefPtr<Inspector::TypeBuilder::CSS::CSSStyle>& out_style) = 0;
    virtual void setRuleSelector(ErrorString*, const RefPtr<Inspector::InspectorObject>& in_ruleId, const String& in_selector, RefPtr<Inspector::TypeBuilder::CSS::CSSRule>& out_rule) = 0;
    virtual void addRule(ErrorString*, int in_contextNodeId, const String& in_selector, RefPtr<Inspector::TypeBuilder::CSS::CSSRule>& out_rule) = 0;
    virtual void getSupportedCSSProperties(ErrorString*, RefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::CSS::CSSPropertyInfo> >& out_cssProperties) = 0;
    virtual void forcePseudoState(ErrorString*, int in_nodeId, const RefPtr<Inspector::InspectorArray>& in_forcedPseudoClasses) = 0;
    virtual void startSelectorProfiler(ErrorString*) = 0;
    virtual void stopSelectorProfiler(ErrorString*, RefPtr<Inspector::TypeBuilder::CSS::SelectorProfile>& out_profile) = 0;
    virtual void getNamedFlowCollection(ErrorString*, int in_documentNodeId, RefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::CSS::NamedFlow> >& out_namedFlows) = 0;
protected:
    virtual ~InspectorCSSBackendDispatcherHandler();
};

class  InspectorCanvasBackendDispatcherHandler {
public:
    virtual void enable(ErrorString*) = 0;
    virtual void disable(ErrorString*) = 0;
    virtual void dropTraceLog(ErrorString*, const String& in_traceLogId) = 0;
    virtual void hasUninstrumentedCanvases(ErrorString*, bool* out_result) = 0;
    virtual void captureFrame(ErrorString*, const String* in_frameId, Inspector::TypeBuilder::Canvas::TraceLogId* out_traceLogId) = 0;
    virtual void startCapturing(ErrorString*, const String* in_frameId, Inspector::TypeBuilder::Canvas::TraceLogId* out_traceLogId) = 0;
    virtual void stopCapturing(ErrorString*, const String& in_traceLogId) = 0;
    virtual void getTraceLog(ErrorString*, const String& in_traceLogId, const int* in_startOffset, const int* in_maxLength, RefPtr<Inspector::TypeBuilder::Canvas::TraceLog>& out_traceLog) = 0;
    virtual void replayTraceLog(ErrorString*, const String& in_traceLogId, int in_stepNo, RefPtr<Inspector::TypeBuilder::Canvas::ResourceState>& out_resourceState) = 0;
    virtual void getResourceInfo(ErrorString*, const String& in_resourceId, RefPtr<Inspector::TypeBuilder::Canvas::ResourceInfo>& out_resourceInfo) = 0;
    virtual void getResourceState(ErrorString*, const String& in_traceLogId, const String& in_resourceId, RefPtr<Inspector::TypeBuilder::Canvas::ResourceState>& out_resourceState) = 0;
protected:
    virtual ~InspectorCanvasBackendDispatcherHandler();
};

class  InspectorConsoleBackendDispatcherHandler {
public:
    virtual void enable(ErrorString*) = 0;
    virtual void disable(ErrorString*) = 0;
    virtual void clearMessages(ErrorString*) = 0;
    virtual void setMonitoringXHREnabled(ErrorString*, bool in_enabled) = 0;
    virtual void addInspectedNode(ErrorString*, int in_nodeId) = 0;
    virtual void addInspectedHeapObject(ErrorString*, int in_heapObjectId) = 0;
protected:
    virtual ~InspectorConsoleBackendDispatcherHandler();
};

class  InspectorDOMBackendDispatcherHandler {
public:
    virtual void getDocument(ErrorString*, RefPtr<Inspector::TypeBuilder::DOM::Node>& out_root) = 0;
    virtual void requestChildNodes(ErrorString*, int in_nodeId, const int* in_depth) = 0;
    virtual void querySelector(ErrorString*, int in_nodeId, const String& in_selector, int* out_nodeId) = 0;
    virtual void querySelectorAll(ErrorString*, int in_nodeId, const String& in_selector, RefPtr<Inspector::TypeBuilder::Array<int> >& out_nodeIds) = 0;
    virtual void setNodeName(ErrorString*, int in_nodeId, const String& in_name, int* out_nodeId) = 0;
    virtual void setNodeValue(ErrorString*, int in_nodeId, const String& in_value) = 0;
    virtual void removeNode(ErrorString*, int in_nodeId) = 0;
    virtual void setAttributeValue(ErrorString*, int in_nodeId, const String& in_name, const String& in_value) = 0;
    virtual void setAttributesAsText(ErrorString*, int in_nodeId, const String& in_text, const String* in_name) = 0;
    virtual void removeAttribute(ErrorString*, int in_nodeId, const String& in_name) = 0;
    virtual void getEventListenersForNode(ErrorString*, int in_nodeId, const String* in_objectGroup, RefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::DOM::EventListener> >& out_listeners) = 0;
    virtual void getOuterHTML(ErrorString*, int in_nodeId, String* out_outerHTML) = 0;
    virtual void setOuterHTML(ErrorString*, int in_nodeId, const String& in_outerHTML) = 0;
    virtual void performSearch(ErrorString*, const String& in_query, const RefPtr<Inspector::InspectorArray>* in_nodeIds, String* out_searchId, int* out_resultCount) = 0;
    virtual void getSearchResults(ErrorString*, const String& in_searchId, int in_fromIndex, int in_toIndex, RefPtr<Inspector::TypeBuilder::Array<int> >& out_nodeIds) = 0;
    virtual void discardSearchResults(ErrorString*, const String& in_searchId) = 0;
    virtual void requestNode(ErrorString*, const String& in_objectId, int* out_nodeId) = 0;
    virtual void setInspectModeEnabled(ErrorString*, bool in_enabled, const RefPtr<Inspector::InspectorObject>* in_highlightConfig) = 0;
    virtual void highlightRect(ErrorString*, int in_x, int in_y, int in_width, int in_height, const RefPtr<Inspector::InspectorObject>* in_color, const RefPtr<Inspector::InspectorObject>* in_outlineColor, const bool* in_usePageCoordinates) = 0;
    virtual void highlightQuad(ErrorString*, const RefPtr<Inspector::InspectorArray>& in_quad, const RefPtr<Inspector::InspectorObject>* in_color, const RefPtr<Inspector::InspectorObject>* in_outlineColor, const bool* in_usePageCoordinates) = 0;
    virtual void highlightNode(ErrorString*, const RefPtr<Inspector::InspectorObject>& in_highlightConfig, const int* in_nodeId, const String* in_objectId) = 0;
    virtual void hideHighlight(ErrorString*) = 0;
    virtual void highlightFrame(ErrorString*, const String& in_frameId, const RefPtr<Inspector::InspectorObject>* in_contentColor, const RefPtr<Inspector::InspectorObject>* in_contentOutlineColor) = 0;
    virtual void pushNodeByPathToFrontend(ErrorString*, const String& in_path, int* out_nodeId) = 0;
    virtual void pushNodeByBackendIdToFrontend(ErrorString*, int in_backendNodeId, int* out_nodeId) = 0;
    virtual void releaseBackendNodeIds(ErrorString*, const String& in_nodeGroup) = 0;
    virtual void resolveNode(ErrorString*, int in_nodeId, const String* in_objectGroup, RefPtr<Inspector::TypeBuilder::Runtime::RemoteObject>& out_object) = 0;
    virtual void getAttributes(ErrorString*, int in_nodeId, RefPtr<Inspector::TypeBuilder::Array<String> >& out_attributes) = 0;
    virtual void moveTo(ErrorString*, int in_nodeId, int in_targetNodeId, const int* in_insertBeforeNodeId, int* out_nodeId) = 0;
    virtual void undo(ErrorString*) = 0;
    virtual void redo(ErrorString*) = 0;
    virtual void markUndoableState(ErrorString*) = 0;
    virtual void focus(ErrorString*, int in_nodeId) = 0;
protected:
    virtual ~InspectorDOMBackendDispatcherHandler();
};

#if ENABLE(JAVASCRIPT_DEBUGGER)
class  InspectorDOMDebuggerBackendDispatcherHandler {
public:
    virtual void setDOMBreakpoint(ErrorString*, int in_nodeId, const String& in_type) = 0;
    virtual void removeDOMBreakpoint(ErrorString*, int in_nodeId, const String& in_type) = 0;
    virtual void setEventListenerBreakpoint(ErrorString*, const String& in_eventName) = 0;
    virtual void removeEventListenerBreakpoint(ErrorString*, const String& in_eventName) = 0;
    virtual void setInstrumentationBreakpoint(ErrorString*, const String& in_eventName) = 0;
    virtual void removeInstrumentationBreakpoint(ErrorString*, const String& in_eventName) = 0;
    virtual void setXHRBreakpoint(ErrorString*, const String& in_url) = 0;
    virtual void removeXHRBreakpoint(ErrorString*, const String& in_url) = 0;
protected:
    virtual ~InspectorDOMDebuggerBackendDispatcherHandler();
};

#endif // ENABLE(JAVASCRIPT_DEBUGGER)
class  InspectorDOMStorageBackendDispatcherHandler {
public:
    virtual void enable(ErrorString*) = 0;
    virtual void disable(ErrorString*) = 0;
    virtual void getDOMStorageItems(ErrorString*, const RefPtr<Inspector::InspectorObject>& in_storageId, RefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::Array<String> > >& out_entries) = 0;
    virtual void setDOMStorageItem(ErrorString*, const RefPtr<Inspector::InspectorObject>& in_storageId, const String& in_key, const String& in_value) = 0;
    virtual void removeDOMStorageItem(ErrorString*, const RefPtr<Inspector::InspectorObject>& in_storageId, const String& in_key) = 0;
protected:
    virtual ~InspectorDOMStorageBackendDispatcherHandler();
};

#if ENABLE(SQL_DATABASE)
class  InspectorDatabaseBackendDispatcherHandler {
public:
    virtual void enable(ErrorString*) = 0;
    virtual void disable(ErrorString*) = 0;
    virtual void getDatabaseTableNames(ErrorString*, const String& in_databaseId, RefPtr<Inspector::TypeBuilder::Array<String> >& out_tableNames) = 0;
    class ExecuteSQLCallback : public Inspector::InspectorBackendDispatcher::CallbackBase {
    public:
        ExecuteSQLCallback(PassRefPtr<Inspector::InspectorBackendDispatcher>, int id);
        void sendSuccess(PassRefPtr<Inspector::TypeBuilder::Array<String> > columnNames, PassRefPtr<Inspector::TypeBuilder::Array<Inspector::InspectorValue> > values, PassRefPtr<Inspector::TypeBuilder::Database::Error> sqlError);
    };
    virtual void executeSQL(ErrorString*, const String& in_databaseId, const String& in_query, PassRefPtr<ExecuteSQLCallback> callback) = 0;
protected:
    virtual ~InspectorDatabaseBackendDispatcherHandler();
};

#endif // ENABLE(SQL_DATABASE)
class  InspectorHeapProfilerBackendDispatcherHandler {
public:
    virtual void hasHeapProfiler(ErrorString*, bool* out_result) = 0;
    virtual void getProfileHeaders(ErrorString*, RefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::HeapProfiler::ProfileHeader> >& out_headers) = 0;
    virtual void getHeapSnapshot(ErrorString*, int in_uid) = 0;
    virtual void removeProfile(ErrorString*, int in_uid) = 0;
    virtual void clearProfiles(ErrorString*) = 0;
    virtual void takeHeapSnapshot(ErrorString*, const bool* in_reportProgress) = 0;
    virtual void collectGarbage(ErrorString*) = 0;
    virtual void getObjectByHeapObjectId(ErrorString*, const String& in_objectId, const String* in_objectGroup, RefPtr<Inspector::TypeBuilder::Runtime::RemoteObject>& out_result) = 0;
    virtual void getHeapObjectId(ErrorString*, const String& in_objectId, Inspector::TypeBuilder::HeapProfiler::HeapSnapshotObjectId* out_heapSnapshotObjectId) = 0;
protected:
    virtual ~InspectorHeapProfilerBackendDispatcherHandler();
};

#if ENABLE(INDEXED_DATABASE)
class  InspectorIndexedDBBackendDispatcherHandler {
public:
    virtual void enable(ErrorString*) = 0;
    virtual void disable(ErrorString*) = 0;
    class RequestDatabaseNamesCallback : public Inspector::InspectorBackendDispatcher::CallbackBase {
    public:
        RequestDatabaseNamesCallback(PassRefPtr<Inspector::InspectorBackendDispatcher>, int id);
        void sendSuccess(PassRefPtr<Inspector::TypeBuilder::Array<String> > databaseNames);
    };
    virtual void requestDatabaseNames(ErrorString*, const String& in_securityOrigin, PassRefPtr<RequestDatabaseNamesCallback> callback) = 0;
    class RequestDatabaseCallback : public Inspector::InspectorBackendDispatcher::CallbackBase {
    public:
        RequestDatabaseCallback(PassRefPtr<Inspector::InspectorBackendDispatcher>, int id);
        void sendSuccess(PassRefPtr<Inspector::TypeBuilder::IndexedDB::DatabaseWithObjectStores> databaseWithObjectStores);
    };
    virtual void requestDatabase(ErrorString*, const String& in_securityOrigin, const String& in_databaseName, PassRefPtr<RequestDatabaseCallback> callback) = 0;
    class RequestDataCallback : public Inspector::InspectorBackendDispatcher::CallbackBase {
    public:
        RequestDataCallback(PassRefPtr<Inspector::InspectorBackendDispatcher>, int id);
        void sendSuccess(PassRefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::IndexedDB::DataEntry> > objectStoreDataEntries, bool hasMore);
    };
    virtual void requestData(ErrorString*, const String& in_securityOrigin, const String& in_databaseName, const String& in_objectStoreName, const String& in_indexName, int in_skipCount, int in_pageSize, const RefPtr<Inspector::InspectorObject>* in_keyRange, PassRefPtr<RequestDataCallback> callback) = 0;
    class ClearObjectStoreCallback : public Inspector::InspectorBackendDispatcher::CallbackBase {
    public:
        ClearObjectStoreCallback(PassRefPtr<Inspector::InspectorBackendDispatcher>, int id);
        void sendSuccess();
    };
    virtual void clearObjectStore(ErrorString*, const String& in_securityOrigin, const String& in_databaseName, const String& in_objectStoreName, PassRefPtr<ClearObjectStoreCallback> callback) = 0;
protected:
    virtual ~InspectorIndexedDBBackendDispatcherHandler();
};

#endif // ENABLE(INDEXED_DATABASE)
class  InspectorInputBackendDispatcherHandler {
public:
    virtual void dispatchKeyEvent(ErrorString*, const String& in_type, const int* in_modifiers, const double* in_timestamp, const String* in_text, const String* in_unmodifiedText, const String* in_keyIdentifier, const int* in_windowsVirtualKeyCode, const int* in_nativeVirtualKeyCode, const int* in_macCharCode, const bool* in_autoRepeat, const bool* in_isKeypad, const bool* in_isSystemKey) = 0;
    virtual void dispatchMouseEvent(ErrorString*, const String& in_type, int in_x, int in_y, const int* in_modifiers, const double* in_timestamp, const String* in_button, const int* in_clickCount) = 0;
protected:
    virtual ~InspectorInputBackendDispatcherHandler();
};

class  InspectorLayerTreeBackendDispatcherHandler {
public:
    virtual void enable(ErrorString*) = 0;
    virtual void disable(ErrorString*) = 0;
    virtual void layersForNode(ErrorString*, int in_nodeId, RefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::LayerTree::Layer> >& out_layers) = 0;
    virtual void reasonsForCompositingLayer(ErrorString*, const String& in_layerId, RefPtr<Inspector::TypeBuilder::LayerTree::CompositingReasons>& out_compositingReasons) = 0;
protected:
    virtual ~InspectorLayerTreeBackendDispatcherHandler();
};

class  InspectorMemoryBackendDispatcherHandler {
public:
    virtual void getDOMCounters(ErrorString*, int* out_documents, int* out_nodes, int* out_jsEventListeners) = 0;
protected:
    virtual ~InspectorMemoryBackendDispatcherHandler();
};

class  InspectorNetworkBackendDispatcherHandler {
public:
    virtual void enable(ErrorString*) = 0;
    virtual void disable(ErrorString*) = 0;
    virtual void setExtraHTTPHeaders(ErrorString*, const RefPtr<Inspector::InspectorObject>& in_headers) = 0;
    virtual void getResponseBody(ErrorString*, const String& in_requestId, String* out_body, bool* out_base64Encoded) = 0;
    virtual void replayXHR(ErrorString*, const String& in_requestId) = 0;
    virtual void canClearBrowserCache(ErrorString*, bool* out_result) = 0;
    virtual void clearBrowserCache(ErrorString*) = 0;
    virtual void canClearBrowserCookies(ErrorString*, bool* out_result) = 0;
    virtual void clearBrowserCookies(ErrorString*) = 0;
    virtual void setCacheDisabled(ErrorString*, bool in_cacheDisabled) = 0;
protected:
    virtual ~InspectorNetworkBackendDispatcherHandler();
};

class  InspectorPageBackendDispatcherHandler {
public:
    virtual void enable(ErrorString*) = 0;
    virtual void disable(ErrorString*) = 0;
    virtual void addScriptToEvaluateOnLoad(ErrorString*, const String& in_scriptSource, Inspector::TypeBuilder::Page::ScriptIdentifier* out_identifier) = 0;
    virtual void removeScriptToEvaluateOnLoad(ErrorString*, const String& in_identifier) = 0;
    virtual void reload(ErrorString*, const bool* in_ignoreCache, const String* in_scriptToEvaluateOnLoad, const String* in_scriptPreprocessor) = 0;
    virtual void navigate(ErrorString*, const String& in_url) = 0;
    virtual void getCookies(ErrorString*, RefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::Page::Cookie> >& out_cookies) = 0;
    virtual void deleteCookie(ErrorString*, const String& in_cookieName, const String& in_url) = 0;
    virtual void getResourceTree(ErrorString*, RefPtr<Inspector::TypeBuilder::Page::FrameResourceTree>& out_frameTree) = 0;
    virtual void getResourceContent(ErrorString*, const String& in_frameId, const String& in_url, String* out_content, bool* out_base64Encoded) = 0;
    virtual void searchInResource(ErrorString*, const String& in_frameId, const String& in_url, const String& in_query, const bool* in_caseSensitive, const bool* in_isRegex, RefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::GenericTypes::SearchMatch> >& out_result) = 0;
    virtual void searchInResources(ErrorString*, const String& in_text, const bool* in_caseSensitive, const bool* in_isRegex, RefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::Page::SearchResult> >& out_result) = 0;
    virtual void setDocumentContent(ErrorString*, const String& in_frameId, const String& in_html) = 0;
    virtual void setShowPaintRects(ErrorString*, bool in_result) = 0;
    virtual void canShowDebugBorders(ErrorString*, bool* out_show) = 0;
    virtual void setShowDebugBorders(ErrorString*, bool in_show) = 0;
    virtual void canShowFPSCounter(ErrorString*, bool* out_show) = 0;
    virtual void setShowFPSCounter(ErrorString*, bool in_show) = 0;
    virtual void canContinuouslyPaint(ErrorString*, bool* out_value) = 0;
    virtual void setContinuousPaintingEnabled(ErrorString*, bool in_enabled) = 0;
    // Named after parameter 'result' while generating command/event getScriptExecutionStatus.
    struct Result {
        enum Enum {
            Allowed = 100,
            Disabled = 16,
            Forbidden = 101,
        };
    }; // struct Result
    virtual void getScriptExecutionStatus(ErrorString*, InspectorPageBackendDispatcherHandler::Result::Enum* out_result) = 0;
    virtual void setScriptExecutionDisabled(ErrorString*, bool in_value) = 0;
    virtual void setTouchEmulationEnabled(ErrorString*, bool in_enabled) = 0;
    virtual void setEmulatedMedia(ErrorString*, const String& in_media) = 0;
    virtual void getCompositingBordersVisible(ErrorString*, bool* out_result) = 0;
    virtual void setCompositingBordersVisible(ErrorString*, bool in_visible) = 0;
    virtual void snapshotNode(ErrorString*, int in_nodeId, String* out_dataURL) = 0;
    virtual void snapshotRect(ErrorString*, int in_x, int in_y, int in_width, int in_height, const String& in_coordinateSystem, String* out_dataURL) = 0;
    virtual void handleJavaScriptDialog(ErrorString*, bool in_accept, const String* in_promptText) = 0;
    virtual void archive(ErrorString*, String* out_data) = 0;
protected:
    virtual ~InspectorPageBackendDispatcherHandler();
};

#if ENABLE(JAVASCRIPT_DEBUGGER)
class  InspectorProfilerBackendDispatcherHandler {
public:
    virtual void causesRecompilation(ErrorString*, bool* out_result) = 0;
    virtual void isSampling(ErrorString*, bool* out_result) = 0;
    virtual void hasHeapProfiler(ErrorString*, bool* out_result) = 0;
    virtual void enable(ErrorString*) = 0;
    virtual void disable(ErrorString*) = 0;
    virtual void start(ErrorString*) = 0;
    virtual void stop(ErrorString*) = 0;
    virtual void getProfileHeaders(ErrorString*, RefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::Profiler::ProfileHeader> >& out_headers) = 0;
    virtual void getCPUProfile(ErrorString*, int in_uid, RefPtr<Inspector::TypeBuilder::Profiler::CPUProfile>& out_profile) = 0;
    virtual void getHeapSnapshot(ErrorString*, int in_uid) = 0;
    virtual void removeProfile(ErrorString*, const String& in_type, int in_uid) = 0;
    virtual void clearProfiles(ErrorString*) = 0;
    virtual void takeHeapSnapshot(ErrorString*, const bool* in_reportProgress) = 0;
    virtual void collectGarbage(ErrorString*) = 0;
    virtual void getObjectByHeapObjectId(ErrorString*, const String& in_objectId, const String* in_objectGroup, RefPtr<Inspector::TypeBuilder::Runtime::RemoteObject>& out_result) = 0;
    virtual void getHeapObjectId(ErrorString*, const String& in_objectId, Inspector::TypeBuilder::Profiler::HeapSnapshotObjectId* out_heapSnapshotObjectId) = 0;
protected:
    virtual ~InspectorProfilerBackendDispatcherHandler();
};

#endif // ENABLE(JAVASCRIPT_DEBUGGER)
class  InspectorTimelineBackendDispatcherHandler {
public:
    virtual void start(ErrorString*, const int* in_maxCallStackDepth, const bool* in_includeDomCounters) = 0;
    virtual void stop(ErrorString*) = 0;
    virtual void supportsFrameInstrumentation(ErrorString*, bool* out_result) = 0;
    virtual void canMonitorMainThread(ErrorString*, bool* out_result) = 0;
protected:
    virtual ~InspectorTimelineBackendDispatcherHandler();
};

class  InspectorWorkerBackendDispatcherHandler {
public:
    virtual void enable(ErrorString*) = 0;
    virtual void disable(ErrorString*) = 0;
    virtual void sendMessageToWorker(ErrorString*, int in_workerId, const RefPtr<Inspector::InspectorObject>& in_message) = 0;
    virtual void canInspectWorkers(ErrorString*, bool* out_result) = 0;
    virtual void connectToWorker(ErrorString*, int in_workerId) = 0;
    virtual void disconnectFromWorker(ErrorString*, int in_workerId) = 0;
    virtual void setAutoconnectToWorkers(ErrorString*, bool in_value) = 0;
protected:
    virtual ~InspectorWorkerBackendDispatcherHandler();
};



class  InspectorApplicationCacheBackendDispatcher FINAL : public Inspector::InspectorSupplementalBackendDispatcher {
public:
    static PassRefPtr<InspectorApplicationCacheBackendDispatcher> create(Inspector::InspectorBackendDispatcher*, InspectorApplicationCacheBackendDispatcherHandler*);
    virtual void dispatch(long callId, const String& method, PassRefPtr<Inspector::InspectorObject> message) OVERRIDE;
private:
    void getFramesWithManifests(long callId, const Inspector::InspectorObject& message);
    void enable(long callId, const Inspector::InspectorObject& message);
    void getManifestForFrame(long callId, const Inspector::InspectorObject& message);
    void getApplicationCacheForFrame(long callId, const Inspector::InspectorObject& message);
private:
    InspectorApplicationCacheBackendDispatcher(Inspector::InspectorBackendDispatcher*, InspectorApplicationCacheBackendDispatcherHandler*);
    InspectorApplicationCacheBackendDispatcherHandler* m_agent;
};

class  InspectorCSSBackendDispatcher FINAL : public Inspector::InspectorSupplementalBackendDispatcher {
public:
    static PassRefPtr<InspectorCSSBackendDispatcher> create(Inspector::InspectorBackendDispatcher*, InspectorCSSBackendDispatcherHandler*);
    virtual void dispatch(long callId, const String& method, PassRefPtr<Inspector::InspectorObject> message) OVERRIDE;
private:
    void enable(long callId, const Inspector::InspectorObject& message);
    void disable(long callId, const Inspector::InspectorObject& message);
    void getMatchedStylesForNode(long callId, const Inspector::InspectorObject& message);
    void getInlineStylesForNode(long callId, const Inspector::InspectorObject& message);
    void getComputedStyleForNode(long callId, const Inspector::InspectorObject& message);
    void getAllStyleSheets(long callId, const Inspector::InspectorObject& message);
    void getStyleSheet(long callId, const Inspector::InspectorObject& message);
    void getStyleSheetText(long callId, const Inspector::InspectorObject& message);
    void setStyleSheetText(long callId, const Inspector::InspectorObject& message);
    void setStyleText(long callId, const Inspector::InspectorObject& message);
    void setPropertyText(long callId, const Inspector::InspectorObject& message);
    void toggleProperty(long callId, const Inspector::InspectorObject& message);
    void setRuleSelector(long callId, const Inspector::InspectorObject& message);
    void addRule(long callId, const Inspector::InspectorObject& message);
    void getSupportedCSSProperties(long callId, const Inspector::InspectorObject& message);
    void forcePseudoState(long callId, const Inspector::InspectorObject& message);
    void startSelectorProfiler(long callId, const Inspector::InspectorObject& message);
    void stopSelectorProfiler(long callId, const Inspector::InspectorObject& message);
    void getNamedFlowCollection(long callId, const Inspector::InspectorObject& message);
private:
    InspectorCSSBackendDispatcher(Inspector::InspectorBackendDispatcher*, InspectorCSSBackendDispatcherHandler*);
    InspectorCSSBackendDispatcherHandler* m_agent;
};

class  InspectorCanvasBackendDispatcher FINAL : public Inspector::InspectorSupplementalBackendDispatcher {
public:
    static PassRefPtr<InspectorCanvasBackendDispatcher> create(Inspector::InspectorBackendDispatcher*, InspectorCanvasBackendDispatcherHandler*);
    virtual void dispatch(long callId, const String& method, PassRefPtr<Inspector::InspectorObject> message) OVERRIDE;
private:
    void enable(long callId, const Inspector::InspectorObject& message);
    void disable(long callId, const Inspector::InspectorObject& message);
    void dropTraceLog(long callId, const Inspector::InspectorObject& message);
    void hasUninstrumentedCanvases(long callId, const Inspector::InspectorObject& message);
    void captureFrame(long callId, const Inspector::InspectorObject& message);
    void startCapturing(long callId, const Inspector::InspectorObject& message);
    void stopCapturing(long callId, const Inspector::InspectorObject& message);
    void getTraceLog(long callId, const Inspector::InspectorObject& message);
    void replayTraceLog(long callId, const Inspector::InspectorObject& message);
    void getResourceInfo(long callId, const Inspector::InspectorObject& message);
    void getResourceState(long callId, const Inspector::InspectorObject& message);
private:
    InspectorCanvasBackendDispatcher(Inspector::InspectorBackendDispatcher*, InspectorCanvasBackendDispatcherHandler*);
    InspectorCanvasBackendDispatcherHandler* m_agent;
};

class  InspectorConsoleBackendDispatcher FINAL : public Inspector::InspectorSupplementalBackendDispatcher {
public:
    static PassRefPtr<InspectorConsoleBackendDispatcher> create(Inspector::InspectorBackendDispatcher*, InspectorConsoleBackendDispatcherHandler*);
    virtual void dispatch(long callId, const String& method, PassRefPtr<Inspector::InspectorObject> message) OVERRIDE;
private:
    void enable(long callId, const Inspector::InspectorObject& message);
    void disable(long callId, const Inspector::InspectorObject& message);
    void clearMessages(long callId, const Inspector::InspectorObject& message);
    void setMonitoringXHREnabled(long callId, const Inspector::InspectorObject& message);
    void addInspectedNode(long callId, const Inspector::InspectorObject& message);
    void addInspectedHeapObject(long callId, const Inspector::InspectorObject& message);
private:
    InspectorConsoleBackendDispatcher(Inspector::InspectorBackendDispatcher*, InspectorConsoleBackendDispatcherHandler*);
    InspectorConsoleBackendDispatcherHandler* m_agent;
};

class  InspectorDOMBackendDispatcher FINAL : public Inspector::InspectorSupplementalBackendDispatcher {
public:
    static PassRefPtr<InspectorDOMBackendDispatcher> create(Inspector::InspectorBackendDispatcher*, InspectorDOMBackendDispatcherHandler*);
    virtual void dispatch(long callId, const String& method, PassRefPtr<Inspector::InspectorObject> message) OVERRIDE;
private:
    void getDocument(long callId, const Inspector::InspectorObject& message);
    void requestChildNodes(long callId, const Inspector::InspectorObject& message);
    void querySelector(long callId, const Inspector::InspectorObject& message);
    void querySelectorAll(long callId, const Inspector::InspectorObject& message);
    void setNodeName(long callId, const Inspector::InspectorObject& message);
    void setNodeValue(long callId, const Inspector::InspectorObject& message);
    void removeNode(long callId, const Inspector::InspectorObject& message);
    void setAttributeValue(long callId, const Inspector::InspectorObject& message);
    void setAttributesAsText(long callId, const Inspector::InspectorObject& message);
    void removeAttribute(long callId, const Inspector::InspectorObject& message);
    void getEventListenersForNode(long callId, const Inspector::InspectorObject& message);
    void getOuterHTML(long callId, const Inspector::InspectorObject& message);
    void setOuterHTML(long callId, const Inspector::InspectorObject& message);
    void performSearch(long callId, const Inspector::InspectorObject& message);
    void getSearchResults(long callId, const Inspector::InspectorObject& message);
    void discardSearchResults(long callId, const Inspector::InspectorObject& message);
    void requestNode(long callId, const Inspector::InspectorObject& message);
    void setInspectModeEnabled(long callId, const Inspector::InspectorObject& message);
    void highlightRect(long callId, const Inspector::InspectorObject& message);
    void highlightQuad(long callId, const Inspector::InspectorObject& message);
    void highlightNode(long callId, const Inspector::InspectorObject& message);
    void hideHighlight(long callId, const Inspector::InspectorObject& message);
    void highlightFrame(long callId, const Inspector::InspectorObject& message);
    void pushNodeByPathToFrontend(long callId, const Inspector::InspectorObject& message);
    void pushNodeByBackendIdToFrontend(long callId, const Inspector::InspectorObject& message);
    void releaseBackendNodeIds(long callId, const Inspector::InspectorObject& message);
    void resolveNode(long callId, const Inspector::InspectorObject& message);
    void getAttributes(long callId, const Inspector::InspectorObject& message);
    void moveTo(long callId, const Inspector::InspectorObject& message);
    void undo(long callId, const Inspector::InspectorObject& message);
    void redo(long callId, const Inspector::InspectorObject& message);
    void markUndoableState(long callId, const Inspector::InspectorObject& message);
    void focus(long callId, const Inspector::InspectorObject& message);
private:
    InspectorDOMBackendDispatcher(Inspector::InspectorBackendDispatcher*, InspectorDOMBackendDispatcherHandler*);
    InspectorDOMBackendDispatcherHandler* m_agent;
};

#if ENABLE(JAVASCRIPT_DEBUGGER)
class  InspectorDOMDebuggerBackendDispatcher FINAL : public Inspector::InspectorSupplementalBackendDispatcher {
public:
    static PassRefPtr<InspectorDOMDebuggerBackendDispatcher> create(Inspector::InspectorBackendDispatcher*, InspectorDOMDebuggerBackendDispatcherHandler*);
    virtual void dispatch(long callId, const String& method, PassRefPtr<Inspector::InspectorObject> message) OVERRIDE;
private:
    void setDOMBreakpoint(long callId, const Inspector::InspectorObject& message);
    void removeDOMBreakpoint(long callId, const Inspector::InspectorObject& message);
    void setEventListenerBreakpoint(long callId, const Inspector::InspectorObject& message);
    void removeEventListenerBreakpoint(long callId, const Inspector::InspectorObject& message);
    void setInstrumentationBreakpoint(long callId, const Inspector::InspectorObject& message);
    void removeInstrumentationBreakpoint(long callId, const Inspector::InspectorObject& message);
    void setXHRBreakpoint(long callId, const Inspector::InspectorObject& message);
    void removeXHRBreakpoint(long callId, const Inspector::InspectorObject& message);
private:
    InspectorDOMDebuggerBackendDispatcher(Inspector::InspectorBackendDispatcher*, InspectorDOMDebuggerBackendDispatcherHandler*);
    InspectorDOMDebuggerBackendDispatcherHandler* m_agent;
};

#endif // ENABLE(JAVASCRIPT_DEBUGGER)
class  InspectorDOMStorageBackendDispatcher FINAL : public Inspector::InspectorSupplementalBackendDispatcher {
public:
    static PassRefPtr<InspectorDOMStorageBackendDispatcher> create(Inspector::InspectorBackendDispatcher*, InspectorDOMStorageBackendDispatcherHandler*);
    virtual void dispatch(long callId, const String& method, PassRefPtr<Inspector::InspectorObject> message) OVERRIDE;
private:
    void enable(long callId, const Inspector::InspectorObject& message);
    void disable(long callId, const Inspector::InspectorObject& message);
    void getDOMStorageItems(long callId, const Inspector::InspectorObject& message);
    void setDOMStorageItem(long callId, const Inspector::InspectorObject& message);
    void removeDOMStorageItem(long callId, const Inspector::InspectorObject& message);
private:
    InspectorDOMStorageBackendDispatcher(Inspector::InspectorBackendDispatcher*, InspectorDOMStorageBackendDispatcherHandler*);
    InspectorDOMStorageBackendDispatcherHandler* m_agent;
};

#if ENABLE(SQL_DATABASE)
class  InspectorDatabaseBackendDispatcher FINAL : public Inspector::InspectorSupplementalBackendDispatcher {
public:
    static PassRefPtr<InspectorDatabaseBackendDispatcher> create(Inspector::InspectorBackendDispatcher*, InspectorDatabaseBackendDispatcherHandler*);
    virtual void dispatch(long callId, const String& method, PassRefPtr<Inspector::InspectorObject> message) OVERRIDE;
private:
    void enable(long callId, const Inspector::InspectorObject& message);
    void disable(long callId, const Inspector::InspectorObject& message);
    void getDatabaseTableNames(long callId, const Inspector::InspectorObject& message);
    void executeSQL(long callId, const Inspector::InspectorObject& message);
private:
    InspectorDatabaseBackendDispatcher(Inspector::InspectorBackendDispatcher*, InspectorDatabaseBackendDispatcherHandler*);
    InspectorDatabaseBackendDispatcherHandler* m_agent;
};

#endif // ENABLE(SQL_DATABASE)
class  InspectorHeapProfilerBackendDispatcher FINAL : public Inspector::InspectorSupplementalBackendDispatcher {
public:
    static PassRefPtr<InspectorHeapProfilerBackendDispatcher> create(Inspector::InspectorBackendDispatcher*, InspectorHeapProfilerBackendDispatcherHandler*);
    virtual void dispatch(long callId, const String& method, PassRefPtr<Inspector::InspectorObject> message) OVERRIDE;
private:
    void hasHeapProfiler(long callId, const Inspector::InspectorObject& message);
    void getProfileHeaders(long callId, const Inspector::InspectorObject& message);
    void getHeapSnapshot(long callId, const Inspector::InspectorObject& message);
    void removeProfile(long callId, const Inspector::InspectorObject& message);
    void clearProfiles(long callId, const Inspector::InspectorObject& message);
    void takeHeapSnapshot(long callId, const Inspector::InspectorObject& message);
    void collectGarbage(long callId, const Inspector::InspectorObject& message);
    void getObjectByHeapObjectId(long callId, const Inspector::InspectorObject& message);
    void getHeapObjectId(long callId, const Inspector::InspectorObject& message);
private:
    InspectorHeapProfilerBackendDispatcher(Inspector::InspectorBackendDispatcher*, InspectorHeapProfilerBackendDispatcherHandler*);
    InspectorHeapProfilerBackendDispatcherHandler* m_agent;
};

#if ENABLE(INDEXED_DATABASE)
class  InspectorIndexedDBBackendDispatcher FINAL : public Inspector::InspectorSupplementalBackendDispatcher {
public:
    static PassRefPtr<InspectorIndexedDBBackendDispatcher> create(Inspector::InspectorBackendDispatcher*, InspectorIndexedDBBackendDispatcherHandler*);
    virtual void dispatch(long callId, const String& method, PassRefPtr<Inspector::InspectorObject> message) OVERRIDE;
private:
    void enable(long callId, const Inspector::InspectorObject& message);
    void disable(long callId, const Inspector::InspectorObject& message);
    void requestDatabaseNames(long callId, const Inspector::InspectorObject& message);
    void requestDatabase(long callId, const Inspector::InspectorObject& message);
    void requestData(long callId, const Inspector::InspectorObject& message);
    void clearObjectStore(long callId, const Inspector::InspectorObject& message);
private:
    InspectorIndexedDBBackendDispatcher(Inspector::InspectorBackendDispatcher*, InspectorIndexedDBBackendDispatcherHandler*);
    InspectorIndexedDBBackendDispatcherHandler* m_agent;
};

#endif // ENABLE(INDEXED_DATABASE)
class  InspectorInputBackendDispatcher FINAL : public Inspector::InspectorSupplementalBackendDispatcher {
public:
    static PassRefPtr<InspectorInputBackendDispatcher> create(Inspector::InspectorBackendDispatcher*, InspectorInputBackendDispatcherHandler*);
    virtual void dispatch(long callId, const String& method, PassRefPtr<Inspector::InspectorObject> message) OVERRIDE;
private:
    void dispatchKeyEvent(long callId, const Inspector::InspectorObject& message);
    void dispatchMouseEvent(long callId, const Inspector::InspectorObject& message);
private:
    InspectorInputBackendDispatcher(Inspector::InspectorBackendDispatcher*, InspectorInputBackendDispatcherHandler*);
    InspectorInputBackendDispatcherHandler* m_agent;
};

class  InspectorLayerTreeBackendDispatcher FINAL : public Inspector::InspectorSupplementalBackendDispatcher {
public:
    static PassRefPtr<InspectorLayerTreeBackendDispatcher> create(Inspector::InspectorBackendDispatcher*, InspectorLayerTreeBackendDispatcherHandler*);
    virtual void dispatch(long callId, const String& method, PassRefPtr<Inspector::InspectorObject> message) OVERRIDE;
private:
    void enable(long callId, const Inspector::InspectorObject& message);
    void disable(long callId, const Inspector::InspectorObject& message);
    void layersForNode(long callId, const Inspector::InspectorObject& message);
    void reasonsForCompositingLayer(long callId, const Inspector::InspectorObject& message);
private:
    InspectorLayerTreeBackendDispatcher(Inspector::InspectorBackendDispatcher*, InspectorLayerTreeBackendDispatcherHandler*);
    InspectorLayerTreeBackendDispatcherHandler* m_agent;
};

class  InspectorMemoryBackendDispatcher FINAL : public Inspector::InspectorSupplementalBackendDispatcher {
public:
    static PassRefPtr<InspectorMemoryBackendDispatcher> create(Inspector::InspectorBackendDispatcher*, InspectorMemoryBackendDispatcherHandler*);
    virtual void dispatch(long callId, const String& method, PassRefPtr<Inspector::InspectorObject> message) OVERRIDE;
private:
    void getDOMCounters(long callId, const Inspector::InspectorObject& message);
private:
    InspectorMemoryBackendDispatcher(Inspector::InspectorBackendDispatcher*, InspectorMemoryBackendDispatcherHandler*);
    InspectorMemoryBackendDispatcherHandler* m_agent;
};

class  InspectorNetworkBackendDispatcher FINAL : public Inspector::InspectorSupplementalBackendDispatcher {
public:
    static PassRefPtr<InspectorNetworkBackendDispatcher> create(Inspector::InspectorBackendDispatcher*, InspectorNetworkBackendDispatcherHandler*);
    virtual void dispatch(long callId, const String& method, PassRefPtr<Inspector::InspectorObject> message) OVERRIDE;
private:
    void enable(long callId, const Inspector::InspectorObject& message);
    void disable(long callId, const Inspector::InspectorObject& message);
    void setExtraHTTPHeaders(long callId, const Inspector::InspectorObject& message);
    void getResponseBody(long callId, const Inspector::InspectorObject& message);
    void replayXHR(long callId, const Inspector::InspectorObject& message);
    void canClearBrowserCache(long callId, const Inspector::InspectorObject& message);
    void clearBrowserCache(long callId, const Inspector::InspectorObject& message);
    void canClearBrowserCookies(long callId, const Inspector::InspectorObject& message);
    void clearBrowserCookies(long callId, const Inspector::InspectorObject& message);
    void setCacheDisabled(long callId, const Inspector::InspectorObject& message);
private:
    InspectorNetworkBackendDispatcher(Inspector::InspectorBackendDispatcher*, InspectorNetworkBackendDispatcherHandler*);
    InspectorNetworkBackendDispatcherHandler* m_agent;
};

class  InspectorPageBackendDispatcher FINAL : public Inspector::InspectorSupplementalBackendDispatcher {
public:
    static PassRefPtr<InspectorPageBackendDispatcher> create(Inspector::InspectorBackendDispatcher*, InspectorPageBackendDispatcherHandler*);
    virtual void dispatch(long callId, const String& method, PassRefPtr<Inspector::InspectorObject> message) OVERRIDE;
private:
    void enable(long callId, const Inspector::InspectorObject& message);
    void disable(long callId, const Inspector::InspectorObject& message);
    void addScriptToEvaluateOnLoad(long callId, const Inspector::InspectorObject& message);
    void removeScriptToEvaluateOnLoad(long callId, const Inspector::InspectorObject& message);
    void reload(long callId, const Inspector::InspectorObject& message);
    void navigate(long callId, const Inspector::InspectorObject& message);
    void getCookies(long callId, const Inspector::InspectorObject& message);
    void deleteCookie(long callId, const Inspector::InspectorObject& message);
    void getResourceTree(long callId, const Inspector::InspectorObject& message);
    void getResourceContent(long callId, const Inspector::InspectorObject& message);
    void searchInResource(long callId, const Inspector::InspectorObject& message);
    void searchInResources(long callId, const Inspector::InspectorObject& message);
    void setDocumentContent(long callId, const Inspector::InspectorObject& message);
    void setShowPaintRects(long callId, const Inspector::InspectorObject& message);
    void canShowDebugBorders(long callId, const Inspector::InspectorObject& message);
    void setShowDebugBorders(long callId, const Inspector::InspectorObject& message);
    void canShowFPSCounter(long callId, const Inspector::InspectorObject& message);
    void setShowFPSCounter(long callId, const Inspector::InspectorObject& message);
    void canContinuouslyPaint(long callId, const Inspector::InspectorObject& message);
    void setContinuousPaintingEnabled(long callId, const Inspector::InspectorObject& message);
    void getScriptExecutionStatus(long callId, const Inspector::InspectorObject& message);
    void setScriptExecutionDisabled(long callId, const Inspector::InspectorObject& message);
    void setTouchEmulationEnabled(long callId, const Inspector::InspectorObject& message);
    void setEmulatedMedia(long callId, const Inspector::InspectorObject& message);
    void getCompositingBordersVisible(long callId, const Inspector::InspectorObject& message);
    void setCompositingBordersVisible(long callId, const Inspector::InspectorObject& message);
    void snapshotNode(long callId, const Inspector::InspectorObject& message);
    void snapshotRect(long callId, const Inspector::InspectorObject& message);
    void handleJavaScriptDialog(long callId, const Inspector::InspectorObject& message);
    void archive(long callId, const Inspector::InspectorObject& message);
private:
    InspectorPageBackendDispatcher(Inspector::InspectorBackendDispatcher*, InspectorPageBackendDispatcherHandler*);
    InspectorPageBackendDispatcherHandler* m_agent;
};

#if ENABLE(JAVASCRIPT_DEBUGGER)
class  InspectorProfilerBackendDispatcher FINAL : public Inspector::InspectorSupplementalBackendDispatcher {
public:
    static PassRefPtr<InspectorProfilerBackendDispatcher> create(Inspector::InspectorBackendDispatcher*, InspectorProfilerBackendDispatcherHandler*);
    virtual void dispatch(long callId, const String& method, PassRefPtr<Inspector::InspectorObject> message) OVERRIDE;
private:
    void causesRecompilation(long callId, const Inspector::InspectorObject& message);
    void isSampling(long callId, const Inspector::InspectorObject& message);
    void hasHeapProfiler(long callId, const Inspector::InspectorObject& message);
    void enable(long callId, const Inspector::InspectorObject& message);
    void disable(long callId, const Inspector::InspectorObject& message);
    void start(long callId, const Inspector::InspectorObject& message);
    void stop(long callId, const Inspector::InspectorObject& message);
    void getProfileHeaders(long callId, const Inspector::InspectorObject& message);
    void getCPUProfile(long callId, const Inspector::InspectorObject& message);
    void getHeapSnapshot(long callId, const Inspector::InspectorObject& message);
    void removeProfile(long callId, const Inspector::InspectorObject& message);
    void clearProfiles(long callId, const Inspector::InspectorObject& message);
    void takeHeapSnapshot(long callId, const Inspector::InspectorObject& message);
    void collectGarbage(long callId, const Inspector::InspectorObject& message);
    void getObjectByHeapObjectId(long callId, const Inspector::InspectorObject& message);
    void getHeapObjectId(long callId, const Inspector::InspectorObject& message);
private:
    InspectorProfilerBackendDispatcher(Inspector::InspectorBackendDispatcher*, InspectorProfilerBackendDispatcherHandler*);
    InspectorProfilerBackendDispatcherHandler* m_agent;
};

#endif // ENABLE(JAVASCRIPT_DEBUGGER)
class  InspectorTimelineBackendDispatcher FINAL : public Inspector::InspectorSupplementalBackendDispatcher {
public:
    static PassRefPtr<InspectorTimelineBackendDispatcher> create(Inspector::InspectorBackendDispatcher*, InspectorTimelineBackendDispatcherHandler*);
    virtual void dispatch(long callId, const String& method, PassRefPtr<Inspector::InspectorObject> message) OVERRIDE;
private:
    void start(long callId, const Inspector::InspectorObject& message);
    void stop(long callId, const Inspector::InspectorObject& message);
    void supportsFrameInstrumentation(long callId, const Inspector::InspectorObject& message);
    void canMonitorMainThread(long callId, const Inspector::InspectorObject& message);
private:
    InspectorTimelineBackendDispatcher(Inspector::InspectorBackendDispatcher*, InspectorTimelineBackendDispatcherHandler*);
    InspectorTimelineBackendDispatcherHandler* m_agent;
};

class  InspectorWorkerBackendDispatcher FINAL : public Inspector::InspectorSupplementalBackendDispatcher {
public:
    static PassRefPtr<InspectorWorkerBackendDispatcher> create(Inspector::InspectorBackendDispatcher*, InspectorWorkerBackendDispatcherHandler*);
    virtual void dispatch(long callId, const String& method, PassRefPtr<Inspector::InspectorObject> message) OVERRIDE;
private:
    void enable(long callId, const Inspector::InspectorObject& message);
    void disable(long callId, const Inspector::InspectorObject& message);
    void sendMessageToWorker(long callId, const Inspector::InspectorObject& message);
    void canInspectWorkers(long callId, const Inspector::InspectorObject& message);
    void connectToWorker(long callId, const Inspector::InspectorObject& message);
    void disconnectFromWorker(long callId, const Inspector::InspectorObject& message);
    void setAutoconnectToWorkers(long callId, const Inspector::InspectorObject& message);
private:
    InspectorWorkerBackendDispatcher(Inspector::InspectorBackendDispatcher*, InspectorWorkerBackendDispatcherHandler*);
    InspectorWorkerBackendDispatcherHandler* m_agent;
};


} // namespace Inspector

#endif // !defined(InspectorWebBackendDispatchers_h)
