/*
 * THIS FILE WAS AUTOMATICALLY GENERATED, DO NOT EDIT.
 *
 * This file was generated by the dom/make_names.pl script.
 *
 * Copyright (C) 2005, 2006, 2007, 2008, 2009, 2013 Apple Inc.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE COMPUTER, INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE COMPUTER, INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "config.h"

#if ENABLE(SVG)

#include "SVGElementFactory.h"

#include "SVGNames.h"

#include "SVGAElement.h"
#include "SVGAnimateElement.h"
#include "SVGAnimateColorElement.h"
#include "SVGAnimateMotionElement.h"
#include "SVGAnimateTransformElement.h"
#include "SVGCircleElement.h"
#include "SVGClipPathElement.h"
#include "SVGCursorElement.h"
#include "SVGDefsElement.h"
#include "SVGDescElement.h"
#include "SVGEllipseElement.h"
#include "SVGForeignObjectElement.h"
#include "SVGGElement.h"
#include "SVGImageElement.h"
#include "SVGLineElement.h"
#include "SVGLinearGradientElement.h"
#include "SVGMarkerElement.h"
#include "SVGMaskElement.h"
#include "SVGMetadataElement.h"
#include "SVGMPathElement.h"
#include "SVGPathElement.h"
#include "SVGPatternElement.h"
#include "SVGPolygonElement.h"
#include "SVGPolylineElement.h"
#include "SVGRadialGradientElement.h"
#include "SVGRectElement.h"
#include "SVGScriptElement.h"
#include "SVGSetElement.h"
#include "SVGStopElement.h"
#include "SVGStyleElement.h"
#include "SVGSVGElement.h"
#include "SVGSwitchElement.h"
#include "SVGSymbolElement.h"
#include "SVGTextElement.h"
#include "SVGTextPathElement.h"
#include "SVGTitleElement.h"
#include "SVGTRefElement.h"
#include "SVGTSpanElement.h"
#include "SVGUseElement.h"
#include "SVGViewElement.h"
#include "SVGUnknownElement.h"

#include "Document.h"
#include "RuntimeEnabledFeatures.h"
#include "Settings.h"
#include <wtf/HashMap.h>
#include <wtf/NeverDestroyed.h>

namespace WebCore {

using namespace SVGNames;

typedef PassRefPtr<SVGElement> (*SVGConstructorFunction)(const QualifiedName&, Document&, bool createdByParser);

static PassRefPtr<SVGElement> aConstructor(const QualifiedName& tagName, Document& document, bool)
{
    return SVGAElement::create(tagName, document);
}

static PassRefPtr<SVGElement> animateConstructor(const QualifiedName& tagName, Document& document, bool)
{
    return SVGAnimateElement::create(tagName, document);
}

static PassRefPtr<SVGElement> animatecolorConstructor(const QualifiedName& tagName, Document& document, bool)
{
    return SVGAnimateColorElement::create(tagName, document);
}

static PassRefPtr<SVGElement> animatemotionConstructor(const QualifiedName& tagName, Document& document, bool)
{
    return SVGAnimateMotionElement::create(tagName, document);
}

static PassRefPtr<SVGElement> animatetransformConstructor(const QualifiedName& tagName, Document& document, bool)
{
    return SVGAnimateTransformElement::create(tagName, document);
}

static PassRefPtr<SVGElement> circleConstructor(const QualifiedName& tagName, Document& document, bool)
{
    return SVGCircleElement::create(tagName, document);
}

static PassRefPtr<SVGElement> clippathConstructor(const QualifiedName& tagName, Document& document, bool)
{
    return SVGClipPathElement::create(tagName, document);
}

static PassRefPtr<SVGElement> cursorConstructor(const QualifiedName& tagName, Document& document, bool)
{
    return SVGCursorElement::create(tagName, document);
}

static PassRefPtr<SVGElement> defsConstructor(const QualifiedName& tagName, Document& document, bool)
{
    return SVGDefsElement::create(tagName, document);
}

static PassRefPtr<SVGElement> descConstructor(const QualifiedName& tagName, Document& document, bool)
{
    return SVGDescElement::create(tagName, document);
}

static PassRefPtr<SVGElement> ellipseConstructor(const QualifiedName& tagName, Document& document, bool)
{
    return SVGEllipseElement::create(tagName, document);
}

static PassRefPtr<SVGElement> foreignobjectConstructor(const QualifiedName& tagName, Document& document, bool)
{
    return SVGForeignObjectElement::create(tagName, document);
}

static PassRefPtr<SVGElement> gConstructor(const QualifiedName& tagName, Document& document, bool)
{
    return SVGGElement::create(tagName, document);
}

static PassRefPtr<SVGElement> imageConstructor(const QualifiedName& tagName, Document& document, bool)
{
    return SVGImageElement::create(tagName, document);
}

static PassRefPtr<SVGElement> lineConstructor(const QualifiedName& tagName, Document& document, bool)
{
    return SVGLineElement::create(tagName, document);
}

static PassRefPtr<SVGElement> lineargradientConstructor(const QualifiedName& tagName, Document& document, bool)
{
    return SVGLinearGradientElement::create(tagName, document);
}

static PassRefPtr<SVGElement> markerConstructor(const QualifiedName& tagName, Document& document, bool)
{
    return SVGMarkerElement::create(tagName, document);
}

static PassRefPtr<SVGElement> maskConstructor(const QualifiedName& tagName, Document& document, bool)
{
    return SVGMaskElement::create(tagName, document);
}

static PassRefPtr<SVGElement> metadataConstructor(const QualifiedName& tagName, Document& document, bool)
{
    return SVGMetadataElement::create(tagName, document);
}

static PassRefPtr<SVGElement> mpathConstructor(const QualifiedName& tagName, Document& document, bool)
{
    return SVGMPathElement::create(tagName, document);
}

static PassRefPtr<SVGElement> pathConstructor(const QualifiedName& tagName, Document& document, bool)
{
    return SVGPathElement::create(tagName, document);
}

static PassRefPtr<SVGElement> patternConstructor(const QualifiedName& tagName, Document& document, bool)
{
    return SVGPatternElement::create(tagName, document);
}

static PassRefPtr<SVGElement> polygonConstructor(const QualifiedName& tagName, Document& document, bool)
{
    return SVGPolygonElement::create(tagName, document);
}

static PassRefPtr<SVGElement> polylineConstructor(const QualifiedName& tagName, Document& document, bool)
{
    return SVGPolylineElement::create(tagName, document);
}

static PassRefPtr<SVGElement> radialgradientConstructor(const QualifiedName& tagName, Document& document, bool)
{
    return SVGRadialGradientElement::create(tagName, document);
}

static PassRefPtr<SVGElement> rectConstructor(const QualifiedName& tagName, Document& document, bool)
{
    return SVGRectElement::create(tagName, document);
}

static PassRefPtr<SVGElement> scriptConstructor(const QualifiedName& tagName, Document& document, bool createdByParser)
{
    return SVGScriptElement::create(tagName, document, createdByParser);
}

static PassRefPtr<SVGElement> setConstructor(const QualifiedName& tagName, Document& document, bool)
{
    return SVGSetElement::create(tagName, document);
}

static PassRefPtr<SVGElement> stopConstructor(const QualifiedName& tagName, Document& document, bool)
{
    return SVGStopElement::create(tagName, document);
}

static PassRefPtr<SVGElement> styleConstructor(const QualifiedName& tagName, Document& document, bool createdByParser)
{
    return SVGStyleElement::create(tagName, document, createdByParser);
}

static PassRefPtr<SVGElement> svgConstructor(const QualifiedName& tagName, Document& document, bool)
{
    return SVGSVGElement::create(tagName, document);
}

static PassRefPtr<SVGElement> switchConstructor(const QualifiedName& tagName, Document& document, bool)
{
    return SVGSwitchElement::create(tagName, document);
}

static PassRefPtr<SVGElement> symbolConstructor(const QualifiedName& tagName, Document& document, bool)
{
    return SVGSymbolElement::create(tagName, document);
}

static PassRefPtr<SVGElement> textConstructor(const QualifiedName& tagName, Document& document, bool)
{
    return SVGTextElement::create(tagName, document);
}

static PassRefPtr<SVGElement> textpathConstructor(const QualifiedName& tagName, Document& document, bool)
{
    return SVGTextPathElement::create(tagName, document);
}

static PassRefPtr<SVGElement> titleConstructor(const QualifiedName& tagName, Document& document, bool)
{
    return SVGTitleElement::create(tagName, document);
}

static PassRefPtr<SVGElement> trefConstructor(const QualifiedName& tagName, Document& document, bool)
{
    return SVGTRefElement::create(tagName, document);
}

static PassRefPtr<SVGElement> tspanConstructor(const QualifiedName& tagName, Document& document, bool)
{
    return SVGTSpanElement::create(tagName, document);
}

static PassRefPtr<SVGElement> useConstructor(const QualifiedName& tagName, Document& document, bool createdByParser)
{
    return SVGUseElement::create(tagName, document, createdByParser);
}

static PassRefPtr<SVGElement> viewConstructor(const QualifiedName& tagName, Document& document, bool)
{
    return SVGViewElement::create(tagName, document);
}

static NEVER_INLINE void populateSVGFactoryMap(HashMap<AtomicStringImpl*, SVGConstructorFunction>& map)
{
    struct TableEntry {
        const QualifiedName& name;
        SVGConstructorFunction function;
    };

    static const TableEntry table[] = {
        { aTag, aConstructor },
        { animateTag, animateConstructor },
        { animateColorTag, animatecolorConstructor },
        { animateMotionTag, animatemotionConstructor },
        { animateTransformTag, animatetransformConstructor },
        { circleTag, circleConstructor },
        { clipPathTag, clippathConstructor },
        { cursorTag, cursorConstructor },
        { defsTag, defsConstructor },
        { descTag, descConstructor },
        { ellipseTag, ellipseConstructor },
        { foreignObjectTag, foreignobjectConstructor },
        { gTag, gConstructor },
        { imageTag, imageConstructor },
        { lineTag, lineConstructor },
        { linearGradientTag, lineargradientConstructor },
        { markerTag, markerConstructor },
        { maskTag, maskConstructor },
        { metadataTag, metadataConstructor },
        { mpathTag, mpathConstructor },
        { pathTag, pathConstructor },
        { patternTag, patternConstructor },
        { polygonTag, polygonConstructor },
        { polylineTag, polylineConstructor },
        { radialGradientTag, radialgradientConstructor },
        { rectTag, rectConstructor },
        { scriptTag, scriptConstructor },
        { setTag, setConstructor },
        { stopTag, stopConstructor },
        { styleTag, styleConstructor },
        { svgTag, svgConstructor },
        { switchTag, switchConstructor },
        { symbolTag, symbolConstructor },
        { textTag, textConstructor },
        { textPathTag, textpathConstructor },
        { titleTag, titleConstructor },
        { trefTag, trefConstructor },
        { tspanTag, tspanConstructor },
        { useTag, useConstructor },
        { viewTag, viewConstructor },
    };

    for (unsigned i = 0; i < WTF_ARRAY_LENGTH(table); ++i)
        map.add(table[i].name.localName().impl(), table[i].function);
}

PassRefPtr<SVGElement> SVGElementFactory::createElement(const QualifiedName& name, Document& document, bool createdByParser)
{
    static NeverDestroyed<HashMap<AtomicStringImpl*, SVGConstructorFunction>> functions;
    if (functions.get().isEmpty())
        populateSVGFactoryMap(functions);
    if (SVGConstructorFunction function = functions.get().get(name.localName().impl())) {
        if (RefPtr<SVGElement> element = function(name, document, createdByParser))
            return element.release();
   }
   return SVGUnknownElement::create(name, document);
}

} // namespace WebCore

#endif
