// File is generated by JavaScriptCore/inspector/scripts/CodeGeneratorInspector.py

// Copyright (c) 2013 Apple Inc. All Rights Reserved.
// Copyright (c) 2011 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef InspectorWebTypeBuilders_h
#define InspectorWebTypeBuilders_h

#if ENABLE(INSPECTOR)

#include <inspector/InspectorTypeBuilder.h>
#include <inspector/InspectorJSTypeBuilders.h>
#include <wtf/Assertions.h>
#include <wtf/PassRefPtr.h>

namespace Inspector {

namespace TypeBuilder {

// Forward declarations.
namespace Page {
class FrameResourceTree;
} // Page

namespace CSS {
class RuleMatch;
class CSSRule;
class SourceRange;
class CSSStyle;
class CSSProperty;
class CSSMedia;
} // CSS

namespace Console {
class CallFrame;
} // Console

namespace DOM {
class Node;
} // DOM

#if ENABLE(INDEXED_DATABASE)
namespace IndexedDB {
class ObjectStore;
class ObjectStoreIndex;
class Key;
class KeyPath;
} // IndexedDB

#endif // ENABLE(INDEXED_DATABASE)
namespace Memory {
class MemoryBlock;
} // Memory

#if ENABLE(JAVASCRIPT_DEBUGGER)
namespace Profiler {
class CPUProfileNode;
} // Profiler

#endif // ENABLE(JAVASCRIPT_DEBUGGER)
namespace Timeline {
class TimelineEvent;
} // Timeline

// End of forward declarations.

// Typedefs.
namespace Page {
/* Unique script identifier. */
typedef String ScriptIdentifier;

} // Page

namespace CSS {
typedef String StyleSheetId;

} // CSS

namespace Canvas {
/* Unique resource identifier. */
typedef String ResourceId;

/* Unique trace log identifier. */
typedef String TraceLogId;

} // Canvas

#if ENABLE(SQL_DATABASE)
namespace Database {
/* Unique identifier of Database object. */
typedef String DatabaseId;

} // Database

#endif // ENABLE(SQL_DATABASE)
namespace HeapProfiler {
/* Heap snashot object id. */
typedef String HeapSnapshotObjectId;

} // HeapProfiler

namespace LayerTree {
/* Unique RenderLayer identifier. */
typedef String LayerId;

/* Unique PseudoElement identifier. */
typedef String PseudoElementId;

} // LayerTree

namespace Network {
/* Unique loader identifier. */
typedef String LoaderId;

/* Unique frame identifier. */
typedef String FrameId;

/* Unique request identifier. */
typedef String RequestId;

} // Network

#if ENABLE(JAVASCRIPT_DEBUGGER)
namespace Profiler {
/* Heap snashot object id. */
typedef String HeapSnapshotObjectId;

} // Profiler

#endif // ENABLE(JAVASCRIPT_DEBUGGER)
// End of typedefs.



 String getWebEnumConstantValue(int code);

namespace Page {
/* Resource type as it was perceived by the rendering engine. */
struct ResourceType {
    enum Enum {
        Document = 0,
        Stylesheet = 1,
        Image = 2,
        Font = 3,
        Script = 4,
        XHR = 5,
        WebSocket = 6,
        Other = 7,
    };
}; // struct ResourceType
/* Coordinate system used by supplied coordinates. */
struct CoordinateSystem {
    enum Enum {
        Viewport = 8,
        Page = 9,
    };
}; // struct CoordinateSystem
/* Information about the Frame on the page. */
class Frame : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        IdSet = 1 << 0,
        LoaderIdSet = 1 << 1,
        UrlSet = 1 << 2,
        SecurityOriginSet = 1 << 3,
        MimeTypeSet = 1 << 4,
        AllFieldsSet = (IdSet | LoaderIdSet | UrlSet | SecurityOriginSet | MimeTypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*Frame*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class Frame;
    public:

        Builder<STATE | IdSet>& setId(const String& value)
        {
            COMPILE_ASSERT(!(STATE & IdSet), property_id_already_set);
            m_result->setString(ASCIILiteral("id"), value);
            return castState<IdSet>();
        }

        Builder<STATE | LoaderIdSet>& setLoaderId(const Inspector::TypeBuilder::Network::LoaderId& value)
        {
            COMPILE_ASSERT(!(STATE & LoaderIdSet), property_loaderId_already_set);
            m_result->setString(ASCIILiteral("loaderId"), value);
            return castState<LoaderIdSet>();
        }

        Builder<STATE | UrlSet>& setUrl(const String& value)
        {
            COMPILE_ASSERT(!(STATE & UrlSet), property_url_already_set);
            m_result->setString(ASCIILiteral("url"), value);
            return castState<UrlSet>();
        }

        Builder<STATE | SecurityOriginSet>& setSecurityOrigin(const String& value)
        {
            COMPILE_ASSERT(!(STATE & SecurityOriginSet), property_securityOrigin_already_set);
            m_result->setString(ASCIILiteral("securityOrigin"), value);
            return castState<SecurityOriginSet>();
        }

        Builder<STATE | MimeTypeSet>& setMimeType(const String& value)
        {
            COMPILE_ASSERT(!(STATE & MimeTypeSet), property_mimeType_already_set);
            m_result->setString(ASCIILiteral("mimeType"), value);
            return castState<MimeTypeSet>();
        }

        operator RefPtr<Frame>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Frame) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<Frame>*>(&m_result);
        }

        PassRefPtr<Frame> release()
        {
            return RefPtr<Frame>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Frame> result = Frame::create()
     *     .setId(...)
     *     .setLoaderId(...)
     *     .setUrl(...)
     *     .setSecurityOrigin(...)
     *     .setMimeType(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;

    void setParentId(const String& value)
    {
        this->setString(ASCIILiteral("parentId"), value);
    }

    void setName(const String& value)
    {
        this->setString(ASCIILiteral("name"), value);
    }
};

/* Information about the Frame hierarchy along with their cached resources. */
class FrameResourceTree : public Inspector::InspectorObjectBase {
public:
    // Named after property name 'resources' while generating FrameResourceTree.
    class Resources : public Inspector::InspectorObjectBase {
    public:
        enum {
            NoFieldsSet = 0,
            UrlSet = 1 << 0,
            TypeSet = 1 << 1,
            MimeTypeSet = 1 << 2,
            AllFieldsSet = (UrlSet | TypeSet | MimeTypeSet)
        };

        template<int STATE>
        class Builder {
        private:
            RefPtr<Inspector::InspectorObject> m_result;

            template<int STEP> Builder<STATE | STEP>& castState()
            {
                return *reinterpret_cast<Builder<STATE | STEP>*>(this);
            }

            Builder(PassRefPtr</*Resources*/Inspector::InspectorObject> ptr)
            {
                COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
                m_result = ptr;
            }
            friend class Resources;
        public:
    
            Builder<STATE | UrlSet>& setUrl(const String& value)
            {
                COMPILE_ASSERT(!(STATE & UrlSet), property_url_already_set);
                m_result->setString(ASCIILiteral("url"), value);
                return castState<UrlSet>();
            }
    
            Builder<STATE | TypeSet>& setType(Inspector::TypeBuilder::Page::ResourceType::Enum value)
            {
                COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
                m_result->setString(ASCIILiteral("type"), Inspector::TypeBuilder::getWebEnumConstantValue(value));
                return castState<TypeSet>();
            }
    
            Builder<STATE | MimeTypeSet>& setMimeType(const String& value)
            {
                COMPILE_ASSERT(!(STATE & MimeTypeSet), property_mimeType_already_set);
                m_result->setString(ASCIILiteral("mimeType"), value);
                return castState<MimeTypeSet>();
            }
    
            operator RefPtr<Resources>& ()
            {
                COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
                COMPILE_ASSERT(sizeof(Resources) == sizeof(Inspector::InspectorObject), cannot_cast);
                return *reinterpret_cast<RefPtr<Resources>*>(&m_result);
            }

            PassRefPtr<Resources> release()
            {
                return RefPtr<Resources>(*this).release();
            }
        };

        /*
         * Synthetic constructor:
         * RefPtr<Resources> result = Resources::create()
         *     .setUrl(...)
         *     .setType(...)
         *     .setMimeType(...);
         */
        static Builder<NoFieldsSet> create()
        {
            return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
        }
        typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;

        void setFailed(bool value)
        {
            this->setBoolean(ASCIILiteral("failed"), value);
        }

        void setCanceled(bool value)
        {
            this->setBoolean(ASCIILiteral("canceled"), value);
        }

        void setSourceMapURL(const String& value)
        {
            this->setString(ASCIILiteral("sourceMapURL"), value);
        }
    };

    enum {
        NoFieldsSet = 0,
        FrameSet = 1 << 0,
        ResourcesSet = 1 << 1,
        AllFieldsSet = (FrameSet | ResourcesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*FrameResourceTree*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class FrameResourceTree;
    public:

        Builder<STATE | FrameSet>& setFrame(PassRefPtr<Inspector::TypeBuilder::Page::Frame> value)
        {
            COMPILE_ASSERT(!(STATE & FrameSet), property_frame_already_set);
            m_result->setValue(ASCIILiteral("frame"), value);
            return castState<FrameSet>();
        }

        Builder<STATE | ResourcesSet>& setResources(PassRefPtr<Inspector::TypeBuilder::Array<Resources> > value)
        {
            COMPILE_ASSERT(!(STATE & ResourcesSet), property_resources_already_set);
            m_result->setValue(ASCIILiteral("resources"), value);
            return castState<ResourcesSet>();
        }

        operator RefPtr<FrameResourceTree>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(FrameResourceTree) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<FrameResourceTree>*>(&m_result);
        }

        PassRefPtr<FrameResourceTree> release()
        {
            return RefPtr<FrameResourceTree>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<FrameResourceTree> result = FrameResourceTree::create()
     *     .setFrame(...)
     *     .setResources(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;

    void setChildFrames(PassRefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::Page::FrameResourceTree> > value)
    {
        this->setValue(ASCIILiteral("childFrames"), value);
    }
};

/* Search result for resource. */
class SearchResult : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        UrlSet = 1 << 0,
        FrameIdSet = 1 << 1,
        MatchesCountSet = 1 << 2,
        AllFieldsSet = (UrlSet | FrameIdSet | MatchesCountSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*SearchResult*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class SearchResult;
    public:

        Builder<STATE | UrlSet>& setUrl(const String& value)
        {
            COMPILE_ASSERT(!(STATE & UrlSet), property_url_already_set);
            m_result->setString(ASCIILiteral("url"), value);
            return castState<UrlSet>();
        }

        Builder<STATE | FrameIdSet>& setFrameId(const Inspector::TypeBuilder::Network::FrameId& value)
        {
            COMPILE_ASSERT(!(STATE & FrameIdSet), property_frameId_already_set);
            m_result->setString(ASCIILiteral("frameId"), value);
            return castState<FrameIdSet>();
        }

        Builder<STATE | MatchesCountSet>& setMatchesCount(double value)
        {
            COMPILE_ASSERT(!(STATE & MatchesCountSet), property_matchesCount_already_set);
            m_result->setNumber(ASCIILiteral("matchesCount"), value);
            return castState<MatchesCountSet>();
        }

        operator RefPtr<SearchResult>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(SearchResult) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<SearchResult>*>(&m_result);
        }

        PassRefPtr<SearchResult> release()
        {
            return RefPtr<SearchResult>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<SearchResult> result = SearchResult::create()
     *     .setUrl(...)
     *     .setFrameId(...)
     *     .setMatchesCount(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;
};

/* Cookie object */
class Cookie : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        ValueSet = 1 << 1,
        DomainSet = 1 << 2,
        PathSet = 1 << 3,
        ExpiresSet = 1 << 4,
        SizeSet = 1 << 5,
        HttpOnlySet = 1 << 6,
        SecureSet = 1 << 7,
        SessionSet = 1 << 8,
        AllFieldsSet = (NameSet | ValueSet | DomainSet | PathSet | ExpiresSet | SizeSet | HttpOnlySet | SecureSet | SessionSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*Cookie*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class Cookie;
    public:

        Builder<STATE | NameSet>& setName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString(ASCIILiteral("name"), value);
            return castState<NameSet>();
        }

        Builder<STATE | ValueSet>& setValue(const String& value)
        {
            COMPILE_ASSERT(!(STATE & ValueSet), property_value_already_set);
            m_result->setString(ASCIILiteral("value"), value);
            return castState<ValueSet>();
        }

        Builder<STATE | DomainSet>& setDomain(const String& value)
        {
            COMPILE_ASSERT(!(STATE & DomainSet), property_domain_already_set);
            m_result->setString(ASCIILiteral("domain"), value);
            return castState<DomainSet>();
        }

        Builder<STATE | PathSet>& setPath(const String& value)
        {
            COMPILE_ASSERT(!(STATE & PathSet), property_path_already_set);
            m_result->setString(ASCIILiteral("path"), value);
            return castState<PathSet>();
        }

        Builder<STATE | ExpiresSet>& setExpires(double value)
        {
            COMPILE_ASSERT(!(STATE & ExpiresSet), property_expires_already_set);
            m_result->setNumber(ASCIILiteral("expires"), value);
            return castState<ExpiresSet>();
        }

        Builder<STATE | SizeSet>& setSize(int value)
        {
            COMPILE_ASSERT(!(STATE & SizeSet), property_size_already_set);
            m_result->setNumber(ASCIILiteral("size"), value);
            return castState<SizeSet>();
        }

        Builder<STATE | HttpOnlySet>& setHttpOnly(bool value)
        {
            COMPILE_ASSERT(!(STATE & HttpOnlySet), property_httpOnly_already_set);
            m_result->setBoolean(ASCIILiteral("httpOnly"), value);
            return castState<HttpOnlySet>();
        }

        Builder<STATE | SecureSet>& setSecure(bool value)
        {
            COMPILE_ASSERT(!(STATE & SecureSet), property_secure_already_set);
            m_result->setBoolean(ASCIILiteral("secure"), value);
            return castState<SecureSet>();
        }

        Builder<STATE | SessionSet>& setSession(bool value)
        {
            COMPILE_ASSERT(!(STATE & SessionSet), property_session_already_set);
            m_result->setBoolean(ASCIILiteral("session"), value);
            return castState<SessionSet>();
        }

        operator RefPtr<Cookie>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Cookie) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<Cookie>*>(&m_result);
        }

        PassRefPtr<Cookie> release()
        {
            return RefPtr<Cookie>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Cookie> result = Cookie::create()
     *     .setName(...)
     *     .setValue(...)
     *     .setDomain(...)
     *     .setPath(...)
     *     .setExpires(...)
     *     .setSize(...)
     *     .setHttpOnly(...)
     *     .setSecure(...)
     *     .setSession(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;
};

} // Page

namespace ApplicationCache {
/* Detailed application cache resource information. */
class ApplicationCacheResource : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        UrlSet = 1 << 0,
        SizeSet = 1 << 1,
        TypeSet = 1 << 2,
        AllFieldsSet = (UrlSet | SizeSet | TypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*ApplicationCacheResource*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class ApplicationCacheResource;
    public:

        Builder<STATE | UrlSet>& setUrl(const String& value)
        {
            COMPILE_ASSERT(!(STATE & UrlSet), property_url_already_set);
            m_result->setString(ASCIILiteral("url"), value);
            return castState<UrlSet>();
        }

        Builder<STATE | SizeSet>& setSize(int value)
        {
            COMPILE_ASSERT(!(STATE & SizeSet), property_size_already_set);
            m_result->setNumber(ASCIILiteral("size"), value);
            return castState<SizeSet>();
        }

        Builder<STATE | TypeSet>& setType(const String& value)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString(ASCIILiteral("type"), value);
            return castState<TypeSet>();
        }

        operator RefPtr<ApplicationCacheResource>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(ApplicationCacheResource) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<ApplicationCacheResource>*>(&m_result);
        }

        PassRefPtr<ApplicationCacheResource> release()
        {
            return RefPtr<ApplicationCacheResource>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<ApplicationCacheResource> result = ApplicationCacheResource::create()
     *     .setUrl(...)
     *     .setSize(...)
     *     .setType(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;
};

/* Detailed application cache information. */
class ApplicationCache : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        ManifestURLSet = 1 << 0,
        SizeSet = 1 << 1,
        CreationTimeSet = 1 << 2,
        UpdateTimeSet = 1 << 3,
        ResourcesSet = 1 << 4,
        AllFieldsSet = (ManifestURLSet | SizeSet | CreationTimeSet | UpdateTimeSet | ResourcesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*ApplicationCache*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class ApplicationCache;
    public:

        Builder<STATE | ManifestURLSet>& setManifestURL(const String& value)
        {
            COMPILE_ASSERT(!(STATE & ManifestURLSet), property_manifestURL_already_set);
            m_result->setString(ASCIILiteral("manifestURL"), value);
            return castState<ManifestURLSet>();
        }

        Builder<STATE | SizeSet>& setSize(double value)
        {
            COMPILE_ASSERT(!(STATE & SizeSet), property_size_already_set);
            m_result->setNumber(ASCIILiteral("size"), value);
            return castState<SizeSet>();
        }

        Builder<STATE | CreationTimeSet>& setCreationTime(double value)
        {
            COMPILE_ASSERT(!(STATE & CreationTimeSet), property_creationTime_already_set);
            m_result->setNumber(ASCIILiteral("creationTime"), value);
            return castState<CreationTimeSet>();
        }

        Builder<STATE | UpdateTimeSet>& setUpdateTime(double value)
        {
            COMPILE_ASSERT(!(STATE & UpdateTimeSet), property_updateTime_already_set);
            m_result->setNumber(ASCIILiteral("updateTime"), value);
            return castState<UpdateTimeSet>();
        }

        Builder<STATE | ResourcesSet>& setResources(PassRefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::ApplicationCache::ApplicationCacheResource> > value)
        {
            COMPILE_ASSERT(!(STATE & ResourcesSet), property_resources_already_set);
            m_result->setValue(ASCIILiteral("resources"), value);
            return castState<ResourcesSet>();
        }

        operator RefPtr<ApplicationCache>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(ApplicationCache) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<ApplicationCache>*>(&m_result);
        }

        PassRefPtr<ApplicationCache> release()
        {
            return RefPtr<ApplicationCache>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<ApplicationCache> result = ApplicationCache::create()
     *     .setManifestURL(...)
     *     .setSize(...)
     *     .setCreationTime(...)
     *     .setUpdateTime(...)
     *     .setResources(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;
};

/* Frame identifier - manifest URL pair. */
class FrameWithManifest : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        FrameIdSet = 1 << 0,
        ManifestURLSet = 1 << 1,
        StatusSet = 1 << 2,
        AllFieldsSet = (FrameIdSet | ManifestURLSet | StatusSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*FrameWithManifest*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class FrameWithManifest;
    public:

        Builder<STATE | FrameIdSet>& setFrameId(const Inspector::TypeBuilder::Network::FrameId& value)
        {
            COMPILE_ASSERT(!(STATE & FrameIdSet), property_frameId_already_set);
            m_result->setString(ASCIILiteral("frameId"), value);
            return castState<FrameIdSet>();
        }

        Builder<STATE | ManifestURLSet>& setManifestURL(const String& value)
        {
            COMPILE_ASSERT(!(STATE & ManifestURLSet), property_manifestURL_already_set);
            m_result->setString(ASCIILiteral("manifestURL"), value);
            return castState<ManifestURLSet>();
        }

        Builder<STATE | StatusSet>& setStatus(int value)
        {
            COMPILE_ASSERT(!(STATE & StatusSet), property_status_already_set);
            m_result->setNumber(ASCIILiteral("status"), value);
            return castState<StatusSet>();
        }

        operator RefPtr<FrameWithManifest>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(FrameWithManifest) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<FrameWithManifest>*>(&m_result);
        }

        PassRefPtr<FrameWithManifest> release()
        {
            return RefPtr<FrameWithManifest>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<FrameWithManifest> result = FrameWithManifest::create()
     *     .setFrameId(...)
     *     .setManifestURL(...)
     *     .setStatus(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;
};

} // ApplicationCache

namespace CSS {
/* This object identifies a CSS style in a unique way. */
class CSSStyleId : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        StyleSheetIdSet = 1 << 0,
        OrdinalSet = 1 << 1,
        AllFieldsSet = (StyleSheetIdSet | OrdinalSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*CSSStyleId*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class CSSStyleId;
    public:

        Builder<STATE | StyleSheetIdSet>& setStyleSheetId(const Inspector::TypeBuilder::CSS::StyleSheetId& value)
        {
            COMPILE_ASSERT(!(STATE & StyleSheetIdSet), property_styleSheetId_already_set);
            m_result->setString(ASCIILiteral("styleSheetId"), value);
            return castState<StyleSheetIdSet>();
        }

        Builder<STATE | OrdinalSet>& setOrdinal(int value)
        {
            COMPILE_ASSERT(!(STATE & OrdinalSet), property_ordinal_already_set);
            m_result->setNumber(ASCIILiteral("ordinal"), value);
            return castState<OrdinalSet>();
        }

        operator RefPtr<CSSStyleId>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CSSStyleId) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<CSSStyleId>*>(&m_result);
        }

        PassRefPtr<CSSStyleId> release()
        {
            return RefPtr<CSSStyleId>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CSSStyleId> result = CSSStyleId::create()
     *     .setStyleSheetId(...)
     *     .setOrdinal(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;
};

/* Stylesheet type: "user" for user stylesheets, "user-agent" for user-agent stylesheets, "inspector" for stylesheets created by the inspector (i.e. those holding the "via inspector" rules), "regular" for regular stylesheets. */
struct StyleSheetOrigin {
    enum Enum {
        User = 10,
        UserAgent = 11,
        Inspector = 12,
        Regular = 13,
    };
}; // struct StyleSheetOrigin
/* This object identifies a CSS rule in a unique way. */
class CSSRuleId : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        StyleSheetIdSet = 1 << 0,
        OrdinalSet = 1 << 1,
        AllFieldsSet = (StyleSheetIdSet | OrdinalSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*CSSRuleId*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class CSSRuleId;
    public:

        Builder<STATE | StyleSheetIdSet>& setStyleSheetId(const Inspector::TypeBuilder::CSS::StyleSheetId& value)
        {
            COMPILE_ASSERT(!(STATE & StyleSheetIdSet), property_styleSheetId_already_set);
            m_result->setString(ASCIILiteral("styleSheetId"), value);
            return castState<StyleSheetIdSet>();
        }

        Builder<STATE | OrdinalSet>& setOrdinal(int value)
        {
            COMPILE_ASSERT(!(STATE & OrdinalSet), property_ordinal_already_set);
            m_result->setNumber(ASCIILiteral("ordinal"), value);
            return castState<OrdinalSet>();
        }

        operator RefPtr<CSSRuleId>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CSSRuleId) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<CSSRuleId>*>(&m_result);
        }

        PassRefPtr<CSSRuleId> release()
        {
            return RefPtr<CSSRuleId>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CSSRuleId> result = CSSRuleId::create()
     *     .setStyleSheetId(...)
     *     .setOrdinal(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;
};

/* CSS rule collection for a single pseudo style. */
class PseudoIdMatches : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        PseudoIdSet = 1 << 0,
        MatchesSet = 1 << 1,
        AllFieldsSet = (PseudoIdSet | MatchesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*PseudoIdMatches*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class PseudoIdMatches;
    public:

        Builder<STATE | PseudoIdSet>& setPseudoId(int value)
        {
            COMPILE_ASSERT(!(STATE & PseudoIdSet), property_pseudoId_already_set);
            m_result->setNumber(ASCIILiteral("pseudoId"), value);
            return castState<PseudoIdSet>();
        }

        Builder<STATE | MatchesSet>& setMatches(PassRefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::CSS::RuleMatch> > value)
        {
            COMPILE_ASSERT(!(STATE & MatchesSet), property_matches_already_set);
            m_result->setValue(ASCIILiteral("matches"), value);
            return castState<MatchesSet>();
        }

        operator RefPtr<PseudoIdMatches>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(PseudoIdMatches) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<PseudoIdMatches>*>(&m_result);
        }

        PassRefPtr<PseudoIdMatches> release()
        {
            return RefPtr<PseudoIdMatches>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<PseudoIdMatches> result = PseudoIdMatches::create()
     *     .setPseudoId(...)
     *     .setMatches(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;
};

/* CSS rule collection for a single pseudo style. */
class InheritedStyleEntry : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        MatchedCSSRulesSet = 1 << 0,
        AllFieldsSet = (MatchedCSSRulesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*InheritedStyleEntry*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class InheritedStyleEntry;
    public:

        Builder<STATE | MatchedCSSRulesSet>& setMatchedCSSRules(PassRefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::CSS::RuleMatch> > value)
        {
            COMPILE_ASSERT(!(STATE & MatchedCSSRulesSet), property_matchedCSSRules_already_set);
            m_result->setValue(ASCIILiteral("matchedCSSRules"), value);
            return castState<MatchedCSSRulesSet>();
        }

        operator RefPtr<InheritedStyleEntry>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(InheritedStyleEntry) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<InheritedStyleEntry>*>(&m_result);
        }

        PassRefPtr<InheritedStyleEntry> release()
        {
            return RefPtr<InheritedStyleEntry>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<InheritedStyleEntry> result = InheritedStyleEntry::create()
     *     .setMatchedCSSRules(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;

    void setInlineStyle(PassRefPtr<Inspector::TypeBuilder::CSS::CSSStyle> value)
    {
        this->setValue(ASCIILiteral("inlineStyle"), value);
    }
};

/* Match data for a CSS rule. */
class RuleMatch : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        RuleSet = 1 << 0,
        MatchingSelectorsSet = 1 << 1,
        AllFieldsSet = (RuleSet | MatchingSelectorsSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*RuleMatch*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class RuleMatch;
    public:

        Builder<STATE | RuleSet>& setRule(PassRefPtr<Inspector::TypeBuilder::CSS::CSSRule> value)
        {
            COMPILE_ASSERT(!(STATE & RuleSet), property_rule_already_set);
            m_result->setValue(ASCIILiteral("rule"), value);
            return castState<RuleSet>();
        }

        Builder<STATE | MatchingSelectorsSet>& setMatchingSelectors(PassRefPtr<Inspector::TypeBuilder::Array<int> > value)
        {
            COMPILE_ASSERT(!(STATE & MatchingSelectorsSet), property_matchingSelectors_already_set);
            m_result->setValue(ASCIILiteral("matchingSelectors"), value);
            return castState<MatchingSelectorsSet>();
        }

        operator RefPtr<RuleMatch>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(RuleMatch) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<RuleMatch>*>(&m_result);
        }

        PassRefPtr<RuleMatch> release()
        {
            return RefPtr<RuleMatch>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<RuleMatch> result = RuleMatch::create()
     *     .setRule(...)
     *     .setMatchingSelectors(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;
};

/* Selector list data. */
class SelectorList : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        SelectorsSet = 1 << 0,
        TextSet = 1 << 1,
        AllFieldsSet = (SelectorsSet | TextSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*SelectorList*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class SelectorList;
    public:

        Builder<STATE | SelectorsSet>& setSelectors(PassRefPtr<Inspector::TypeBuilder::Array<String> > value)
        {
            COMPILE_ASSERT(!(STATE & SelectorsSet), property_selectors_already_set);
            m_result->setValue(ASCIILiteral("selectors"), value);
            return castState<SelectorsSet>();
        }

        Builder<STATE | TextSet>& setText(const String& value)
        {
            COMPILE_ASSERT(!(STATE & TextSet), property_text_already_set);
            m_result->setString(ASCIILiteral("text"), value);
            return castState<TextSet>();
        }

        operator RefPtr<SelectorList>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(SelectorList) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<SelectorList>*>(&m_result);
        }

        PassRefPtr<SelectorList> release()
        {
            return RefPtr<SelectorList>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<SelectorList> result = SelectorList::create()
     *     .setSelectors(...)
     *     .setText(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;

    void setRange(PassRefPtr<Inspector::TypeBuilder::CSS::SourceRange> value)
    {
        this->setValue(ASCIILiteral("range"), value);
    }
};

/* CSS style information for a DOM style attribute. */
class CSSStyleAttribute : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        StyleSet = 1 << 1,
        AllFieldsSet = (NameSet | StyleSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*CSSStyleAttribute*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class CSSStyleAttribute;
    public:

        Builder<STATE | NameSet>& setName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString(ASCIILiteral("name"), value);
            return castState<NameSet>();
        }

        Builder<STATE | StyleSet>& setStyle(PassRefPtr<Inspector::TypeBuilder::CSS::CSSStyle> value)
        {
            COMPILE_ASSERT(!(STATE & StyleSet), property_style_already_set);
            m_result->setValue(ASCIILiteral("style"), value);
            return castState<StyleSet>();
        }

        operator RefPtr<CSSStyleAttribute>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CSSStyleAttribute) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<CSSStyleAttribute>*>(&m_result);
        }

        PassRefPtr<CSSStyleAttribute> release()
        {
            return RefPtr<CSSStyleAttribute>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CSSStyleAttribute> result = CSSStyleAttribute::create()
     *     .setName(...)
     *     .setStyle(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;
};

/* CSS stylesheet metainformation. */
class CSSStyleSheetHeader : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        StyleSheetIdSet = 1 << 0,
        FrameIdSet = 1 << 1,
        SourceURLSet = 1 << 2,
        OriginSet = 1 << 3,
        TitleSet = 1 << 4,
        DisabledSet = 1 << 5,
        AllFieldsSet = (StyleSheetIdSet | FrameIdSet | SourceURLSet | OriginSet | TitleSet | DisabledSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*CSSStyleSheetHeader*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class CSSStyleSheetHeader;
    public:

        Builder<STATE | StyleSheetIdSet>& setStyleSheetId(const Inspector::TypeBuilder::CSS::StyleSheetId& value)
        {
            COMPILE_ASSERT(!(STATE & StyleSheetIdSet), property_styleSheetId_already_set);
            m_result->setString(ASCIILiteral("styleSheetId"), value);
            return castState<StyleSheetIdSet>();
        }

        Builder<STATE | FrameIdSet>& setFrameId(const Inspector::TypeBuilder::Network::FrameId& value)
        {
            COMPILE_ASSERT(!(STATE & FrameIdSet), property_frameId_already_set);
            m_result->setString(ASCIILiteral("frameId"), value);
            return castState<FrameIdSet>();
        }

        Builder<STATE | SourceURLSet>& setSourceURL(const String& value)
        {
            COMPILE_ASSERT(!(STATE & SourceURLSet), property_sourceURL_already_set);
            m_result->setString(ASCIILiteral("sourceURL"), value);
            return castState<SourceURLSet>();
        }

        Builder<STATE | OriginSet>& setOrigin(Inspector::TypeBuilder::CSS::StyleSheetOrigin::Enum value)
        {
            COMPILE_ASSERT(!(STATE & OriginSet), property_origin_already_set);
            m_result->setString(ASCIILiteral("origin"), Inspector::TypeBuilder::getWebEnumConstantValue(value));
            return castState<OriginSet>();
        }

        Builder<STATE | TitleSet>& setTitle(const String& value)
        {
            COMPILE_ASSERT(!(STATE & TitleSet), property_title_already_set);
            m_result->setString(ASCIILiteral("title"), value);
            return castState<TitleSet>();
        }

        Builder<STATE | DisabledSet>& setDisabled(bool value)
        {
            COMPILE_ASSERT(!(STATE & DisabledSet), property_disabled_already_set);
            m_result->setBoolean(ASCIILiteral("disabled"), value);
            return castState<DisabledSet>();
        }

        operator RefPtr<CSSStyleSheetHeader>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CSSStyleSheetHeader) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<CSSStyleSheetHeader>*>(&m_result);
        }

        PassRefPtr<CSSStyleSheetHeader> release()
        {
            return RefPtr<CSSStyleSheetHeader>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CSSStyleSheetHeader> result = CSSStyleSheetHeader::create()
     *     .setStyleSheetId(...)
     *     .setFrameId(...)
     *     .setSourceURL(...)
     *     .setOrigin(...)
     *     .setTitle(...)
     *     .setDisabled(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;
};

/* CSS stylesheet contents. */
class CSSStyleSheetBody : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        StyleSheetIdSet = 1 << 0,
        RulesSet = 1 << 1,
        AllFieldsSet = (StyleSheetIdSet | RulesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*CSSStyleSheetBody*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class CSSStyleSheetBody;
    public:

        Builder<STATE | StyleSheetIdSet>& setStyleSheetId(const Inspector::TypeBuilder::CSS::StyleSheetId& value)
        {
            COMPILE_ASSERT(!(STATE & StyleSheetIdSet), property_styleSheetId_already_set);
            m_result->setString(ASCIILiteral("styleSheetId"), value);
            return castState<StyleSheetIdSet>();
        }

        Builder<STATE | RulesSet>& setRules(PassRefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::CSS::CSSRule> > value)
        {
            COMPILE_ASSERT(!(STATE & RulesSet), property_rules_already_set);
            m_result->setValue(ASCIILiteral("rules"), value);
            return castState<RulesSet>();
        }

        operator RefPtr<CSSStyleSheetBody>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CSSStyleSheetBody) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<CSSStyleSheetBody>*>(&m_result);
        }

        PassRefPtr<CSSStyleSheetBody> release()
        {
            return RefPtr<CSSStyleSheetBody>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CSSStyleSheetBody> result = CSSStyleSheetBody::create()
     *     .setStyleSheetId(...)
     *     .setRules(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;

    void setText(const String& value)
    {
        this->setString(ASCIILiteral("text"), value);
    }
};

/* CSS rule representation. */
class CSSRule : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        SelectorListSet = 1 << 0,
        SourceLineSet = 1 << 1,
        OriginSet = 1 << 2,
        StyleSet = 1 << 3,
        AllFieldsSet = (SelectorListSet | SourceLineSet | OriginSet | StyleSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*CSSRule*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class CSSRule;
    public:

        Builder<STATE | SelectorListSet>& setSelectorList(PassRefPtr<Inspector::TypeBuilder::CSS::SelectorList> value)
        {
            COMPILE_ASSERT(!(STATE & SelectorListSet), property_selectorList_already_set);
            m_result->setValue(ASCIILiteral("selectorList"), value);
            return castState<SelectorListSet>();
        }

        Builder<STATE | SourceLineSet>& setSourceLine(int value)
        {
            COMPILE_ASSERT(!(STATE & SourceLineSet), property_sourceLine_already_set);
            m_result->setNumber(ASCIILiteral("sourceLine"), value);
            return castState<SourceLineSet>();
        }

        Builder<STATE | OriginSet>& setOrigin(Inspector::TypeBuilder::CSS::StyleSheetOrigin::Enum value)
        {
            COMPILE_ASSERT(!(STATE & OriginSet), property_origin_already_set);
            m_result->setString(ASCIILiteral("origin"), Inspector::TypeBuilder::getWebEnumConstantValue(value));
            return castState<OriginSet>();
        }

        Builder<STATE | StyleSet>& setStyle(PassRefPtr<Inspector::TypeBuilder::CSS::CSSStyle> value)
        {
            COMPILE_ASSERT(!(STATE & StyleSet), property_style_already_set);
            m_result->setValue(ASCIILiteral("style"), value);
            return castState<StyleSet>();
        }

        operator RefPtr<CSSRule>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CSSRule) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<CSSRule>*>(&m_result);
        }

        PassRefPtr<CSSRule> release()
        {
            return RefPtr<CSSRule>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CSSRule> result = CSSRule::create()
     *     .setSelectorList(...)
     *     .setSourceLine(...)
     *     .setOrigin(...)
     *     .setStyle(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;

    void setRuleId(PassRefPtr<Inspector::TypeBuilder::CSS::CSSRuleId> value)
    {
        this->setValue(ASCIILiteral("ruleId"), value);
    }

    void setSourceURL(const String& value)
    {
        this->setString(ASCIILiteral("sourceURL"), value);
    }

    void setMedia(PassRefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::CSS::CSSMedia> > value)
    {
        this->setValue(ASCIILiteral("media"), value);
    }
};

/* Text range within a resource. */
class SourceRange : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        StartLineSet = 1 << 0,
        StartColumnSet = 1 << 1,
        EndLineSet = 1 << 2,
        EndColumnSet = 1 << 3,
        AllFieldsSet = (StartLineSet | StartColumnSet | EndLineSet | EndColumnSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*SourceRange*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class SourceRange;
    public:

        Builder<STATE | StartLineSet>& setStartLine(int value)
        {
            COMPILE_ASSERT(!(STATE & StartLineSet), property_startLine_already_set);
            m_result->setNumber(ASCIILiteral("startLine"), value);
            return castState<StartLineSet>();
        }

        Builder<STATE | StartColumnSet>& setStartColumn(int value)
        {
            COMPILE_ASSERT(!(STATE & StartColumnSet), property_startColumn_already_set);
            m_result->setNumber(ASCIILiteral("startColumn"), value);
            return castState<StartColumnSet>();
        }

        Builder<STATE | EndLineSet>& setEndLine(int value)
        {
            COMPILE_ASSERT(!(STATE & EndLineSet), property_endLine_already_set);
            m_result->setNumber(ASCIILiteral("endLine"), value);
            return castState<EndLineSet>();
        }

        Builder<STATE | EndColumnSet>& setEndColumn(int value)
        {
            COMPILE_ASSERT(!(STATE & EndColumnSet), property_endColumn_already_set);
            m_result->setNumber(ASCIILiteral("endColumn"), value);
            return castState<EndColumnSet>();
        }

        operator RefPtr<SourceRange>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(SourceRange) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<SourceRange>*>(&m_result);
        }

        PassRefPtr<SourceRange> release()
        {
            return RefPtr<SourceRange>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<SourceRange> result = SourceRange::create()
     *     .setStartLine(...)
     *     .setStartColumn(...)
     *     .setEndLine(...)
     *     .setEndColumn(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;
};

class ShorthandEntry : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        ValueSet = 1 << 1,
        AllFieldsSet = (NameSet | ValueSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*ShorthandEntry*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class ShorthandEntry;
    public:

        Builder<STATE | NameSet>& setName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString(ASCIILiteral("name"), value);
            return castState<NameSet>();
        }

        Builder<STATE | ValueSet>& setValue(const String& value)
        {
            COMPILE_ASSERT(!(STATE & ValueSet), property_value_already_set);
            m_result->setString(ASCIILiteral("value"), value);
            return castState<ValueSet>();
        }

        operator RefPtr<ShorthandEntry>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(ShorthandEntry) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<ShorthandEntry>*>(&m_result);
        }

        PassRefPtr<ShorthandEntry> release()
        {
            return RefPtr<ShorthandEntry>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<ShorthandEntry> result = ShorthandEntry::create()
     *     .setName(...)
     *     .setValue(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;
};

class CSSPropertyInfo : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        AllFieldsSet = (NameSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*CSSPropertyInfo*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class CSSPropertyInfo;
    public:

        Builder<STATE | NameSet>& setName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString(ASCIILiteral("name"), value);
            return castState<NameSet>();
        }

        operator RefPtr<CSSPropertyInfo>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CSSPropertyInfo) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<CSSPropertyInfo>*>(&m_result);
        }

        PassRefPtr<CSSPropertyInfo> release()
        {
            return RefPtr<CSSPropertyInfo>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CSSPropertyInfo> result = CSSPropertyInfo::create()
     *     .setName(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;

    void setLonghands(PassRefPtr<Inspector::TypeBuilder::Array<String> > value)
    {
        this->setValue(ASCIILiteral("longhands"), value);
    }
};

class CSSComputedStyleProperty : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        ValueSet = 1 << 1,
        AllFieldsSet = (NameSet | ValueSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*CSSComputedStyleProperty*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class CSSComputedStyleProperty;
    public:

        Builder<STATE | NameSet>& setName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString(ASCIILiteral("name"), value);
            return castState<NameSet>();
        }

        Builder<STATE | ValueSet>& setValue(const String& value)
        {
            COMPILE_ASSERT(!(STATE & ValueSet), property_value_already_set);
            m_result->setString(ASCIILiteral("value"), value);
            return castState<ValueSet>();
        }

        operator RefPtr<CSSComputedStyleProperty>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CSSComputedStyleProperty) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<CSSComputedStyleProperty>*>(&m_result);
        }

        PassRefPtr<CSSComputedStyleProperty> release()
        {
            return RefPtr<CSSComputedStyleProperty>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CSSComputedStyleProperty> result = CSSComputedStyleProperty::create()
     *     .setName(...)
     *     .setValue(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;
};

/* CSS style representation. */
class CSSStyle : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        CssPropertiesSet = 1 << 0,
        ShorthandEntriesSet = 1 << 1,
        AllFieldsSet = (CssPropertiesSet | ShorthandEntriesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*CSSStyle*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class CSSStyle;
    public:

        Builder<STATE | CssPropertiesSet>& setCssProperties(PassRefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::CSS::CSSProperty> > value)
        {
            COMPILE_ASSERT(!(STATE & CssPropertiesSet), property_cssProperties_already_set);
            m_result->setValue(ASCIILiteral("cssProperties"), value);
            return castState<CssPropertiesSet>();
        }

        Builder<STATE | ShorthandEntriesSet>& setShorthandEntries(PassRefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::CSS::ShorthandEntry> > value)
        {
            COMPILE_ASSERT(!(STATE & ShorthandEntriesSet), property_shorthandEntries_already_set);
            m_result->setValue(ASCIILiteral("shorthandEntries"), value);
            return castState<ShorthandEntriesSet>();
        }

        operator RefPtr<CSSStyle>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CSSStyle) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<CSSStyle>*>(&m_result);
        }

        PassRefPtr<CSSStyle> release()
        {
            return RefPtr<CSSStyle>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CSSStyle> result = CSSStyle::create()
     *     .setCssProperties(...)
     *     .setShorthandEntries(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;

    void setStyleId(PassRefPtr<Inspector::TypeBuilder::CSS::CSSStyleId> value)
    {
        this->setValue(ASCIILiteral("styleId"), value);
    }

    void setCssText(const String& value)
    {
        this->setString(ASCIILiteral("cssText"), value);
    }

    void setRange(PassRefPtr<Inspector::TypeBuilder::CSS::SourceRange> value)
    {
        this->setValue(ASCIILiteral("range"), value);
    }

    void setWidth(const String& value)
    {
        this->setString(ASCIILiteral("width"), value);
    }

    void setHeight(const String& value)
    {
        this->setString(ASCIILiteral("height"), value);
    }
};

/* CSS style effective visual dimensions and source offsets. */
class CSSProperty : public Inspector::InspectorObject {
public:
    // Named after property name 'status' while generating CSSProperty.
    struct Status {
        enum Enum {
            Active = 14,
            Inactive = 15,
            Disabled = 16,
            Style = 17,
        };
    }; // struct Status
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        ValueSet = 1 << 1,
        AllFieldsSet = (NameSet | ValueSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*CSSProperty*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class CSSProperty;
    public:

        Builder<STATE | NameSet>& setName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString(ASCIILiteral("name"), value);
            return castState<NameSet>();
        }

        Builder<STATE | ValueSet>& setValue(const String& value)
        {
            COMPILE_ASSERT(!(STATE & ValueSet), property_value_already_set);
            m_result->setString(ASCIILiteral("value"), value);
            return castState<ValueSet>();
        }

        operator RefPtr<CSSProperty>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CSSProperty) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<CSSProperty>*>(&m_result);
        }

        PassRefPtr<CSSProperty> release()
        {
            return RefPtr<CSSProperty>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CSSProperty> result = CSSProperty::create()
     *     .setName(...)
     *     .setValue(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;

    void setPriority(const String& value)
    {
        this->setString(ASCIILiteral("priority"), value);
    }

    void setImplicit(bool value)
    {
        this->setBoolean(ASCIILiteral("implicit"), value);
    }

    void setText(const String& value)
    {
        this->setString(ASCIILiteral("text"), value);
    }

    void setParsedOk(bool value)
    {
        this->setBoolean(ASCIILiteral("parsedOk"), value);
    }

    void setStatus(Status::Enum value)
    {
        this->setString(ASCIILiteral("status"), Inspector::TypeBuilder::getWebEnumConstantValue(value));
    }

    void setRange(PassRefPtr<Inspector::TypeBuilder::CSS::SourceRange> value)
    {
        this->setValue(ASCIILiteral("range"), value);
    }

    // Property names for type generated as open.
    static const char* Name;
    static const char* Value;
    static const char* Priority;
    static const char* Implicit;
    static const char* Text;
    static const char* ParsedOk;
    static const char* Status;
    static const char* Range;
};

/* CSS media query descriptor. */
class CSSMedia : public Inspector::InspectorObjectBase {
public:
    // Named after property name 'source' while generating CSSMedia.
    struct Source {
        enum Enum {
            MediaRule = 18,
            ImportRule = 19,
            LinkedSheet = 20,
            InlineSheet = 21,
        };
    }; // struct Source
    enum {
        NoFieldsSet = 0,
        TextSet = 1 << 0,
        SourceSet = 1 << 1,
        AllFieldsSet = (TextSet | SourceSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*CSSMedia*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class CSSMedia;
    public:

        Builder<STATE | TextSet>& setText(const String& value)
        {
            COMPILE_ASSERT(!(STATE & TextSet), property_text_already_set);
            m_result->setString(ASCIILiteral("text"), value);
            return castState<TextSet>();
        }

        Builder<STATE | SourceSet>& setSource(Source::Enum value)
        {
            COMPILE_ASSERT(!(STATE & SourceSet), property_source_already_set);
            m_result->setString(ASCIILiteral("source"), Inspector::TypeBuilder::getWebEnumConstantValue(value));
            return castState<SourceSet>();
        }

        operator RefPtr<CSSMedia>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CSSMedia) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<CSSMedia>*>(&m_result);
        }

        PassRefPtr<CSSMedia> release()
        {
            return RefPtr<CSSMedia>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CSSMedia> result = CSSMedia::create()
     *     .setText(...)
     *     .setSource(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;

    void setSourceURL(const String& value)
    {
        this->setString(ASCIILiteral("sourceURL"), value);
    }

    void setSourceLine(int value)
    {
        this->setNumber(ASCIILiteral("sourceLine"), value);
    }
};

/* CSS selector profile entry. */
class SelectorProfileEntry : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        SelectorSet = 1 << 0,
        UrlSet = 1 << 1,
        LineNumberSet = 1 << 2,
        TimeSet = 1 << 3,
        HitCountSet = 1 << 4,
        MatchCountSet = 1 << 5,
        AllFieldsSet = (SelectorSet | UrlSet | LineNumberSet | TimeSet | HitCountSet | MatchCountSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*SelectorProfileEntry*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class SelectorProfileEntry;
    public:

        Builder<STATE | SelectorSet>& setSelector(const String& value)
        {
            COMPILE_ASSERT(!(STATE & SelectorSet), property_selector_already_set);
            m_result->setString(ASCIILiteral("selector"), value);
            return castState<SelectorSet>();
        }

        Builder<STATE | UrlSet>& setUrl(const String& value)
        {
            COMPILE_ASSERT(!(STATE & UrlSet), property_url_already_set);
            m_result->setString(ASCIILiteral("url"), value);
            return castState<UrlSet>();
        }

        Builder<STATE | LineNumberSet>& setLineNumber(int value)
        {
            COMPILE_ASSERT(!(STATE & LineNumberSet), property_lineNumber_already_set);
            m_result->setNumber(ASCIILiteral("lineNumber"), value);
            return castState<LineNumberSet>();
        }

        Builder<STATE | TimeSet>& setTime(double value)
        {
            COMPILE_ASSERT(!(STATE & TimeSet), property_time_already_set);
            m_result->setNumber(ASCIILiteral("time"), value);
            return castState<TimeSet>();
        }

        Builder<STATE | HitCountSet>& setHitCount(int value)
        {
            COMPILE_ASSERT(!(STATE & HitCountSet), property_hitCount_already_set);
            m_result->setNumber(ASCIILiteral("hitCount"), value);
            return castState<HitCountSet>();
        }

        Builder<STATE | MatchCountSet>& setMatchCount(int value)
        {
            COMPILE_ASSERT(!(STATE & MatchCountSet), property_matchCount_already_set);
            m_result->setNumber(ASCIILiteral("matchCount"), value);
            return castState<MatchCountSet>();
        }

        operator RefPtr<SelectorProfileEntry>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(SelectorProfileEntry) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<SelectorProfileEntry>*>(&m_result);
        }

        PassRefPtr<SelectorProfileEntry> release()
        {
            return RefPtr<SelectorProfileEntry>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<SelectorProfileEntry> result = SelectorProfileEntry::create()
     *     .setSelector(...)
     *     .setUrl(...)
     *     .setLineNumber(...)
     *     .setTime(...)
     *     .setHitCount(...)
     *     .setMatchCount(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;
};

class SelectorProfile : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        TotalTimeSet = 1 << 0,
        DataSet = 1 << 1,
        AllFieldsSet = (TotalTimeSet | DataSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*SelectorProfile*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class SelectorProfile;
    public:

        Builder<STATE | TotalTimeSet>& setTotalTime(double value)
        {
            COMPILE_ASSERT(!(STATE & TotalTimeSet), property_totalTime_already_set);
            m_result->setNumber(ASCIILiteral("totalTime"), value);
            return castState<TotalTimeSet>();
        }

        Builder<STATE | DataSet>& setData(PassRefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::CSS::SelectorProfileEntry> > value)
        {
            COMPILE_ASSERT(!(STATE & DataSet), property_data_already_set);
            m_result->setValue(ASCIILiteral("data"), value);
            return castState<DataSet>();
        }

        operator RefPtr<SelectorProfile>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(SelectorProfile) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<SelectorProfile>*>(&m_result);
        }

        PassRefPtr<SelectorProfile> release()
        {
            return RefPtr<SelectorProfile>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<SelectorProfile> result = SelectorProfile::create()
     *     .setTotalTime(...)
     *     .setData(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;
};

/* This object represents a region that flows from a Named Flow. */
class Region : public Inspector::InspectorObjectBase {
public:
    // Named after property name 'regionOverset' while generating Region.
    struct RegionOverset {
        enum Enum {
            Overset = 22,
            Fit = 23,
            Empty = 24,
        };
    }; // struct RegionOverset
    enum {
        NoFieldsSet = 0,
        RegionOversetSet = 1 << 0,
        NodeIdSet = 1 << 1,
        AllFieldsSet = (RegionOversetSet | NodeIdSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*Region*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class Region;
    public:

        Builder<STATE | RegionOversetSet>& setRegionOverset(RegionOverset::Enum value)
        {
            COMPILE_ASSERT(!(STATE & RegionOversetSet), property_regionOverset_already_set);
            m_result->setString(ASCIILiteral("regionOverset"), Inspector::TypeBuilder::getWebEnumConstantValue(value));
            return castState<RegionOversetSet>();
        }

        Builder<STATE | NodeIdSet>& setNodeId(int value)
        {
            COMPILE_ASSERT(!(STATE & NodeIdSet), property_nodeId_already_set);
            m_result->setNumber(ASCIILiteral("nodeId"), value);
            return castState<NodeIdSet>();
        }

        operator RefPtr<Region>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Region) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<Region>*>(&m_result);
        }

        PassRefPtr<Region> release()
        {
            return RefPtr<Region>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Region> result = Region::create()
     *     .setRegionOverset(...)
     *     .setNodeId(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;
};

/* This object represents a Named Flow. */
class NamedFlow : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        DocumentNodeIdSet = 1 << 0,
        NameSet = 1 << 1,
        OversetSet = 1 << 2,
        ContentSet = 1 << 3,
        RegionsSet = 1 << 4,
        AllFieldsSet = (DocumentNodeIdSet | NameSet | OversetSet | ContentSet | RegionsSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*NamedFlow*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class NamedFlow;
    public:

        Builder<STATE | DocumentNodeIdSet>& setDocumentNodeId(int value)
        {
            COMPILE_ASSERT(!(STATE & DocumentNodeIdSet), property_documentNodeId_already_set);
            m_result->setNumber(ASCIILiteral("documentNodeId"), value);
            return castState<DocumentNodeIdSet>();
        }

        Builder<STATE | NameSet>& setName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString(ASCIILiteral("name"), value);
            return castState<NameSet>();
        }

        Builder<STATE | OversetSet>& setOverset(bool value)
        {
            COMPILE_ASSERT(!(STATE & OversetSet), property_overset_already_set);
            m_result->setBoolean(ASCIILiteral("overset"), value);
            return castState<OversetSet>();
        }

        Builder<STATE | ContentSet>& setContent(PassRefPtr<Inspector::TypeBuilder::Array<int> > value)
        {
            COMPILE_ASSERT(!(STATE & ContentSet), property_content_already_set);
            m_result->setValue(ASCIILiteral("content"), value);
            return castState<ContentSet>();
        }

        Builder<STATE | RegionsSet>& setRegions(PassRefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::CSS::Region> > value)
        {
            COMPILE_ASSERT(!(STATE & RegionsSet), property_regions_already_set);
            m_result->setValue(ASCIILiteral("regions"), value);
            return castState<RegionsSet>();
        }

        operator RefPtr<NamedFlow>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(NamedFlow) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<NamedFlow>*>(&m_result);
        }

        PassRefPtr<NamedFlow> release()
        {
            return RefPtr<NamedFlow>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<NamedFlow> result = NamedFlow::create()
     *     .setDocumentNodeId(...)
     *     .setName(...)
     *     .setOverset(...)
     *     .setContent(...)
     *     .setRegions(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;
};

} // CSS

namespace Canvas {
class ResourceInfo : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        IdSet = 1 << 0,
        DescriptionSet = 1 << 1,
        AllFieldsSet = (IdSet | DescriptionSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*ResourceInfo*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class ResourceInfo;
    public:

        Builder<STATE | IdSet>& setId(const Inspector::TypeBuilder::Canvas::ResourceId& value)
        {
            COMPILE_ASSERT(!(STATE & IdSet), property_id_already_set);
            m_result->setString(ASCIILiteral("id"), value);
            return castState<IdSet>();
        }

        Builder<STATE | DescriptionSet>& setDescription(const String& value)
        {
            COMPILE_ASSERT(!(STATE & DescriptionSet), property_description_already_set);
            m_result->setString(ASCIILiteral("description"), value);
            return castState<DescriptionSet>();
        }

        operator RefPtr<ResourceInfo>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(ResourceInfo) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<ResourceInfo>*>(&m_result);
        }

        PassRefPtr<ResourceInfo> release()
        {
            return RefPtr<ResourceInfo>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<ResourceInfo> result = ResourceInfo::create()
     *     .setId(...)
     *     .setDescription(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;
    static PassRefPtr<ResourceInfo> runtimeCast(PassRefPtr<Inspector::InspectorValue> value)
    {
        RefPtr<Inspector::InspectorObject> object;
        bool castRes = value->asObject(&object);
        ASSERT_UNUSED(castRes, castRes);
#if !ASSERT_DISABLED
        assertCorrectValue(object.get());
#endif  // !ASSERT_DISABLED
        COMPILE_ASSERT(sizeof(ResourceInfo) == sizeof(Inspector::InspectorObjectBase), type_cast_problem);
        return static_cast<ResourceInfo*>(static_cast<Inspector::InspectorObjectBase*>(object.get()));
    }

#if !ASSERT_DISABLED
    static  void assertCorrectValue(Inspector::InspectorValue* value);
#endif  // !ASSERT_DISABLED
};

class ResourceState : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        IdSet = 1 << 0,
        TraceLogIdSet = 1 << 1,
        AllFieldsSet = (IdSet | TraceLogIdSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*ResourceState*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class ResourceState;
    public:

        Builder<STATE | IdSet>& setId(const Inspector::TypeBuilder::Canvas::ResourceId& value)
        {
            COMPILE_ASSERT(!(STATE & IdSet), property_id_already_set);
            m_result->setString(ASCIILiteral("id"), value);
            return castState<IdSet>();
        }

        Builder<STATE | TraceLogIdSet>& setTraceLogId(const Inspector::TypeBuilder::Canvas::TraceLogId& value)
        {
            COMPILE_ASSERT(!(STATE & TraceLogIdSet), property_traceLogId_already_set);
            m_result->setString(ASCIILiteral("traceLogId"), value);
            return castState<TraceLogIdSet>();
        }

        operator RefPtr<ResourceState>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(ResourceState) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<ResourceState>*>(&m_result);
        }

        PassRefPtr<ResourceState> release()
        {
            return RefPtr<ResourceState>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<ResourceState> result = ResourceState::create()
     *     .setId(...)
     *     .setTraceLogId(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;

    void setImageURL(const String& value)
    {
        this->setString(ASCIILiteral("imageURL"), value);
    }
    static PassRefPtr<ResourceState> runtimeCast(PassRefPtr<Inspector::InspectorValue> value)
    {
        RefPtr<Inspector::InspectorObject> object;
        bool castRes = value->asObject(&object);
        ASSERT_UNUSED(castRes, castRes);
#if !ASSERT_DISABLED
        assertCorrectValue(object.get());
#endif  // !ASSERT_DISABLED
        COMPILE_ASSERT(sizeof(ResourceState) == sizeof(Inspector::InspectorObjectBase), type_cast_problem);
        return static_cast<ResourceState*>(static_cast<Inspector::InspectorObjectBase*>(object.get()));
    }

#if !ASSERT_DISABLED
    static  void assertCorrectValue(Inspector::InspectorValue* value);
#endif  // !ASSERT_DISABLED
};

class CallArgument : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        DescriptionSet = 1 << 0,
        AllFieldsSet = (DescriptionSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*CallArgument*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class CallArgument;
    public:

        Builder<STATE | DescriptionSet>& setDescription(const String& value)
        {
            COMPILE_ASSERT(!(STATE & DescriptionSet), property_description_already_set);
            m_result->setString(ASCIILiteral("description"), value);
            return castState<DescriptionSet>();
        }

        operator RefPtr<CallArgument>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CallArgument) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<CallArgument>*>(&m_result);
        }

        PassRefPtr<CallArgument> release()
        {
            return RefPtr<CallArgument>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CallArgument> result = CallArgument::create()
     *     .setDescription(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;
#if !ASSERT_DISABLED
    static  void assertCorrectValue(Inspector::InspectorValue* value);
#endif  // !ASSERT_DISABLED
};

class Call : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        ContextIdSet = 1 << 0,
        AllFieldsSet = (ContextIdSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*Call*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class Call;
    public:

        Builder<STATE | ContextIdSet>& setContextId(const Inspector::TypeBuilder::Canvas::ResourceId& value)
        {
            COMPILE_ASSERT(!(STATE & ContextIdSet), property_contextId_already_set);
            m_result->setString(ASCIILiteral("contextId"), value);
            return castState<ContextIdSet>();
        }

        operator RefPtr<Call>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Call) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<Call>*>(&m_result);
        }

        PassRefPtr<Call> release()
        {
            return RefPtr<Call>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Call> result = Call::create()
     *     .setContextId(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;

    void setFunctionName(const String& value)
    {
        this->setString(ASCIILiteral("functionName"), value);
    }

    void setArguments(PassRefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::Canvas::CallArgument> > value)
    {
        this->setValue(ASCIILiteral("arguments"), value);
    }

    void setResult(PassRefPtr<Inspector::TypeBuilder::Canvas::CallArgument> value)
    {
        this->setValue(ASCIILiteral("result"), value);
    }

    void setIsDrawingCall(bool value)
    {
        this->setBoolean(ASCIILiteral("isDrawingCall"), value);
    }

    void setIsFrameEndCall(bool value)
    {
        this->setBoolean(ASCIILiteral("isFrameEndCall"), value);
    }

    void setProperty(const String& value)
    {
        this->setString(ASCIILiteral("property"), value);
    }

    void setValue(PassRefPtr<Inspector::TypeBuilder::Canvas::CallArgument> value)
    {
        this->setValue(ASCIILiteral("value"), value);
    }
    using Inspector::InspectorObjectBase::setValue;


    void setSourceURL(const String& value)
    {
        this->setString(ASCIILiteral("sourceURL"), value);
    }

    void setLineNumber(int value)
    {
        this->setNumber(ASCIILiteral("lineNumber"), value);
    }

    void setColumnNumber(int value)
    {
        this->setNumber(ASCIILiteral("columnNumber"), value);
    }
#if !ASSERT_DISABLED
    static  void assertCorrectValue(Inspector::InspectorValue* value);
#endif  // !ASSERT_DISABLED
};

class TraceLog : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        IdSet = 1 << 0,
        CallsSet = 1 << 1,
        StartOffsetSet = 1 << 2,
        AliveSet = 1 << 3,
        TotalAvailableCallsSet = 1 << 4,
        AllFieldsSet = (IdSet | CallsSet | StartOffsetSet | AliveSet | TotalAvailableCallsSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*TraceLog*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class TraceLog;
    public:

        Builder<STATE | IdSet>& setId(const Inspector::TypeBuilder::Canvas::TraceLogId& value)
        {
            COMPILE_ASSERT(!(STATE & IdSet), property_id_already_set);
            m_result->setString(ASCIILiteral("id"), value);
            return castState<IdSet>();
        }

        Builder<STATE | CallsSet>& setCalls(PassRefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::Canvas::Call> > value)
        {
            COMPILE_ASSERT(!(STATE & CallsSet), property_calls_already_set);
            m_result->setValue(ASCIILiteral("calls"), value);
            return castState<CallsSet>();
        }

        Builder<STATE | StartOffsetSet>& setStartOffset(int value)
        {
            COMPILE_ASSERT(!(STATE & StartOffsetSet), property_startOffset_already_set);
            m_result->setNumber(ASCIILiteral("startOffset"), value);
            return castState<StartOffsetSet>();
        }

        Builder<STATE | AliveSet>& setAlive(bool value)
        {
            COMPILE_ASSERT(!(STATE & AliveSet), property_alive_already_set);
            m_result->setBoolean(ASCIILiteral("alive"), value);
            return castState<AliveSet>();
        }

        Builder<STATE | TotalAvailableCallsSet>& setTotalAvailableCalls(double value)
        {
            COMPILE_ASSERT(!(STATE & TotalAvailableCallsSet), property_totalAvailableCalls_already_set);
            m_result->setNumber(ASCIILiteral("totalAvailableCalls"), value);
            return castState<TotalAvailableCallsSet>();
        }

        operator RefPtr<TraceLog>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(TraceLog) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<TraceLog>*>(&m_result);
        }

        PassRefPtr<TraceLog> release()
        {
            return RefPtr<TraceLog>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<TraceLog> result = TraceLog::create()
     *     .setId(...)
     *     .setCalls(...)
     *     .setStartOffset(...)
     *     .setAlive(...)
     *     .setTotalAvailableCalls(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;
    static PassRefPtr<TraceLog> runtimeCast(PassRefPtr<Inspector::InspectorValue> value)
    {
        RefPtr<Inspector::InspectorObject> object;
        bool castRes = value->asObject(&object);
        ASSERT_UNUSED(castRes, castRes);
#if !ASSERT_DISABLED
        assertCorrectValue(object.get());
#endif  // !ASSERT_DISABLED
        COMPILE_ASSERT(sizeof(TraceLog) == sizeof(Inspector::InspectorObjectBase), type_cast_problem);
        return static_cast<TraceLog*>(static_cast<Inspector::InspectorObjectBase*>(object.get()));
    }

#if !ASSERT_DISABLED
    static  void assertCorrectValue(Inspector::InspectorValue* value);
#endif  // !ASSERT_DISABLED
};

} // Canvas

namespace Console {
/* Console message. */
class ConsoleMessage : public Inspector::InspectorObjectBase {
public:
    // Named after property name 'source' while generating ConsoleMessage.
    struct Source {
        enum Enum {
            XML = 25,
            Javascript = 26,
            Network = 27,
            ConsoleAPI = 28,
            Storage = 29,
            Appcache = 30,
            Rendering = 31,
            CSS = 32,
            Security = 33,
            Other = 34,
        };
    }; // struct Source
    // Named after property name 'level' while generating ConsoleMessage.
    struct Level {
        enum Enum {
            Log = 35,
            Warning = 36,
            Error = 37,
            Debug = 38,
        };
    }; // struct Level
    // Named after property name 'type' while generating ConsoleMessage.
    struct Type {
        enum Enum {
            Log = 35,
            Dir = 39,
            DirXML = 40,
            Table = 41,
            Trace = 42,
            Clear = 43,
            StartGroup = 44,
            StartGroupCollapsed = 45,
            EndGroup = 46,
            Assert = 47,
            Timing = 48,
            Profile = 49,
            ProfileEnd = 50,
        };
    }; // struct Type
    enum {
        NoFieldsSet = 0,
        SourceSet = 1 << 0,
        LevelSet = 1 << 1,
        TextSet = 1 << 2,
        AllFieldsSet = (SourceSet | LevelSet | TextSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*ConsoleMessage*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class ConsoleMessage;
    public:

        Builder<STATE | SourceSet>& setSource(Source::Enum value)
        {
            COMPILE_ASSERT(!(STATE & SourceSet), property_source_already_set);
            m_result->setString(ASCIILiteral("source"), Inspector::TypeBuilder::getWebEnumConstantValue(value));
            return castState<SourceSet>();
        }

        Builder<STATE | LevelSet>& setLevel(Level::Enum value)
        {
            COMPILE_ASSERT(!(STATE & LevelSet), property_level_already_set);
            m_result->setString(ASCIILiteral("level"), Inspector::TypeBuilder::getWebEnumConstantValue(value));
            return castState<LevelSet>();
        }

        Builder<STATE | TextSet>& setText(const String& value)
        {
            COMPILE_ASSERT(!(STATE & TextSet), property_text_already_set);
            m_result->setString(ASCIILiteral("text"), value);
            return castState<TextSet>();
        }

        operator RefPtr<ConsoleMessage>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(ConsoleMessage) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<ConsoleMessage>*>(&m_result);
        }

        PassRefPtr<ConsoleMessage> release()
        {
            return RefPtr<ConsoleMessage>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<ConsoleMessage> result = ConsoleMessage::create()
     *     .setSource(...)
     *     .setLevel(...)
     *     .setText(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;

    void setType(Type::Enum value)
    {
        this->setString(ASCIILiteral("type"), Inspector::TypeBuilder::getWebEnumConstantValue(value));
    }

    void setUrl(const String& value)
    {
        this->setString(ASCIILiteral("url"), value);
    }

    void setLine(int value)
    {
        this->setNumber(ASCIILiteral("line"), value);
    }

    void setColumn(int value)
    {
        this->setNumber(ASCIILiteral("column"), value);
    }

    void setRepeatCount(int value)
    {
        this->setNumber(ASCIILiteral("repeatCount"), value);
    }

    void setParameters(PassRefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::Runtime::RemoteObject> > value)
    {
        this->setValue(ASCIILiteral("parameters"), value);
    }

    void setStackTrace(PassRefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::Console::CallFrame> > value)
    {
        this->setValue(ASCIILiteral("stackTrace"), value);
    }

    void setNetworkRequestId(const Inspector::TypeBuilder::Network::RequestId& value)
    {
        this->setString(ASCIILiteral("networkRequestId"), value);
    }
};

/* Stack entry for console errors and assertions. */
class CallFrame : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        FunctionNameSet = 1 << 0,
        UrlSet = 1 << 1,
        LineNumberSet = 1 << 2,
        ColumnNumberSet = 1 << 3,
        AllFieldsSet = (FunctionNameSet | UrlSet | LineNumberSet | ColumnNumberSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*CallFrame*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class CallFrame;
    public:

        Builder<STATE | FunctionNameSet>& setFunctionName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & FunctionNameSet), property_functionName_already_set);
            m_result->setString(ASCIILiteral("functionName"), value);
            return castState<FunctionNameSet>();
        }

        Builder<STATE | UrlSet>& setUrl(const String& value)
        {
            COMPILE_ASSERT(!(STATE & UrlSet), property_url_already_set);
            m_result->setString(ASCIILiteral("url"), value);
            return castState<UrlSet>();
        }

        Builder<STATE | LineNumberSet>& setLineNumber(int value)
        {
            COMPILE_ASSERT(!(STATE & LineNumberSet), property_lineNumber_already_set);
            m_result->setNumber(ASCIILiteral("lineNumber"), value);
            return castState<LineNumberSet>();
        }

        Builder<STATE | ColumnNumberSet>& setColumnNumber(int value)
        {
            COMPILE_ASSERT(!(STATE & ColumnNumberSet), property_columnNumber_already_set);
            m_result->setNumber(ASCIILiteral("columnNumber"), value);
            return castState<ColumnNumberSet>();
        }

        operator RefPtr<CallFrame>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CallFrame) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<CallFrame>*>(&m_result);
        }

        PassRefPtr<CallFrame> release()
        {
            return RefPtr<CallFrame>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CallFrame> result = CallFrame::create()
     *     .setFunctionName(...)
     *     .setUrl(...)
     *     .setLineNumber(...)
     *     .setColumnNumber(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;
};

} // Console

namespace DOM {
/* DOM interaction is implemented in terms of mirror objects that represent the actual DOM nodes. DOMNode is a base node mirror type. */
class Node : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NodeIdSet = 1 << 0,
        NodeTypeSet = 1 << 1,
        NodeNameSet = 1 << 2,
        LocalNameSet = 1 << 3,
        NodeValueSet = 1 << 4,
        AllFieldsSet = (NodeIdSet | NodeTypeSet | NodeNameSet | LocalNameSet | NodeValueSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*Node*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class Node;
    public:

        Builder<STATE | NodeIdSet>& setNodeId(int value)
        {
            COMPILE_ASSERT(!(STATE & NodeIdSet), property_nodeId_already_set);
            m_result->setNumber(ASCIILiteral("nodeId"), value);
            return castState<NodeIdSet>();
        }

        Builder<STATE | NodeTypeSet>& setNodeType(int value)
        {
            COMPILE_ASSERT(!(STATE & NodeTypeSet), property_nodeType_already_set);
            m_result->setNumber(ASCIILiteral("nodeType"), value);
            return castState<NodeTypeSet>();
        }

        Builder<STATE | NodeNameSet>& setNodeName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NodeNameSet), property_nodeName_already_set);
            m_result->setString(ASCIILiteral("nodeName"), value);
            return castState<NodeNameSet>();
        }

        Builder<STATE | LocalNameSet>& setLocalName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & LocalNameSet), property_localName_already_set);
            m_result->setString(ASCIILiteral("localName"), value);
            return castState<LocalNameSet>();
        }

        Builder<STATE | NodeValueSet>& setNodeValue(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NodeValueSet), property_nodeValue_already_set);
            m_result->setString(ASCIILiteral("nodeValue"), value);
            return castState<NodeValueSet>();
        }

        operator RefPtr<Node>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Node) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<Node>*>(&m_result);
        }

        PassRefPtr<Node> release()
        {
            return RefPtr<Node>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Node> result = Node::create()
     *     .setNodeId(...)
     *     .setNodeType(...)
     *     .setNodeName(...)
     *     .setLocalName(...)
     *     .setNodeValue(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;

    void setChildNodeCount(int value)
    {
        this->setNumber(ASCIILiteral("childNodeCount"), value);
    }

    void setChildren(PassRefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::DOM::Node> > value)
    {
        this->setValue(ASCIILiteral("children"), value);
    }

    void setAttributes(PassRefPtr<Inspector::TypeBuilder::Array<String> > value)
    {
        this->setValue(ASCIILiteral("attributes"), value);
    }

    void setDocumentURL(const String& value)
    {
        this->setString(ASCIILiteral("documentURL"), value);
    }

    void setBaseURL(const String& value)
    {
        this->setString(ASCIILiteral("baseURL"), value);
    }

    void setPublicId(const String& value)
    {
        this->setString(ASCIILiteral("publicId"), value);
    }

    void setSystemId(const String& value)
    {
        this->setString(ASCIILiteral("systemId"), value);
    }

    void setInternalSubset(const String& value)
    {
        this->setString(ASCIILiteral("internalSubset"), value);
    }

    void setXmlVersion(const String& value)
    {
        this->setString(ASCIILiteral("xmlVersion"), value);
    }

    void setName(const String& value)
    {
        this->setString(ASCIILiteral("name"), value);
    }

    void setValue(const String& value)
    {
        this->setString(ASCIILiteral("value"), value);
    }
    using Inspector::InspectorObjectBase::setValue;


    void setFrameId(const Inspector::TypeBuilder::Network::FrameId& value)
    {
        this->setString(ASCIILiteral("frameId"), value);
    }

    void setContentDocument(PassRefPtr<Inspector::TypeBuilder::DOM::Node> value)
    {
        this->setValue(ASCIILiteral("contentDocument"), value);
    }

    void setShadowRoots(PassRefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::DOM::Node> > value)
    {
        this->setValue(ASCIILiteral("shadowRoots"), value);
    }

    void setTemplateContent(PassRefPtr<Inspector::TypeBuilder::DOM::Node> value)
    {
        this->setValue(ASCIILiteral("templateContent"), value);
    }
};

/* DOM interaction is implemented in terms of mirror objects that represent the actual DOM nodes. DOMNode is a base node mirror type. */
class EventListener : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        UseCaptureSet = 1 << 1,
        IsAttributeSet = 1 << 2,
        NodeIdSet = 1 << 3,
        HandlerBodySet = 1 << 4,
        AllFieldsSet = (TypeSet | UseCaptureSet | IsAttributeSet | NodeIdSet | HandlerBodySet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*EventListener*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class EventListener;
    public:

        Builder<STATE | TypeSet>& setType(const String& value)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString(ASCIILiteral("type"), value);
            return castState<TypeSet>();
        }

        Builder<STATE | UseCaptureSet>& setUseCapture(bool value)
        {
            COMPILE_ASSERT(!(STATE & UseCaptureSet), property_useCapture_already_set);
            m_result->setBoolean(ASCIILiteral("useCapture"), value);
            return castState<UseCaptureSet>();
        }

        Builder<STATE | IsAttributeSet>& setIsAttribute(bool value)
        {
            COMPILE_ASSERT(!(STATE & IsAttributeSet), property_isAttribute_already_set);
            m_result->setBoolean(ASCIILiteral("isAttribute"), value);
            return castState<IsAttributeSet>();
        }

        Builder<STATE | NodeIdSet>& setNodeId(int value)
        {
            COMPILE_ASSERT(!(STATE & NodeIdSet), property_nodeId_already_set);
            m_result->setNumber(ASCIILiteral("nodeId"), value);
            return castState<NodeIdSet>();
        }

        Builder<STATE | HandlerBodySet>& setHandlerBody(const String& value)
        {
            COMPILE_ASSERT(!(STATE & HandlerBodySet), property_handlerBody_already_set);
            m_result->setString(ASCIILiteral("handlerBody"), value);
            return castState<HandlerBodySet>();
        }

        operator RefPtr<EventListener>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(EventListener) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<EventListener>*>(&m_result);
        }

        PassRefPtr<EventListener> release()
        {
            return RefPtr<EventListener>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<EventListener> result = EventListener::create()
     *     .setType(...)
     *     .setUseCapture(...)
     *     .setIsAttribute(...)
     *     .setNodeId(...)
     *     .setHandlerBody(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;

    void setLocation(PassRefPtr<Inspector::TypeBuilder::Debugger::Location> value)
    {
        this->setValue(ASCIILiteral("location"), value);
    }

    void setSourceName(const String& value)
    {
        this->setString(ASCIILiteral("sourceName"), value);
    }

    void setHandler(PassRefPtr<Inspector::TypeBuilder::Runtime::RemoteObject> value)
    {
        this->setValue(ASCIILiteral("handler"), value);
    }
};

/* A structure holding an RGBA color. */
// Type originally was named 'RGBA'.
class Rgba : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        RSet = 1 << 0,
        GSet = 1 << 1,
        BSet = 1 << 2,
        AllFieldsSet = (RSet | GSet | BSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*Rgba*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class Rgba;
    public:

        Builder<STATE | RSet>& setR(int value)
        {
            COMPILE_ASSERT(!(STATE & RSet), property_r_already_set);
            m_result->setNumber(ASCIILiteral("r"), value);
            return castState<RSet>();
        }

        Builder<STATE | GSet>& setG(int value)
        {
            COMPILE_ASSERT(!(STATE & GSet), property_g_already_set);
            m_result->setNumber(ASCIILiteral("g"), value);
            return castState<GSet>();
        }

        Builder<STATE | BSet>& setB(int value)
        {
            COMPILE_ASSERT(!(STATE & BSet), property_b_already_set);
            m_result->setNumber(ASCIILiteral("b"), value);
            return castState<BSet>();
        }

        operator RefPtr<Rgba>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Rgba) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<Rgba>*>(&m_result);
        }

        PassRefPtr<Rgba> release()
        {
            return RefPtr<Rgba>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Rgba> result = Rgba::create()
     *     .setR(...)
     *     .setG(...)
     *     .setB(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;

    void setA(double value)
    {
        this->setNumber(ASCIILiteral("a"), value);
    }
};

/* Configuration data for the highlighting of page elements. */
class HighlightConfig : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        AllFieldsSet = 0
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*HighlightConfig*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class HighlightConfig;
    public:

        operator RefPtr<HighlightConfig>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(HighlightConfig) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<HighlightConfig>*>(&m_result);
        }

        PassRefPtr<HighlightConfig> release()
        {
            return RefPtr<HighlightConfig>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<HighlightConfig> result = HighlightConfig::create();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;

    void setShowInfo(bool value)
    {
        this->setBoolean(ASCIILiteral("showInfo"), value);
    }

    void setContentColor(PassRefPtr<Inspector::TypeBuilder::DOM::Rgba> value)
    {
        this->setValue(ASCIILiteral("contentColor"), value);
    }

    void setPaddingColor(PassRefPtr<Inspector::TypeBuilder::DOM::Rgba> value)
    {
        this->setValue(ASCIILiteral("paddingColor"), value);
    }

    void setBorderColor(PassRefPtr<Inspector::TypeBuilder::DOM::Rgba> value)
    {
        this->setValue(ASCIILiteral("borderColor"), value);
    }

    void setMarginColor(PassRefPtr<Inspector::TypeBuilder::DOM::Rgba> value)
    {
        this->setValue(ASCIILiteral("marginColor"), value);
    }
};

} // DOM

#if ENABLE(JAVASCRIPT_DEBUGGER)
namespace DOMDebugger {
/* DOM breakpoint type. */
struct DOMBreakpointType {
    enum Enum {
        SubtreeModified = 51,
        AttributeModified = 52,
        NodeRemoved = 53,
    };
}; // struct DOMBreakpointType
} // DOMDebugger

#endif // ENABLE(JAVASCRIPT_DEBUGGER)
namespace DOMStorage {
/* DOM Storage identifier. */
class StorageId : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        SecurityOriginSet = 1 << 0,
        IsLocalStorageSet = 1 << 1,
        AllFieldsSet = (SecurityOriginSet | IsLocalStorageSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*StorageId*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class StorageId;
    public:

        Builder<STATE | SecurityOriginSet>& setSecurityOrigin(const String& value)
        {
            COMPILE_ASSERT(!(STATE & SecurityOriginSet), property_securityOrigin_already_set);
            m_result->setString(ASCIILiteral("securityOrigin"), value);
            return castState<SecurityOriginSet>();
        }

        Builder<STATE | IsLocalStorageSet>& setIsLocalStorage(bool value)
        {
            COMPILE_ASSERT(!(STATE & IsLocalStorageSet), property_isLocalStorage_already_set);
            m_result->setBoolean(ASCIILiteral("isLocalStorage"), value);
            return castState<IsLocalStorageSet>();
        }

        operator RefPtr<StorageId>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(StorageId) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<StorageId>*>(&m_result);
        }

        PassRefPtr<StorageId> release()
        {
            return RefPtr<StorageId>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<StorageId> result = StorageId::create()
     *     .setSecurityOrigin(...)
     *     .setIsLocalStorage(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;
};

} // DOMStorage

#if ENABLE(SQL_DATABASE)
namespace Database {
/* Database object. */
class Database : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        IdSet = 1 << 0,
        DomainSet = 1 << 1,
        NameSet = 1 << 2,
        VersionSet = 1 << 3,
        AllFieldsSet = (IdSet | DomainSet | NameSet | VersionSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*Database*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class Database;
    public:

        Builder<STATE | IdSet>& setId(const Inspector::TypeBuilder::Database::DatabaseId& value)
        {
            COMPILE_ASSERT(!(STATE & IdSet), property_id_already_set);
            m_result->setString(ASCIILiteral("id"), value);
            return castState<IdSet>();
        }

        Builder<STATE | DomainSet>& setDomain(const String& value)
        {
            COMPILE_ASSERT(!(STATE & DomainSet), property_domain_already_set);
            m_result->setString(ASCIILiteral("domain"), value);
            return castState<DomainSet>();
        }

        Builder<STATE | NameSet>& setName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString(ASCIILiteral("name"), value);
            return castState<NameSet>();
        }

        Builder<STATE | VersionSet>& setVersion(const String& value)
        {
            COMPILE_ASSERT(!(STATE & VersionSet), property_version_already_set);
            m_result->setString(ASCIILiteral("version"), value);
            return castState<VersionSet>();
        }

        operator RefPtr<Database>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Database) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<Database>*>(&m_result);
        }

        PassRefPtr<Database> release()
        {
            return RefPtr<Database>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Database> result = Database::create()
     *     .setId(...)
     *     .setDomain(...)
     *     .setName(...)
     *     .setVersion(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;
};

/* Database error. */
class Error : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        MessageSet = 1 << 0,
        CodeSet = 1 << 1,
        AllFieldsSet = (MessageSet | CodeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*Error*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class Error;
    public:

        Builder<STATE | MessageSet>& setMessage(const String& value)
        {
            COMPILE_ASSERT(!(STATE & MessageSet), property_message_already_set);
            m_result->setString(ASCIILiteral("message"), value);
            return castState<MessageSet>();
        }

        Builder<STATE | CodeSet>& setCode(int value)
        {
            COMPILE_ASSERT(!(STATE & CodeSet), property_code_already_set);
            m_result->setNumber(ASCIILiteral("code"), value);
            return castState<CodeSet>();
        }

        operator RefPtr<Error>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Error) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<Error>*>(&m_result);
        }

        PassRefPtr<Error> release()
        {
            return RefPtr<Error>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Error> result = Error::create()
     *     .setMessage(...)
     *     .setCode(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;
};

} // Database

#endif // ENABLE(SQL_DATABASE)
namespace HeapProfiler {
/* Profile header. */
class ProfileHeader : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        TitleSet = 1 << 0,
        UidSet = 1 << 1,
        AllFieldsSet = (TitleSet | UidSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*ProfileHeader*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class ProfileHeader;
    public:

        Builder<STATE | TitleSet>& setTitle(const String& value)
        {
            COMPILE_ASSERT(!(STATE & TitleSet), property_title_already_set);
            m_result->setString(ASCIILiteral("title"), value);
            return castState<TitleSet>();
        }

        Builder<STATE | UidSet>& setUid(int value)
        {
            COMPILE_ASSERT(!(STATE & UidSet), property_uid_already_set);
            m_result->setNumber(ASCIILiteral("uid"), value);
            return castState<UidSet>();
        }

        operator RefPtr<ProfileHeader>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(ProfileHeader) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<ProfileHeader>*>(&m_result);
        }

        PassRefPtr<ProfileHeader> release()
        {
            return RefPtr<ProfileHeader>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<ProfileHeader> result = ProfileHeader::create()
     *     .setTitle(...)
     *     .setUid(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;

    void setMaxJSObjectId(int value)
    {
        this->setNumber(ASCIILiteral("maxJSObjectId"), value);
    }
};

} // HeapProfiler

#if ENABLE(INDEXED_DATABASE)
namespace IndexedDB {
/* Database with an array of object stores. */
class DatabaseWithObjectStores : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        VersionSet = 1 << 1,
        IntVersionSet = 1 << 2,
        ObjectStoresSet = 1 << 3,
        AllFieldsSet = (NameSet | VersionSet | IntVersionSet | ObjectStoresSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*DatabaseWithObjectStores*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class DatabaseWithObjectStores;
    public:

        Builder<STATE | NameSet>& setName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString(ASCIILiteral("name"), value);
            return castState<NameSet>();
        }

        Builder<STATE | VersionSet>& setVersion(const String& value)
        {
            COMPILE_ASSERT(!(STATE & VersionSet), property_version_already_set);
            m_result->setString(ASCIILiteral("version"), value);
            return castState<VersionSet>();
        }

        Builder<STATE | IntVersionSet>& setIntVersion(int value)
        {
            COMPILE_ASSERT(!(STATE & IntVersionSet), property_intVersion_already_set);
            m_result->setNumber(ASCIILiteral("intVersion"), value);
            return castState<IntVersionSet>();
        }

        Builder<STATE | ObjectStoresSet>& setObjectStores(PassRefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::IndexedDB::ObjectStore> > value)
        {
            COMPILE_ASSERT(!(STATE & ObjectStoresSet), property_objectStores_already_set);
            m_result->setValue(ASCIILiteral("objectStores"), value);
            return castState<ObjectStoresSet>();
        }

        operator RefPtr<DatabaseWithObjectStores>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(DatabaseWithObjectStores) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<DatabaseWithObjectStores>*>(&m_result);
        }

        PassRefPtr<DatabaseWithObjectStores> release()
        {
            return RefPtr<DatabaseWithObjectStores>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<DatabaseWithObjectStores> result = DatabaseWithObjectStores::create()
     *     .setName(...)
     *     .setVersion(...)
     *     .setIntVersion(...)
     *     .setObjectStores(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;
};

/* Object store. */
class ObjectStore : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        KeyPathSet = 1 << 1,
        AutoIncrementSet = 1 << 2,
        IndexesSet = 1 << 3,
        AllFieldsSet = (NameSet | KeyPathSet | AutoIncrementSet | IndexesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*ObjectStore*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class ObjectStore;
    public:

        Builder<STATE | NameSet>& setName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString(ASCIILiteral("name"), value);
            return castState<NameSet>();
        }

        Builder<STATE | KeyPathSet>& setKeyPath(PassRefPtr<Inspector::TypeBuilder::IndexedDB::KeyPath> value)
        {
            COMPILE_ASSERT(!(STATE & KeyPathSet), property_keyPath_already_set);
            m_result->setValue(ASCIILiteral("keyPath"), value);
            return castState<KeyPathSet>();
        }

        Builder<STATE | AutoIncrementSet>& setAutoIncrement(bool value)
        {
            COMPILE_ASSERT(!(STATE & AutoIncrementSet), property_autoIncrement_already_set);
            m_result->setBoolean(ASCIILiteral("autoIncrement"), value);
            return castState<AutoIncrementSet>();
        }

        Builder<STATE | IndexesSet>& setIndexes(PassRefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::IndexedDB::ObjectStoreIndex> > value)
        {
            COMPILE_ASSERT(!(STATE & IndexesSet), property_indexes_already_set);
            m_result->setValue(ASCIILiteral("indexes"), value);
            return castState<IndexesSet>();
        }

        operator RefPtr<ObjectStore>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(ObjectStore) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<ObjectStore>*>(&m_result);
        }

        PassRefPtr<ObjectStore> release()
        {
            return RefPtr<ObjectStore>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<ObjectStore> result = ObjectStore::create()
     *     .setName(...)
     *     .setKeyPath(...)
     *     .setAutoIncrement(...)
     *     .setIndexes(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;
};

/* Object store index. */
class ObjectStoreIndex : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        KeyPathSet = 1 << 1,
        UniqueSet = 1 << 2,
        MultiEntrySet = 1 << 3,
        AllFieldsSet = (NameSet | KeyPathSet | UniqueSet | MultiEntrySet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*ObjectStoreIndex*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class ObjectStoreIndex;
    public:

        Builder<STATE | NameSet>& setName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString(ASCIILiteral("name"), value);
            return castState<NameSet>();
        }

        Builder<STATE | KeyPathSet>& setKeyPath(PassRefPtr<Inspector::TypeBuilder::IndexedDB::KeyPath> value)
        {
            COMPILE_ASSERT(!(STATE & KeyPathSet), property_keyPath_already_set);
            m_result->setValue(ASCIILiteral("keyPath"), value);
            return castState<KeyPathSet>();
        }

        Builder<STATE | UniqueSet>& setUnique(bool value)
        {
            COMPILE_ASSERT(!(STATE & UniqueSet), property_unique_already_set);
            m_result->setBoolean(ASCIILiteral("unique"), value);
            return castState<UniqueSet>();
        }

        Builder<STATE | MultiEntrySet>& setMultiEntry(bool value)
        {
            COMPILE_ASSERT(!(STATE & MultiEntrySet), property_multiEntry_already_set);
            m_result->setBoolean(ASCIILiteral("multiEntry"), value);
            return castState<MultiEntrySet>();
        }

        operator RefPtr<ObjectStoreIndex>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(ObjectStoreIndex) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<ObjectStoreIndex>*>(&m_result);
        }

        PassRefPtr<ObjectStoreIndex> release()
        {
            return RefPtr<ObjectStoreIndex>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<ObjectStoreIndex> result = ObjectStoreIndex::create()
     *     .setName(...)
     *     .setKeyPath(...)
     *     .setUnique(...)
     *     .setMultiEntry(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;
};

/* Key. */
class Key : public Inspector::InspectorObjectBase {
public:
    // Named after property name 'type' while generating Key.
    struct Type {
        enum Enum {
            Number = 54,
            String = 55,
            Date = 56,
            Array = 57,
        };
    }; // struct Type
    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        AllFieldsSet = (TypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*Key*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class Key;
    public:

        Builder<STATE | TypeSet>& setType(Type::Enum value)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString(ASCIILiteral("type"), Inspector::TypeBuilder::getWebEnumConstantValue(value));
            return castState<TypeSet>();
        }

        operator RefPtr<Key>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Key) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<Key>*>(&m_result);
        }

        PassRefPtr<Key> release()
        {
            return RefPtr<Key>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Key> result = Key::create()
     *     .setType(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;

    void setNumber(double value)
    {
        this->setNumber(ASCIILiteral("number"), value);
    }
    using Inspector::InspectorObjectBase::setNumber;


    void setString(const String& value)
    {
        this->setString(ASCIILiteral("string"), value);
    }
    using Inspector::InspectorObjectBase::setString;


    void setDate(double value)
    {
        this->setNumber(ASCIILiteral("date"), value);
    }

    void setArray(PassRefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::IndexedDB::Key> > value)
    {
        this->setValue(ASCIILiteral("array"), value);
    }
    using Inspector::InspectorObjectBase::setArray;

};

/* Key range. */
class KeyRange : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        LowerOpenSet = 1 << 0,
        UpperOpenSet = 1 << 1,
        AllFieldsSet = (LowerOpenSet | UpperOpenSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*KeyRange*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class KeyRange;
    public:

        Builder<STATE | LowerOpenSet>& setLowerOpen(bool value)
        {
            COMPILE_ASSERT(!(STATE & LowerOpenSet), property_lowerOpen_already_set);
            m_result->setBoolean(ASCIILiteral("lowerOpen"), value);
            return castState<LowerOpenSet>();
        }

        Builder<STATE | UpperOpenSet>& setUpperOpen(bool value)
        {
            COMPILE_ASSERT(!(STATE & UpperOpenSet), property_upperOpen_already_set);
            m_result->setBoolean(ASCIILiteral("upperOpen"), value);
            return castState<UpperOpenSet>();
        }

        operator RefPtr<KeyRange>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(KeyRange) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<KeyRange>*>(&m_result);
        }

        PassRefPtr<KeyRange> release()
        {
            return RefPtr<KeyRange>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<KeyRange> result = KeyRange::create()
     *     .setLowerOpen(...)
     *     .setUpperOpen(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;

    void setLower(PassRefPtr<Inspector::TypeBuilder::IndexedDB::Key> value)
    {
        this->setValue(ASCIILiteral("lower"), value);
    }

    void setUpper(PassRefPtr<Inspector::TypeBuilder::IndexedDB::Key> value)
    {
        this->setValue(ASCIILiteral("upper"), value);
    }
};

/* Data entry. */
class DataEntry : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        KeySet = 1 << 0,
        PrimaryKeySet = 1 << 1,
        ValueSet = 1 << 2,
        AllFieldsSet = (KeySet | PrimaryKeySet | ValueSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*DataEntry*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class DataEntry;
    public:

        Builder<STATE | KeySet>& setKey(PassRefPtr<Inspector::TypeBuilder::Runtime::RemoteObject> value)
        {
            COMPILE_ASSERT(!(STATE & KeySet), property_key_already_set);
            m_result->setValue(ASCIILiteral("key"), value);
            return castState<KeySet>();
        }

        Builder<STATE | PrimaryKeySet>& setPrimaryKey(PassRefPtr<Inspector::TypeBuilder::Runtime::RemoteObject> value)
        {
            COMPILE_ASSERT(!(STATE & PrimaryKeySet), property_primaryKey_already_set);
            m_result->setValue(ASCIILiteral("primaryKey"), value);
            return castState<PrimaryKeySet>();
        }

        Builder<STATE | ValueSet>& setValue(PassRefPtr<Inspector::TypeBuilder::Runtime::RemoteObject> value)
        {
            COMPILE_ASSERT(!(STATE & ValueSet), property_value_already_set);
            m_result->setValue(ASCIILiteral("value"), value);
            return castState<ValueSet>();
        }

        operator RefPtr<DataEntry>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(DataEntry) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<DataEntry>*>(&m_result);
        }

        PassRefPtr<DataEntry> release()
        {
            return RefPtr<DataEntry>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<DataEntry> result = DataEntry::create()
     *     .setKey(...)
     *     .setPrimaryKey(...)
     *     .setValue(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;
};

/* Key path. */
class KeyPath : public Inspector::InspectorObjectBase {
public:
    // Named after property name 'type' while generating KeyPath.
    struct Type {
        enum Enum {
            Null = 58,
            String = 55,
            Array = 57,
        };
    }; // struct Type
    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        AllFieldsSet = (TypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*KeyPath*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class KeyPath;
    public:

        Builder<STATE | TypeSet>& setType(Type::Enum value)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString(ASCIILiteral("type"), Inspector::TypeBuilder::getWebEnumConstantValue(value));
            return castState<TypeSet>();
        }

        operator RefPtr<KeyPath>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(KeyPath) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<KeyPath>*>(&m_result);
        }

        PassRefPtr<KeyPath> release()
        {
            return RefPtr<KeyPath>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<KeyPath> result = KeyPath::create()
     *     .setType(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;

    void setString(const String& value)
    {
        this->setString(ASCIILiteral("string"), value);
    }
    using Inspector::InspectorObjectBase::setString;


    void setArray(PassRefPtr<Inspector::TypeBuilder::Array<String> > value)
    {
        this->setValue(ASCIILiteral("array"), value);
    }
    using Inspector::InspectorObjectBase::setArray;

};

} // IndexedDB

#endif // ENABLE(INDEXED_DATABASE)
namespace LayerTree {
/* A rectangle. */
class IntRect : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        XSet = 1 << 0,
        YSet = 1 << 1,
        WidthSet = 1 << 2,
        HeightSet = 1 << 3,
        AllFieldsSet = (XSet | YSet | WidthSet | HeightSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*IntRect*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class IntRect;
    public:

        Builder<STATE | XSet>& setX(int value)
        {
            COMPILE_ASSERT(!(STATE & XSet), property_x_already_set);
            m_result->setNumber(ASCIILiteral("x"), value);
            return castState<XSet>();
        }

        Builder<STATE | YSet>& setY(int value)
        {
            COMPILE_ASSERT(!(STATE & YSet), property_y_already_set);
            m_result->setNumber(ASCIILiteral("y"), value);
            return castState<YSet>();
        }

        Builder<STATE | WidthSet>& setWidth(int value)
        {
            COMPILE_ASSERT(!(STATE & WidthSet), property_width_already_set);
            m_result->setNumber(ASCIILiteral("width"), value);
            return castState<WidthSet>();
        }

        Builder<STATE | HeightSet>& setHeight(int value)
        {
            COMPILE_ASSERT(!(STATE & HeightSet), property_height_already_set);
            m_result->setNumber(ASCIILiteral("height"), value);
            return castState<HeightSet>();
        }

        operator RefPtr<IntRect>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(IntRect) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<IntRect>*>(&m_result);
        }

        PassRefPtr<IntRect> release()
        {
            return RefPtr<IntRect>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<IntRect> result = IntRect::create()
     *     .setX(...)
     *     .setY(...)
     *     .setWidth(...)
     *     .setHeight(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;
};

/* Information about a compositing layer. */
class Layer : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        LayerIdSet = 1 << 0,
        NodeIdSet = 1 << 1,
        BoundsSet = 1 << 2,
        PaintCountSet = 1 << 3,
        MemorySet = 1 << 4,
        CompositedBoundsSet = 1 << 5,
        AllFieldsSet = (LayerIdSet | NodeIdSet | BoundsSet | PaintCountSet | MemorySet | CompositedBoundsSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*Layer*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class Layer;
    public:

        Builder<STATE | LayerIdSet>& setLayerId(const Inspector::TypeBuilder::LayerTree::LayerId& value)
        {
            COMPILE_ASSERT(!(STATE & LayerIdSet), property_layerId_already_set);
            m_result->setString(ASCIILiteral("layerId"), value);
            return castState<LayerIdSet>();
        }

        Builder<STATE | NodeIdSet>& setNodeId(int value)
        {
            COMPILE_ASSERT(!(STATE & NodeIdSet), property_nodeId_already_set);
            m_result->setNumber(ASCIILiteral("nodeId"), value);
            return castState<NodeIdSet>();
        }

        Builder<STATE | BoundsSet>& setBounds(PassRefPtr<Inspector::TypeBuilder::LayerTree::IntRect> value)
        {
            COMPILE_ASSERT(!(STATE & BoundsSet), property_bounds_already_set);
            m_result->setValue(ASCIILiteral("bounds"), value);
            return castState<BoundsSet>();
        }

        Builder<STATE | PaintCountSet>& setPaintCount(int value)
        {
            COMPILE_ASSERT(!(STATE & PaintCountSet), property_paintCount_already_set);
            m_result->setNumber(ASCIILiteral("paintCount"), value);
            return castState<PaintCountSet>();
        }

        Builder<STATE | MemorySet>& setMemory(int value)
        {
            COMPILE_ASSERT(!(STATE & MemorySet), property_memory_already_set);
            m_result->setNumber(ASCIILiteral("memory"), value);
            return castState<MemorySet>();
        }

        Builder<STATE | CompositedBoundsSet>& setCompositedBounds(PassRefPtr<Inspector::TypeBuilder::LayerTree::IntRect> value)
        {
            COMPILE_ASSERT(!(STATE & CompositedBoundsSet), property_compositedBounds_already_set);
            m_result->setValue(ASCIILiteral("compositedBounds"), value);
            return castState<CompositedBoundsSet>();
        }

        operator RefPtr<Layer>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Layer) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<Layer>*>(&m_result);
        }

        PassRefPtr<Layer> release()
        {
            return RefPtr<Layer>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Layer> result = Layer::create()
     *     .setLayerId(...)
     *     .setNodeId(...)
     *     .setBounds(...)
     *     .setPaintCount(...)
     *     .setMemory(...)
     *     .setCompositedBounds(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;

    void setIsInShadowTree(bool value)
    {
        this->setBoolean(ASCIILiteral("isInShadowTree"), value);
    }

    void setIsReflection(bool value)
    {
        this->setBoolean(ASCIILiteral("isReflection"), value);
    }

    void setIsGeneratedContent(bool value)
    {
        this->setBoolean(ASCIILiteral("isGeneratedContent"), value);
    }

    void setIsAnonymous(bool value)
    {
        this->setBoolean(ASCIILiteral("isAnonymous"), value);
    }

    void setPseudoElementId(const Inspector::TypeBuilder::LayerTree::PseudoElementId& value)
    {
        this->setString(ASCIILiteral("pseudoElementId"), value);
    }

    void setPseudoElement(const String& value)
    {
        this->setString(ASCIILiteral("pseudoElement"), value);
    }
};

/* An object containing the reasons why the layer was composited as properties. */
class CompositingReasons : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        AllFieldsSet = 0
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*CompositingReasons*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class CompositingReasons;
    public:

        operator RefPtr<CompositingReasons>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CompositingReasons) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<CompositingReasons>*>(&m_result);
        }

        PassRefPtr<CompositingReasons> release()
        {
            return RefPtr<CompositingReasons>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CompositingReasons> result = CompositingReasons::create();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;

    void setTransform3D(bool value)
    {
        this->setBoolean(ASCIILiteral("transform3D"), value);
    }

    void setVideo(bool value)
    {
        this->setBoolean(ASCIILiteral("video"), value);
    }

    void setCanvas(bool value)
    {
        this->setBoolean(ASCIILiteral("canvas"), value);
    }

    void setPlugin(bool value)
    {
        this->setBoolean(ASCIILiteral("plugin"), value);
    }

    void setIFrame(bool value)
    {
        this->setBoolean(ASCIILiteral("iFrame"), value);
    }

    void setBackfaceVisibilityHidden(bool value)
    {
        this->setBoolean(ASCIILiteral("backfaceVisibilityHidden"), value);
    }

    void setClipsCompositingDescendants(bool value)
    {
        this->setBoolean(ASCIILiteral("clipsCompositingDescendants"), value);
    }

    void setAnimation(bool value)
    {
        this->setBoolean(ASCIILiteral("animation"), value);
    }

    void setFilters(bool value)
    {
        this->setBoolean(ASCIILiteral("filters"), value);
    }

    void setPositionFixed(bool value)
    {
        this->setBoolean(ASCIILiteral("positionFixed"), value);
    }

    void setPositionSticky(bool value)
    {
        this->setBoolean(ASCIILiteral("positionSticky"), value);
    }

    void setOverflowScrollingTouch(bool value)
    {
        this->setBoolean(ASCIILiteral("overflowScrollingTouch"), value);
    }

    void setStacking(bool value)
    {
        this->setBoolean(ASCIILiteral("stacking"), value);
    }

    void setOverlap(bool value)
    {
        this->setBoolean(ASCIILiteral("overlap"), value);
    }

    void setNegativeZIndexChildren(bool value)
    {
        this->setBoolean(ASCIILiteral("negativeZIndexChildren"), value);
    }

    void setTransformWithCompositedDescendants(bool value)
    {
        this->setBoolean(ASCIILiteral("transformWithCompositedDescendants"), value);
    }

    void setOpacityWithCompositedDescendants(bool value)
    {
        this->setBoolean(ASCIILiteral("opacityWithCompositedDescendants"), value);
    }

    void setMaskWithCompositedDescendants(bool value)
    {
        this->setBoolean(ASCIILiteral("maskWithCompositedDescendants"), value);
    }

    void setReflectionWithCompositedDescendants(bool value)
    {
        this->setBoolean(ASCIILiteral("reflectionWithCompositedDescendants"), value);
    }

    void setFilterWithCompositedDescendants(bool value)
    {
        this->setBoolean(ASCIILiteral("filterWithCompositedDescendants"), value);
    }

    void setBlendingWithCompositedDescendants(bool value)
    {
        this->setBoolean(ASCIILiteral("blendingWithCompositedDescendants"), value);
    }

    void setPerspective(bool value)
    {
        this->setBoolean(ASCIILiteral("perspective"), value);
    }

    void setPreserve3D(bool value)
    {
        this->setBoolean(ASCIILiteral("preserve3D"), value);
    }

    void setRoot(bool value)
    {
        this->setBoolean(ASCIILiteral("root"), value);
    }
};

} // LayerTree

namespace Memory {
class MemoryBlock : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        AllFieldsSet = (NameSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*MemoryBlock*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class MemoryBlock;
    public:

        Builder<STATE | NameSet>& setName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString(ASCIILiteral("name"), value);
            return castState<NameSet>();
        }

        operator RefPtr<MemoryBlock>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(MemoryBlock) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<MemoryBlock>*>(&m_result);
        }

        PassRefPtr<MemoryBlock> release()
        {
            return RefPtr<MemoryBlock>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<MemoryBlock> result = MemoryBlock::create()
     *     .setName(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;

    void setSize(double value)
    {
        this->setNumber(ASCIILiteral("size"), value);
    }

    void setChildren(PassRefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::Memory::MemoryBlock> > value)
    {
        this->setValue(ASCIILiteral("children"), value);
    }
};

} // Memory

namespace Network {
/* Timing information for the request. */
class ResourceTiming : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        RequestTimeSet = 1 << 0,
        ProxyStartSet = 1 << 1,
        ProxyEndSet = 1 << 2,
        DnsStartSet = 1 << 3,
        DnsEndSet = 1 << 4,
        ConnectStartSet = 1 << 5,
        ConnectEndSet = 1 << 6,
        SslStartSet = 1 << 7,
        SslEndSet = 1 << 8,
        SendStartSet = 1 << 9,
        SendEndSet = 1 << 10,
        ReceiveHeadersEndSet = 1 << 11,
        AllFieldsSet = (RequestTimeSet | ProxyStartSet | ProxyEndSet | DnsStartSet | DnsEndSet | ConnectStartSet | ConnectEndSet | SslStartSet | SslEndSet | SendStartSet | SendEndSet | ReceiveHeadersEndSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*ResourceTiming*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class ResourceTiming;
    public:

        Builder<STATE | RequestTimeSet>& setRequestTime(double value)
        {
            COMPILE_ASSERT(!(STATE & RequestTimeSet), property_requestTime_already_set);
            m_result->setNumber(ASCIILiteral("requestTime"), value);
            return castState<RequestTimeSet>();
        }

        Builder<STATE | ProxyStartSet>& setProxyStart(double value)
        {
            COMPILE_ASSERT(!(STATE & ProxyStartSet), property_proxyStart_already_set);
            m_result->setNumber(ASCIILiteral("proxyStart"), value);
            return castState<ProxyStartSet>();
        }

        Builder<STATE | ProxyEndSet>& setProxyEnd(double value)
        {
            COMPILE_ASSERT(!(STATE & ProxyEndSet), property_proxyEnd_already_set);
            m_result->setNumber(ASCIILiteral("proxyEnd"), value);
            return castState<ProxyEndSet>();
        }

        Builder<STATE | DnsStartSet>& setDnsStart(double value)
        {
            COMPILE_ASSERT(!(STATE & DnsStartSet), property_dnsStart_already_set);
            m_result->setNumber(ASCIILiteral("dnsStart"), value);
            return castState<DnsStartSet>();
        }

        Builder<STATE | DnsEndSet>& setDnsEnd(double value)
        {
            COMPILE_ASSERT(!(STATE & DnsEndSet), property_dnsEnd_already_set);
            m_result->setNumber(ASCIILiteral("dnsEnd"), value);
            return castState<DnsEndSet>();
        }

        Builder<STATE | ConnectStartSet>& setConnectStart(double value)
        {
            COMPILE_ASSERT(!(STATE & ConnectStartSet), property_connectStart_already_set);
            m_result->setNumber(ASCIILiteral("connectStart"), value);
            return castState<ConnectStartSet>();
        }

        Builder<STATE | ConnectEndSet>& setConnectEnd(double value)
        {
            COMPILE_ASSERT(!(STATE & ConnectEndSet), property_connectEnd_already_set);
            m_result->setNumber(ASCIILiteral("connectEnd"), value);
            return castState<ConnectEndSet>();
        }

        Builder<STATE | SslStartSet>& setSslStart(double value)
        {
            COMPILE_ASSERT(!(STATE & SslStartSet), property_sslStart_already_set);
            m_result->setNumber(ASCIILiteral("sslStart"), value);
            return castState<SslStartSet>();
        }

        Builder<STATE | SslEndSet>& setSslEnd(double value)
        {
            COMPILE_ASSERT(!(STATE & SslEndSet), property_sslEnd_already_set);
            m_result->setNumber(ASCIILiteral("sslEnd"), value);
            return castState<SslEndSet>();
        }

        Builder<STATE | SendStartSet>& setSendStart(double value)
        {
            COMPILE_ASSERT(!(STATE & SendStartSet), property_sendStart_already_set);
            m_result->setNumber(ASCIILiteral("sendStart"), value);
            return castState<SendStartSet>();
        }

        Builder<STATE | SendEndSet>& setSendEnd(double value)
        {
            COMPILE_ASSERT(!(STATE & SendEndSet), property_sendEnd_already_set);
            m_result->setNumber(ASCIILiteral("sendEnd"), value);
            return castState<SendEndSet>();
        }

        Builder<STATE | ReceiveHeadersEndSet>& setReceiveHeadersEnd(double value)
        {
            COMPILE_ASSERT(!(STATE & ReceiveHeadersEndSet), property_receiveHeadersEnd_already_set);
            m_result->setNumber(ASCIILiteral("receiveHeadersEnd"), value);
            return castState<ReceiveHeadersEndSet>();
        }

        operator RefPtr<ResourceTiming>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(ResourceTiming) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<ResourceTiming>*>(&m_result);
        }

        PassRefPtr<ResourceTiming> release()
        {
            return RefPtr<ResourceTiming>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<ResourceTiming> result = ResourceTiming::create()
     *     .setRequestTime(...)
     *     .setProxyStart(...)
     *     .setProxyEnd(...)
     *     .setDnsStart(...)
     *     .setDnsEnd(...)
     *     .setConnectStart(...)
     *     .setConnectEnd(...)
     *     .setSslStart(...)
     *     .setSslEnd(...)
     *     .setSendStart(...)
     *     .setSendEnd(...)
     *     .setReceiveHeadersEnd(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;
};

/* HTTP request data. */
class Request : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        UrlSet = 1 << 0,
        MethodSet = 1 << 1,
        HeadersSet = 1 << 2,
        AllFieldsSet = (UrlSet | MethodSet | HeadersSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*Request*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class Request;
    public:

        Builder<STATE | UrlSet>& setUrl(const String& value)
        {
            COMPILE_ASSERT(!(STATE & UrlSet), property_url_already_set);
            m_result->setString(ASCIILiteral("url"), value);
            return castState<UrlSet>();
        }

        Builder<STATE | MethodSet>& setMethod(const String& value)
        {
            COMPILE_ASSERT(!(STATE & MethodSet), property_method_already_set);
            m_result->setString(ASCIILiteral("method"), value);
            return castState<MethodSet>();
        }

        Builder<STATE | HeadersSet>& setHeaders(PassRefPtr<Inspector::InspectorObject> value)
        {
            COMPILE_ASSERT(!(STATE & HeadersSet), property_headers_already_set);
            m_result->setValue(ASCIILiteral("headers"), value);
            return castState<HeadersSet>();
        }

        operator RefPtr<Request>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Request) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<Request>*>(&m_result);
        }

        PassRefPtr<Request> release()
        {
            return RefPtr<Request>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Request> result = Request::create()
     *     .setUrl(...)
     *     .setMethod(...)
     *     .setHeaders(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;

    void setPostData(const String& value)
    {
        this->setString(ASCIILiteral("postData"), value);
    }
};

/* HTTP response data. */
class Response : public Inspector::InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        UrlSet = 1 << 0,
        StatusSet = 1 << 1,
        StatusTextSet = 1 << 2,
        HeadersSet = 1 << 3,
        MimeTypeSet = 1 << 4,
        ConnectionReusedSet = 1 << 5,
        ConnectionIdSet = 1 << 6,
        AllFieldsSet = (UrlSet | StatusSet | StatusTextSet | HeadersSet | MimeTypeSet | ConnectionReusedSet | ConnectionIdSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*Response*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class Response;
    public:

        Builder<STATE | UrlSet>& setUrl(const String& value)
        {
            COMPILE_ASSERT(!(STATE & UrlSet), property_url_already_set);
            m_result->setString(ASCIILiteral("url"), value);
            return castState<UrlSet>();
        }

        Builder<STATE | StatusSet>& setStatus(double value)
        {
            COMPILE_ASSERT(!(STATE & StatusSet), property_status_already_set);
            m_result->setNumber(ASCIILiteral("status"), value);
            return castState<StatusSet>();
        }

        Builder<STATE | StatusTextSet>& setStatusText(const String& value)
        {
            COMPILE_ASSERT(!(STATE & StatusTextSet), property_statusText_already_set);
            m_result->setString(ASCIILiteral("statusText"), value);
            return castState<StatusTextSet>();
        }

        Builder<STATE | HeadersSet>& setHeaders(PassRefPtr<Inspector::InspectorObject> value)
        {
            COMPILE_ASSERT(!(STATE & HeadersSet), property_headers_already_set);
            m_result->setValue(ASCIILiteral("headers"), value);
            return castState<HeadersSet>();
        }

        Builder<STATE | MimeTypeSet>& setMimeType(const String& value)
        {
            COMPILE_ASSERT(!(STATE & MimeTypeSet), property_mimeType_already_set);
            m_result->setString(ASCIILiteral("mimeType"), value);
            return castState<MimeTypeSet>();
        }

        Builder<STATE | ConnectionReusedSet>& setConnectionReused(bool value)
        {
            COMPILE_ASSERT(!(STATE & ConnectionReusedSet), property_connectionReused_already_set);
            m_result->setBoolean(ASCIILiteral("connectionReused"), value);
            return castState<ConnectionReusedSet>();
        }

        Builder<STATE | ConnectionIdSet>& setConnectionId(double value)
        {
            COMPILE_ASSERT(!(STATE & ConnectionIdSet), property_connectionId_already_set);
            m_result->setNumber(ASCIILiteral("connectionId"), value);
            return castState<ConnectionIdSet>();
        }

        operator RefPtr<Response>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Response) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<Response>*>(&m_result);
        }

        PassRefPtr<Response> release()
        {
            return RefPtr<Response>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Response> result = Response::create()
     *     .setUrl(...)
     *     .setStatus(...)
     *     .setStatusText(...)
     *     .setHeaders(...)
     *     .setMimeType(...)
     *     .setConnectionReused(...)
     *     .setConnectionId(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;

    void setHeadersText(const String& value)
    {
        this->setString(ASCIILiteral("headersText"), value);
    }

    void setRequestHeaders(PassRefPtr<Inspector::InspectorObject> value)
    {
        this->setValue(ASCIILiteral("requestHeaders"), value);
    }

    void setRequestHeadersText(const String& value)
    {
        this->setString(ASCIILiteral("requestHeadersText"), value);
    }

    void setFromDiskCache(bool value)
    {
        this->setBoolean(ASCIILiteral("fromDiskCache"), value);
    }

    void setTiming(PassRefPtr<Inspector::TypeBuilder::Network::ResourceTiming> value)
    {
        this->setValue(ASCIILiteral("timing"), value);
    }

    // Property names for type generated as open.
    static const char* Url;
    static const char* Status;
    static const char* StatusText;
    static const char* Headers;
    static const char* MimeType;
    static const char* ConnectionReused;
    static const char* ConnectionId;
    static const char* HeadersText;
    static const char* RequestHeaders;
    static const char* RequestHeadersText;
    static const char* FromDiskCache;
    static const char* Timing;
};

/* WebSocket request data. */
class WebSocketRequest : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        HeadersSet = 1 << 0,
        AllFieldsSet = (HeadersSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*WebSocketRequest*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class WebSocketRequest;
    public:

        Builder<STATE | HeadersSet>& setHeaders(PassRefPtr<Inspector::InspectorObject> value)
        {
            COMPILE_ASSERT(!(STATE & HeadersSet), property_headers_already_set);
            m_result->setValue(ASCIILiteral("headers"), value);
            return castState<HeadersSet>();
        }

        operator RefPtr<WebSocketRequest>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(WebSocketRequest) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<WebSocketRequest>*>(&m_result);
        }

        PassRefPtr<WebSocketRequest> release()
        {
            return RefPtr<WebSocketRequest>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<WebSocketRequest> result = WebSocketRequest::create()
     *     .setHeaders(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;
};

/* WebSocket response data. */
class WebSocketResponse : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        StatusSet = 1 << 0,
        StatusTextSet = 1 << 1,
        HeadersSet = 1 << 2,
        AllFieldsSet = (StatusSet | StatusTextSet | HeadersSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*WebSocketResponse*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class WebSocketResponse;
    public:

        Builder<STATE | StatusSet>& setStatus(double value)
        {
            COMPILE_ASSERT(!(STATE & StatusSet), property_status_already_set);
            m_result->setNumber(ASCIILiteral("status"), value);
            return castState<StatusSet>();
        }

        Builder<STATE | StatusTextSet>& setStatusText(const String& value)
        {
            COMPILE_ASSERT(!(STATE & StatusTextSet), property_statusText_already_set);
            m_result->setString(ASCIILiteral("statusText"), value);
            return castState<StatusTextSet>();
        }

        Builder<STATE | HeadersSet>& setHeaders(PassRefPtr<Inspector::InspectorObject> value)
        {
            COMPILE_ASSERT(!(STATE & HeadersSet), property_headers_already_set);
            m_result->setValue(ASCIILiteral("headers"), value);
            return castState<HeadersSet>();
        }

        operator RefPtr<WebSocketResponse>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(WebSocketResponse) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<WebSocketResponse>*>(&m_result);
        }

        PassRefPtr<WebSocketResponse> release()
        {
            return RefPtr<WebSocketResponse>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<WebSocketResponse> result = WebSocketResponse::create()
     *     .setStatus(...)
     *     .setStatusText(...)
     *     .setHeaders(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;
};

/* WebSocket frame data. */
class WebSocketFrame : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        OpcodeSet = 1 << 0,
        MaskSet = 1 << 1,
        PayloadDataSet = 1 << 2,
        AllFieldsSet = (OpcodeSet | MaskSet | PayloadDataSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*WebSocketFrame*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class WebSocketFrame;
    public:

        Builder<STATE | OpcodeSet>& setOpcode(double value)
        {
            COMPILE_ASSERT(!(STATE & OpcodeSet), property_opcode_already_set);
            m_result->setNumber(ASCIILiteral("opcode"), value);
            return castState<OpcodeSet>();
        }

        Builder<STATE | MaskSet>& setMask(bool value)
        {
            COMPILE_ASSERT(!(STATE & MaskSet), property_mask_already_set);
            m_result->setBoolean(ASCIILiteral("mask"), value);
            return castState<MaskSet>();
        }

        Builder<STATE | PayloadDataSet>& setPayloadData(const String& value)
        {
            COMPILE_ASSERT(!(STATE & PayloadDataSet), property_payloadData_already_set);
            m_result->setString(ASCIILiteral("payloadData"), value);
            return castState<PayloadDataSet>();
        }

        operator RefPtr<WebSocketFrame>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(WebSocketFrame) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<WebSocketFrame>*>(&m_result);
        }

        PassRefPtr<WebSocketFrame> release()
        {
            return RefPtr<WebSocketFrame>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<WebSocketFrame> result = WebSocketFrame::create()
     *     .setOpcode(...)
     *     .setMask(...)
     *     .setPayloadData(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;
};

/* Information about the cached resource. */
class CachedResource : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        UrlSet = 1 << 0,
        TypeSet = 1 << 1,
        BodySizeSet = 1 << 2,
        AllFieldsSet = (UrlSet | TypeSet | BodySizeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*CachedResource*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class CachedResource;
    public:

        Builder<STATE | UrlSet>& setUrl(const String& value)
        {
            COMPILE_ASSERT(!(STATE & UrlSet), property_url_already_set);
            m_result->setString(ASCIILiteral("url"), value);
            return castState<UrlSet>();
        }

        Builder<STATE | TypeSet>& setType(Inspector::TypeBuilder::Page::ResourceType::Enum value)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString(ASCIILiteral("type"), Inspector::TypeBuilder::getWebEnumConstantValue(value));
            return castState<TypeSet>();
        }

        Builder<STATE | BodySizeSet>& setBodySize(double value)
        {
            COMPILE_ASSERT(!(STATE & BodySizeSet), property_bodySize_already_set);
            m_result->setNumber(ASCIILiteral("bodySize"), value);
            return castState<BodySizeSet>();
        }

        operator RefPtr<CachedResource>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CachedResource) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<CachedResource>*>(&m_result);
        }

        PassRefPtr<CachedResource> release()
        {
            return RefPtr<CachedResource>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CachedResource> result = CachedResource::create()
     *     .setUrl(...)
     *     .setType(...)
     *     .setBodySize(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;

    void setResponse(PassRefPtr<Inspector::TypeBuilder::Network::Response> value)
    {
        this->setValue(ASCIILiteral("response"), value);
    }

    void setSourceMapURL(const String& value)
    {
        this->setString(ASCIILiteral("sourceMapURL"), value);
    }
};

/* Information about the request initiator. */
class Initiator : public Inspector::InspectorObjectBase {
public:
    // Named after property name 'type' while generating Initiator.
    struct Type {
        enum Enum {
            Parser = 59,
            Script = 60,
            Other = 34,
        };
    }; // struct Type
    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        AllFieldsSet = (TypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*Initiator*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class Initiator;
    public:

        Builder<STATE | TypeSet>& setType(Type::Enum value)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString(ASCIILiteral("type"), Inspector::TypeBuilder::getWebEnumConstantValue(value));
            return castState<TypeSet>();
        }

        operator RefPtr<Initiator>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Initiator) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<Initiator>*>(&m_result);
        }

        PassRefPtr<Initiator> release()
        {
            return RefPtr<Initiator>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Initiator> result = Initiator::create()
     *     .setType(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;

    void setStackTrace(PassRefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::Console::CallFrame> > value)
    {
        this->setValue(ASCIILiteral("stackTrace"), value);
    }

    void setUrl(const String& value)
    {
        this->setString(ASCIILiteral("url"), value);
    }

    void setLineNumber(double value)
    {
        this->setNumber(ASCIILiteral("lineNumber"), value);
    }
};

} // Network

#if ENABLE(JAVASCRIPT_DEBUGGER)
namespace Profiler {
/* Profile header. */
class ProfileHeader : public Inspector::InspectorObjectBase {
public:
    // Named after property name 'typeId' while generating ProfileHeader.
    struct TypeId {
        enum Enum {
            CPU = 61,
            CSS = 62,
            HEAP = 63,
        };
    }; // struct TypeId
    enum {
        NoFieldsSet = 0,
        TypeIdSet = 1 << 0,
        TitleSet = 1 << 1,
        UidSet = 1 << 2,
        AllFieldsSet = (TypeIdSet | TitleSet | UidSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*ProfileHeader*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class ProfileHeader;
    public:

        Builder<STATE | TypeIdSet>& setTypeId(TypeId::Enum value)
        {
            COMPILE_ASSERT(!(STATE & TypeIdSet), property_typeId_already_set);
            m_result->setString(ASCIILiteral("typeId"), Inspector::TypeBuilder::getWebEnumConstantValue(value));
            return castState<TypeIdSet>();
        }

        Builder<STATE | TitleSet>& setTitle(const String& value)
        {
            COMPILE_ASSERT(!(STATE & TitleSet), property_title_already_set);
            m_result->setString(ASCIILiteral("title"), value);
            return castState<TitleSet>();
        }

        Builder<STATE | UidSet>& setUid(int value)
        {
            COMPILE_ASSERT(!(STATE & UidSet), property_uid_already_set);
            m_result->setNumber(ASCIILiteral("uid"), value);
            return castState<UidSet>();
        }

        operator RefPtr<ProfileHeader>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(ProfileHeader) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<ProfileHeader>*>(&m_result);
        }

        PassRefPtr<ProfileHeader> release()
        {
            return RefPtr<ProfileHeader>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<ProfileHeader> result = ProfileHeader::create()
     *     .setTypeId(...)
     *     .setTitle(...)
     *     .setUid(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;

    void setMaxJSObjectId(int value)
    {
        this->setNumber(ASCIILiteral("maxJSObjectId"), value);
    }
};

/* CPU Profile node. Holds callsite information, execution statistics and child nodes. */
class CPUProfileNode : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        FunctionNameSet = 1 << 0,
        UrlSet = 1 << 1,
        LineNumberSet = 1 << 2,
        TotalTimeSet = 1 << 3,
        SelfTimeSet = 1 << 4,
        NumberOfCallsSet = 1 << 5,
        VisibleSet = 1 << 6,
        CallUIDSet = 1 << 7,
        ChildrenSet = 1 << 8,
        AllFieldsSet = (FunctionNameSet | UrlSet | LineNumberSet | TotalTimeSet | SelfTimeSet | NumberOfCallsSet | VisibleSet | CallUIDSet | ChildrenSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*CPUProfileNode*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class CPUProfileNode;
    public:

        Builder<STATE | FunctionNameSet>& setFunctionName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & FunctionNameSet), property_functionName_already_set);
            m_result->setString(ASCIILiteral("functionName"), value);
            return castState<FunctionNameSet>();
        }

        Builder<STATE | UrlSet>& setUrl(const String& value)
        {
            COMPILE_ASSERT(!(STATE & UrlSet), property_url_already_set);
            m_result->setString(ASCIILiteral("url"), value);
            return castState<UrlSet>();
        }

        Builder<STATE | LineNumberSet>& setLineNumber(int value)
        {
            COMPILE_ASSERT(!(STATE & LineNumberSet), property_lineNumber_already_set);
            m_result->setNumber(ASCIILiteral("lineNumber"), value);
            return castState<LineNumberSet>();
        }

        Builder<STATE | TotalTimeSet>& setTotalTime(double value)
        {
            COMPILE_ASSERT(!(STATE & TotalTimeSet), property_totalTime_already_set);
            m_result->setNumber(ASCIILiteral("totalTime"), value);
            return castState<TotalTimeSet>();
        }

        Builder<STATE | SelfTimeSet>& setSelfTime(double value)
        {
            COMPILE_ASSERT(!(STATE & SelfTimeSet), property_selfTime_already_set);
            m_result->setNumber(ASCIILiteral("selfTime"), value);
            return castState<SelfTimeSet>();
        }

        Builder<STATE | NumberOfCallsSet>& setNumberOfCalls(int value)
        {
            COMPILE_ASSERT(!(STATE & NumberOfCallsSet), property_numberOfCalls_already_set);
            m_result->setNumber(ASCIILiteral("numberOfCalls"), value);
            return castState<NumberOfCallsSet>();
        }

        Builder<STATE | VisibleSet>& setVisible(bool value)
        {
            COMPILE_ASSERT(!(STATE & VisibleSet), property_visible_already_set);
            m_result->setBoolean(ASCIILiteral("visible"), value);
            return castState<VisibleSet>();
        }

        Builder<STATE | CallUIDSet>& setCallUID(double value)
        {
            COMPILE_ASSERT(!(STATE & CallUIDSet), property_callUID_already_set);
            m_result->setNumber(ASCIILiteral("callUID"), value);
            return castState<CallUIDSet>();
        }

        Builder<STATE | ChildrenSet>& setChildren(PassRefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::Profiler::CPUProfileNode> > value)
        {
            COMPILE_ASSERT(!(STATE & ChildrenSet), property_children_already_set);
            m_result->setValue(ASCIILiteral("children"), value);
            return castState<ChildrenSet>();
        }

        operator RefPtr<CPUProfileNode>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CPUProfileNode) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<CPUProfileNode>*>(&m_result);
        }

        PassRefPtr<CPUProfileNode> release()
        {
            return RefPtr<CPUProfileNode>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CPUProfileNode> result = CPUProfileNode::create()
     *     .setFunctionName(...)
     *     .setUrl(...)
     *     .setLineNumber(...)
     *     .setTotalTime(...)
     *     .setSelfTime(...)
     *     .setNumberOfCalls(...)
     *     .setVisible(...)
     *     .setCallUID(...)
     *     .setChildren(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;

    void setId(int value)
    {
        this->setNumber(ASCIILiteral("id"), value);
    }
};

/* Profile. */
class CPUProfile : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        AllFieldsSet = 0
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*CPUProfile*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class CPUProfile;
    public:

        operator RefPtr<CPUProfile>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CPUProfile) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<CPUProfile>*>(&m_result);
        }

        PassRefPtr<CPUProfile> release()
        {
            return RefPtr<CPUProfile>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CPUProfile> result = CPUProfile::create();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;

    void setHead(PassRefPtr<Inspector::TypeBuilder::Profiler::CPUProfileNode> value)
    {
        this->setValue(ASCIILiteral("head"), value);
    }

    void setIdleTime(double value)
    {
        this->setNumber(ASCIILiteral("idleTime"), value);
    }

    void setSamples(PassRefPtr<Inspector::TypeBuilder::Array<int> > value)
    {
        this->setValue(ASCIILiteral("samples"), value);
    }
};

} // Profiler

#endif // ENABLE(JAVASCRIPT_DEBUGGER)
namespace Timeline {
/* Current values of DOM counters. */
class DOMCounters : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        DocumentsSet = 1 << 0,
        NodesSet = 1 << 1,
        JsEventListenersSet = 1 << 2,
        AllFieldsSet = (DocumentsSet | NodesSet | JsEventListenersSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*DOMCounters*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class DOMCounters;
    public:

        Builder<STATE | DocumentsSet>& setDocuments(int value)
        {
            COMPILE_ASSERT(!(STATE & DocumentsSet), property_documents_already_set);
            m_result->setNumber(ASCIILiteral("documents"), value);
            return castState<DocumentsSet>();
        }

        Builder<STATE | NodesSet>& setNodes(int value)
        {
            COMPILE_ASSERT(!(STATE & NodesSet), property_nodes_already_set);
            m_result->setNumber(ASCIILiteral("nodes"), value);
            return castState<NodesSet>();
        }

        Builder<STATE | JsEventListenersSet>& setJsEventListeners(int value)
        {
            COMPILE_ASSERT(!(STATE & JsEventListenersSet), property_jsEventListeners_already_set);
            m_result->setNumber(ASCIILiteral("jsEventListeners"), value);
            return castState<JsEventListenersSet>();
        }

        operator RefPtr<DOMCounters>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(DOMCounters) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<DOMCounters>*>(&m_result);
        }

        PassRefPtr<DOMCounters> release()
        {
            return RefPtr<DOMCounters>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<DOMCounters> result = DOMCounters::create()
     *     .setDocuments(...)
     *     .setNodes(...)
     *     .setJsEventListeners(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;
#if !ASSERT_DISABLED
    static  void assertCorrectValue(Inspector::InspectorValue* value);
#endif  // !ASSERT_DISABLED
};

/* Timeline record type. */
struct EventType {
    enum Enum {
        EventDispatch = 64,
        BeginFrame = 65,
        ScheduleStyleRecalculation = 66,
        RecalculateStyles = 67,
        InvalidateLayout = 68,
        Layout = 69,
        Paint = 70,
        ScrollLayer = 71,
        ResizeImage = 72,
        CompositeLayers = 73,
        ParseHTML = 74,
        TimerInstall = 75,
        TimerRemove = 76,
        TimerFire = 77,
        EvaluateScript = 78,
        MarkLoad = 79,
        MarkDOMContent = 80,
        TimeStamp = 81,
        Time = 82,
        TimeEnd = 83,
        ScheduleResourceRequest = 84,
        ResourceSendRequest = 85,
        ResourceReceiveResponse = 86,
        ResourceReceivedData = 87,
        ResourceFinish = 88,
        XHRReadyStateChange = 89,
        XHRLoad = 90,
        FunctionCall = 91,
        GCEvent = 92,
        RequestAnimationFrame = 93,
        CancelAnimationFrame = 94,
        FireAnimationFrame = 95,
        WebSocketCreate = 96,
        WebSocketSendHandshakeRequest = 97,
        WebSocketReceiveHandshakeResponse = 98,
        WebSocketDestroy = 99,
    };
#if !ASSERT_DISABLED
    static void assertCorrectValue(Inspector::InspectorValue* value);
#endif  // !ASSERT_DISABLED
}; // struct EventType
/* Timeline record contains information about the recorded activity. */
class TimelineEvent : public Inspector::InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        DataSet = 1 << 1,
        AllFieldsSet = (TypeSet | DataSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*TimelineEvent*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class TimelineEvent;
    public:

        Builder<STATE | TypeSet>& setType(Inspector::TypeBuilder::Timeline::EventType::Enum value)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString(ASCIILiteral("type"), Inspector::TypeBuilder::getWebEnumConstantValue(value));
            return castState<TypeSet>();
        }

        Builder<STATE | DataSet>& setData(PassRefPtr<Inspector::InspectorObject> value)
        {
            COMPILE_ASSERT(!(STATE & DataSet), property_data_already_set);
            m_result->setValue(ASCIILiteral("data"), value);
            return castState<DataSet>();
        }

        operator RefPtr<TimelineEvent>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(TimelineEvent) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<TimelineEvent>*>(&m_result);
        }

        PassRefPtr<TimelineEvent> release()
        {
            return RefPtr<TimelineEvent>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<TimelineEvent> result = TimelineEvent::create()
     *     .setType(...)
     *     .setData(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::TypeBuilder::StructItemTraits ItemTraits;

    void setThread(const String& value)
    {
        this->setString(ASCIILiteral("thread"), value);
    }

    void setChildren(PassRefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::Timeline::TimelineEvent> > value)
    {
        this->setValue(ASCIILiteral("children"), value);
    }

    void setCounters(PassRefPtr<Inspector::TypeBuilder::Timeline::DOMCounters> value)
    {
        this->setValue(ASCIILiteral("counters"), value);
    }

    void setUsedHeapSize(int value)
    {
        this->setNumber(ASCIILiteral("usedHeapSize"), value);
    }
    static PassRefPtr<TimelineEvent> runtimeCast(PassRefPtr<Inspector::InspectorValue> value)
    {
        RefPtr<Inspector::InspectorObject> object;
        bool castRes = value->asObject(&object);
        ASSERT_UNUSED(castRes, castRes);
#if !ASSERT_DISABLED
        assertCorrectValue(object.get());
#endif  // !ASSERT_DISABLED
        COMPILE_ASSERT(sizeof(TimelineEvent) == sizeof(Inspector::InspectorObjectBase), type_cast_problem);
        return static_cast<TimelineEvent*>(static_cast<Inspector::InspectorObjectBase*>(object.get()));
    }

#if !ASSERT_DISABLED
    static  void assertCorrectValue(Inspector::InspectorValue* value);
#endif  // !ASSERT_DISABLED

    // Property names for type generated as open.
    static const char* Type;
    static const char* Data;
    static const char* Thread;
    static const char* Children;
    static const char* Counters;
    static const char* UsedHeapSize;
};

} // Timeline


} // namespace TypeBuilder

} // namespace Inspector

#endif // ENABLE(INSPECTOR)

#endif // !defined(InspectorWebTypeBuilders_h)
