// File is generated by JavaScriptCore/inspector/scripts/CodeGeneratorInspector.py

// Copyright (c) 2013 Apple Inc. All Rights Reserved.
// Copyright (c) 2011 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "config.h"
#include "InspectorWebBackendDispatchers.h"

#if ENABLE(INSPECTOR)

#include <inspector/InspectorFrontendChannel.h>
#include <inspector/InspectorValues.h>
#include <wtf/text/CString.h>
#include <wtf/text/WTFString.h>

namespace Inspector {

InspectorApplicationCacheBackendDispatcherHandler::~InspectorApplicationCacheBackendDispatcherHandler() { }
InspectorCSSBackendDispatcherHandler::~InspectorCSSBackendDispatcherHandler() { }
InspectorCanvasBackendDispatcherHandler::~InspectorCanvasBackendDispatcherHandler() { }
InspectorConsoleBackendDispatcherHandler::~InspectorConsoleBackendDispatcherHandler() { }
InspectorDOMBackendDispatcherHandler::~InspectorDOMBackendDispatcherHandler() { }
#if ENABLE(JAVASCRIPT_DEBUGGER)
InspectorDOMDebuggerBackendDispatcherHandler::~InspectorDOMDebuggerBackendDispatcherHandler() { }
#endif // ENABLE(JAVASCRIPT_DEBUGGER)
InspectorDOMStorageBackendDispatcherHandler::~InspectorDOMStorageBackendDispatcherHandler() { }
#if ENABLE(SQL_DATABASE)
InspectorDatabaseBackendDispatcherHandler::~InspectorDatabaseBackendDispatcherHandler() { }
#endif // ENABLE(SQL_DATABASE)
InspectorHeapProfilerBackendDispatcherHandler::~InspectorHeapProfilerBackendDispatcherHandler() { }
#if ENABLE(INDEXED_DATABASE)
InspectorIndexedDBBackendDispatcherHandler::~InspectorIndexedDBBackendDispatcherHandler() { }
#endif // ENABLE(INDEXED_DATABASE)
InspectorInputBackendDispatcherHandler::~InspectorInputBackendDispatcherHandler() { }
InspectorLayerTreeBackendDispatcherHandler::~InspectorLayerTreeBackendDispatcherHandler() { }
InspectorMemoryBackendDispatcherHandler::~InspectorMemoryBackendDispatcherHandler() { }
InspectorNetworkBackendDispatcherHandler::~InspectorNetworkBackendDispatcherHandler() { }
InspectorPageBackendDispatcherHandler::~InspectorPageBackendDispatcherHandler() { }
#if ENABLE(JAVASCRIPT_DEBUGGER)
InspectorProfilerBackendDispatcherHandler::~InspectorProfilerBackendDispatcherHandler() { }
#endif // ENABLE(JAVASCRIPT_DEBUGGER)
InspectorTimelineBackendDispatcherHandler::~InspectorTimelineBackendDispatcherHandler() { }
InspectorWorkerBackendDispatcherHandler::~InspectorWorkerBackendDispatcherHandler() { }


PassRefPtr<InspectorApplicationCacheBackendDispatcher> InspectorApplicationCacheBackendDispatcher::create(InspectorBackendDispatcher* backendDispatcher, InspectorApplicationCacheBackendDispatcherHandler* agent)
{
    return adoptRef(new InspectorApplicationCacheBackendDispatcher(backendDispatcher, agent));
}

InspectorApplicationCacheBackendDispatcher::InspectorApplicationCacheBackendDispatcher(InspectorBackendDispatcher* backendDispatcher, InspectorApplicationCacheBackendDispatcherHandler* agent)
    : InspectorSupplementalBackendDispatcher(backendDispatcher)
    , m_agent(agent)
{
    m_backendDispatcher->registerDispatcherForDomain(ASCIILiteral("ApplicationCache"), this);
}

void InspectorApplicationCacheBackendDispatcher::dispatch(long callId, const String& method, PassRefPtr<InspectorObject> message)
{
    Ref<InspectorApplicationCacheBackendDispatcher> protect(*this);

    if (method == "getFramesWithManifests")
        getFramesWithManifests(callId, *message.get());
    else if (method == "enable")
        enable(callId, *message.get());
    else if (method == "getManifestForFrame")
        getManifestForFrame(callId, *message.get());
    else if (method == "getApplicationCacheForFrame")
        getApplicationCacheForFrame(callId, *message.get());
    else
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::MethodNotFound, String("'") + "ApplicationCache" + '.' + method + "' was not found");
}

void InspectorApplicationCacheBackendDispatcher::getFramesWithManifests(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::ApplicationCache::FrameWithManifest> > out_frameIds;
    m_agent->getFramesWithManifests(&error, out_frameIds);

    if (!error.length())
        result->setValue(ASCIILiteral("frameIds"), out_frameIds);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorApplicationCacheBackendDispatcher::enable(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->enable(&error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorApplicationCacheBackendDispatcher::getManifestForFrame(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_frameId = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("frameId"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "ApplicationCache.getManifestForFrame");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    String out_manifestURL;
    m_agent->getManifestForFrame(&error, in_frameId, &out_manifestURL);

    if (!error.length())
        result->setString(ASCIILiteral("manifestURL"), out_manifestURL);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorApplicationCacheBackendDispatcher::getApplicationCacheForFrame(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_frameId = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("frameId"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "ApplicationCache.getApplicationCacheForFrame");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::TypeBuilder::ApplicationCache::ApplicationCache> out_applicationCache;
    m_agent->getApplicationCacheForFrame(&error, in_frameId, out_applicationCache);

    if (!error.length())
        result->setValue(ASCIILiteral("applicationCache"), out_applicationCache);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

PassRefPtr<InspectorCSSBackendDispatcher> InspectorCSSBackendDispatcher::create(InspectorBackendDispatcher* backendDispatcher, InspectorCSSBackendDispatcherHandler* agent)
{
    return adoptRef(new InspectorCSSBackendDispatcher(backendDispatcher, agent));
}

InspectorCSSBackendDispatcher::InspectorCSSBackendDispatcher(InspectorBackendDispatcher* backendDispatcher, InspectorCSSBackendDispatcherHandler* agent)
    : InspectorSupplementalBackendDispatcher(backendDispatcher)
    , m_agent(agent)
{
    m_backendDispatcher->registerDispatcherForDomain(ASCIILiteral("CSS"), this);
}

void InspectorCSSBackendDispatcher::dispatch(long callId, const String& method, PassRefPtr<InspectorObject> message)
{
    Ref<InspectorCSSBackendDispatcher> protect(*this);

    typedef void (InspectorCSSBackendDispatcher::*CallHandler)(long callId, const Inspector::InspectorObject& message);
    typedef HashMap<String, CallHandler> DispatchMap;
    DEFINE_STATIC_LOCAL(DispatchMap, dispatchMap, ());
    if (dispatchMap.isEmpty()) {
        static const struct MethodTable {
            const char* name;
            CallHandler handler;
        } commands[] = {
            { "enable", &InspectorCSSBackendDispatcher::enable },
            { "disable", &InspectorCSSBackendDispatcher::disable },
            { "getMatchedStylesForNode", &InspectorCSSBackendDispatcher::getMatchedStylesForNode },
            { "getInlineStylesForNode", &InspectorCSSBackendDispatcher::getInlineStylesForNode },
            { "getComputedStyleForNode", &InspectorCSSBackendDispatcher::getComputedStyleForNode },
            { "getAllStyleSheets", &InspectorCSSBackendDispatcher::getAllStyleSheets },
            { "getStyleSheet", &InspectorCSSBackendDispatcher::getStyleSheet },
            { "getStyleSheetText", &InspectorCSSBackendDispatcher::getStyleSheetText },
            { "setStyleSheetText", &InspectorCSSBackendDispatcher::setStyleSheetText },
            { "setStyleText", &InspectorCSSBackendDispatcher::setStyleText },
            { "setPropertyText", &InspectorCSSBackendDispatcher::setPropertyText },
            { "toggleProperty", &InspectorCSSBackendDispatcher::toggleProperty },
            { "setRuleSelector", &InspectorCSSBackendDispatcher::setRuleSelector },
            { "addRule", &InspectorCSSBackendDispatcher::addRule },
            { "getSupportedCSSProperties", &InspectorCSSBackendDispatcher::getSupportedCSSProperties },
            { "forcePseudoState", &InspectorCSSBackendDispatcher::forcePseudoState },
            { "startSelectorProfiler", &InspectorCSSBackendDispatcher::startSelectorProfiler },
            { "stopSelectorProfiler", &InspectorCSSBackendDispatcher::stopSelectorProfiler },
            { "getNamedFlowCollection", &InspectorCSSBackendDispatcher::getNamedFlowCollection },
        };
        size_t length = WTF_ARRAY_LENGTH(commands);
        for (size_t i = 0; i < length; ++i)
            dispatchMap.add(commands[i].name, commands[i].handler);
    }

    HashMap<String, CallHandler>::iterator it = dispatchMap.find(method);
    if (it == dispatchMap.end()) {
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::MethodNotFound, String("'") + "CSS" + '.' + method + "' was not found");
        return;
    }

    ((*this).*it->value)(callId, *message.get());
}

void InspectorCSSBackendDispatcher::enable(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->enable(&error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorCSSBackendDispatcher::disable(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->disable(&error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorCSSBackendDispatcher::getMatchedStylesForNode(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("nodeId"), nullptr, protocolErrorsPtr);
    bool includePseudo_valueFound = false;
    bool in_includePseudo = InspectorBackendDispatcher::getBoolean(paramsContainerPtr, ASCIILiteral("includePseudo"), &includePseudo_valueFound, protocolErrorsPtr);
    bool includeInherited_valueFound = false;
    bool in_includeInherited = InspectorBackendDispatcher::getBoolean(paramsContainerPtr, ASCIILiteral("includeInherited"), &includeInherited_valueFound, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "CSS.getMatchedStylesForNode");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::CSS::RuleMatch> > out_matchedCSSRules;
    RefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::CSS::PseudoIdMatches> > out_pseudoElements;
    RefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::CSS::InheritedStyleEntry> > out_inherited;
    m_agent->getMatchedStylesForNode(&error, in_nodeId, includePseudo_valueFound ? &in_includePseudo : nullptr, includeInherited_valueFound ? &in_includeInherited : nullptr, out_matchedCSSRules, out_pseudoElements, out_inherited);

    if (!error.length()) {
        if (out_matchedCSSRules)
            result->setValue(ASCIILiteral("matchedCSSRules"), out_matchedCSSRules);
        if (out_pseudoElements)
            result->setValue(ASCIILiteral("pseudoElements"), out_pseudoElements);
        if (out_inherited)
            result->setValue(ASCIILiteral("inherited"), out_inherited);
    }

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorCSSBackendDispatcher::getInlineStylesForNode(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("nodeId"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "CSS.getInlineStylesForNode");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::TypeBuilder::CSS::CSSStyle> out_inlineStyle;
    RefPtr<Inspector::TypeBuilder::CSS::CSSStyle> out_attributesStyle;
    m_agent->getInlineStylesForNode(&error, in_nodeId, out_inlineStyle, out_attributesStyle);

    if (!error.length()) {
        if (out_inlineStyle)
            result->setValue(ASCIILiteral("inlineStyle"), out_inlineStyle);
        if (out_attributesStyle)
            result->setValue(ASCIILiteral("attributesStyle"), out_attributesStyle);
    }

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorCSSBackendDispatcher::getComputedStyleForNode(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("nodeId"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "CSS.getComputedStyleForNode");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::CSS::CSSComputedStyleProperty> > out_computedStyle;
    m_agent->getComputedStyleForNode(&error, in_nodeId, out_computedStyle);

    if (!error.length())
        result->setValue(ASCIILiteral("computedStyle"), out_computedStyle);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorCSSBackendDispatcher::getAllStyleSheets(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::CSS::CSSStyleSheetHeader> > out_headers;
    m_agent->getAllStyleSheets(&error, out_headers);

    if (!error.length())
        result->setValue(ASCIILiteral("headers"), out_headers);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorCSSBackendDispatcher::getStyleSheet(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_styleSheetId = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("styleSheetId"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "CSS.getStyleSheet");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::TypeBuilder::CSS::CSSStyleSheetBody> out_styleSheet;
    m_agent->getStyleSheet(&error, in_styleSheetId, out_styleSheet);

    if (!error.length())
        result->setValue(ASCIILiteral("styleSheet"), out_styleSheet);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorCSSBackendDispatcher::getStyleSheetText(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_styleSheetId = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("styleSheetId"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "CSS.getStyleSheetText");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    String out_text;
    m_agent->getStyleSheetText(&error, in_styleSheetId, &out_text);

    if (!error.length())
        result->setString(ASCIILiteral("text"), out_text);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorCSSBackendDispatcher::setStyleSheetText(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_styleSheetId = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("styleSheetId"), nullptr, protocolErrorsPtr);
    String in_text = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("text"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "CSS.setStyleSheetText");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->setStyleSheetText(&error, in_styleSheetId, in_text);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorCSSBackendDispatcher::setStyleText(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    RefPtr<Inspector::InspectorObject> in_styleId = InspectorBackendDispatcher::getObject(paramsContainerPtr, ASCIILiteral("styleId"), nullptr, protocolErrorsPtr);
    String in_text = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("text"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "CSS.setStyleText");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::TypeBuilder::CSS::CSSStyle> out_style;
    m_agent->setStyleText(&error, in_styleId, in_text, out_style);

    if (!error.length())
        result->setValue(ASCIILiteral("style"), out_style);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorCSSBackendDispatcher::setPropertyText(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    RefPtr<Inspector::InspectorObject> in_styleId = InspectorBackendDispatcher::getObject(paramsContainerPtr, ASCIILiteral("styleId"), nullptr, protocolErrorsPtr);
    int in_propertyIndex = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("propertyIndex"), nullptr, protocolErrorsPtr);
    String in_text = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("text"), nullptr, protocolErrorsPtr);
    bool in_overwrite = InspectorBackendDispatcher::getBoolean(paramsContainerPtr, ASCIILiteral("overwrite"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "CSS.setPropertyText");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::TypeBuilder::CSS::CSSStyle> out_style;
    m_agent->setPropertyText(&error, in_styleId, in_propertyIndex, in_text, in_overwrite, out_style);

    if (!error.length())
        result->setValue(ASCIILiteral("style"), out_style);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorCSSBackendDispatcher::toggleProperty(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    RefPtr<Inspector::InspectorObject> in_styleId = InspectorBackendDispatcher::getObject(paramsContainerPtr, ASCIILiteral("styleId"), nullptr, protocolErrorsPtr);
    int in_propertyIndex = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("propertyIndex"), nullptr, protocolErrorsPtr);
    bool in_disable = InspectorBackendDispatcher::getBoolean(paramsContainerPtr, ASCIILiteral("disable"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "CSS.toggleProperty");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::TypeBuilder::CSS::CSSStyle> out_style;
    m_agent->toggleProperty(&error, in_styleId, in_propertyIndex, in_disable, out_style);

    if (!error.length())
        result->setValue(ASCIILiteral("style"), out_style);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorCSSBackendDispatcher::setRuleSelector(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    RefPtr<Inspector::InspectorObject> in_ruleId = InspectorBackendDispatcher::getObject(paramsContainerPtr, ASCIILiteral("ruleId"), nullptr, protocolErrorsPtr);
    String in_selector = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("selector"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "CSS.setRuleSelector");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::TypeBuilder::CSS::CSSRule> out_rule;
    m_agent->setRuleSelector(&error, in_ruleId, in_selector, out_rule);

    if (!error.length())
        result->setValue(ASCIILiteral("rule"), out_rule);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorCSSBackendDispatcher::addRule(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_contextNodeId = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("contextNodeId"), nullptr, protocolErrorsPtr);
    String in_selector = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("selector"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "CSS.addRule");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::TypeBuilder::CSS::CSSRule> out_rule;
    m_agent->addRule(&error, in_contextNodeId, in_selector, out_rule);

    if (!error.length())
        result->setValue(ASCIILiteral("rule"), out_rule);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorCSSBackendDispatcher::getSupportedCSSProperties(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::CSS::CSSPropertyInfo> > out_cssProperties;
    m_agent->getSupportedCSSProperties(&error, out_cssProperties);

    if (!error.length())
        result->setValue(ASCIILiteral("cssProperties"), out_cssProperties);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorCSSBackendDispatcher::forcePseudoState(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("nodeId"), nullptr, protocolErrorsPtr);
    RefPtr<Inspector::InspectorArray> in_forcedPseudoClasses = InspectorBackendDispatcher::getArray(paramsContainerPtr, ASCIILiteral("forcedPseudoClasses"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "CSS.forcePseudoState");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->forcePseudoState(&error, in_nodeId, in_forcedPseudoClasses);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorCSSBackendDispatcher::startSelectorProfiler(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->startSelectorProfiler(&error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorCSSBackendDispatcher::stopSelectorProfiler(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::TypeBuilder::CSS::SelectorProfile> out_profile;
    m_agent->stopSelectorProfiler(&error, out_profile);

    if (!error.length())
        result->setValue(ASCIILiteral("profile"), out_profile);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorCSSBackendDispatcher::getNamedFlowCollection(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_documentNodeId = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("documentNodeId"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "CSS.getNamedFlowCollection");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::CSS::NamedFlow> > out_namedFlows;
    m_agent->getNamedFlowCollection(&error, in_documentNodeId, out_namedFlows);

    if (!error.length())
        result->setValue(ASCIILiteral("namedFlows"), out_namedFlows);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

PassRefPtr<InspectorCanvasBackendDispatcher> InspectorCanvasBackendDispatcher::create(InspectorBackendDispatcher* backendDispatcher, InspectorCanvasBackendDispatcherHandler* agent)
{
    return adoptRef(new InspectorCanvasBackendDispatcher(backendDispatcher, agent));
}

InspectorCanvasBackendDispatcher::InspectorCanvasBackendDispatcher(InspectorBackendDispatcher* backendDispatcher, InspectorCanvasBackendDispatcherHandler* agent)
    : InspectorSupplementalBackendDispatcher(backendDispatcher)
    , m_agent(agent)
{
    m_backendDispatcher->registerDispatcherForDomain(ASCIILiteral("Canvas"), this);
}

void InspectorCanvasBackendDispatcher::dispatch(long callId, const String& method, PassRefPtr<InspectorObject> message)
{
    Ref<InspectorCanvasBackendDispatcher> protect(*this);

    typedef void (InspectorCanvasBackendDispatcher::*CallHandler)(long callId, const Inspector::InspectorObject& message);
    typedef HashMap<String, CallHandler> DispatchMap;
    DEFINE_STATIC_LOCAL(DispatchMap, dispatchMap, ());
    if (dispatchMap.isEmpty()) {
        static const struct MethodTable {
            const char* name;
            CallHandler handler;
        } commands[] = {
            { "enable", &InspectorCanvasBackendDispatcher::enable },
            { "disable", &InspectorCanvasBackendDispatcher::disable },
            { "dropTraceLog", &InspectorCanvasBackendDispatcher::dropTraceLog },
            { "hasUninstrumentedCanvases", &InspectorCanvasBackendDispatcher::hasUninstrumentedCanvases },
            { "captureFrame", &InspectorCanvasBackendDispatcher::captureFrame },
            { "startCapturing", &InspectorCanvasBackendDispatcher::startCapturing },
            { "stopCapturing", &InspectorCanvasBackendDispatcher::stopCapturing },
            { "getTraceLog", &InspectorCanvasBackendDispatcher::getTraceLog },
            { "replayTraceLog", &InspectorCanvasBackendDispatcher::replayTraceLog },
            { "getResourceInfo", &InspectorCanvasBackendDispatcher::getResourceInfo },
            { "getResourceState", &InspectorCanvasBackendDispatcher::getResourceState },
        };
        size_t length = WTF_ARRAY_LENGTH(commands);
        for (size_t i = 0; i < length; ++i)
            dispatchMap.add(commands[i].name, commands[i].handler);
    }

    HashMap<String, CallHandler>::iterator it = dispatchMap.find(method);
    if (it == dispatchMap.end()) {
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::MethodNotFound, String("'") + "Canvas" + '.' + method + "' was not found");
        return;
    }

    ((*this).*it->value)(callId, *message.get());
}

void InspectorCanvasBackendDispatcher::enable(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->enable(&error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorCanvasBackendDispatcher::disable(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->disable(&error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorCanvasBackendDispatcher::dropTraceLog(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_traceLogId = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("traceLogId"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Canvas.dropTraceLog");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->dropTraceLog(&error, in_traceLogId);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorCanvasBackendDispatcher::hasUninstrumentedCanvases(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    bool out_result;
    m_agent->hasUninstrumentedCanvases(&error, &out_result);

    if (!error.length())
        result->setBoolean(ASCIILiteral("result"), out_result);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorCanvasBackendDispatcher::captureFrame(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    bool frameId_valueFound = false;
    String in_frameId = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("frameId"), &frameId_valueFound, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Canvas.captureFrame");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    Inspector::TypeBuilder::Canvas::TraceLogId out_traceLogId;
    m_agent->captureFrame(&error, frameId_valueFound ? &in_frameId : nullptr, &out_traceLogId);

    if (!error.length())
        result->setString(ASCIILiteral("traceLogId"), out_traceLogId);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorCanvasBackendDispatcher::startCapturing(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    bool frameId_valueFound = false;
    String in_frameId = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("frameId"), &frameId_valueFound, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Canvas.startCapturing");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    Inspector::TypeBuilder::Canvas::TraceLogId out_traceLogId;
    m_agent->startCapturing(&error, frameId_valueFound ? &in_frameId : nullptr, &out_traceLogId);

    if (!error.length())
        result->setString(ASCIILiteral("traceLogId"), out_traceLogId);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorCanvasBackendDispatcher::stopCapturing(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_traceLogId = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("traceLogId"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Canvas.stopCapturing");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->stopCapturing(&error, in_traceLogId);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorCanvasBackendDispatcher::getTraceLog(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_traceLogId = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("traceLogId"), nullptr, protocolErrorsPtr);
    bool startOffset_valueFound = false;
    int in_startOffset = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("startOffset"), &startOffset_valueFound, protocolErrorsPtr);
    bool maxLength_valueFound = false;
    int in_maxLength = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("maxLength"), &maxLength_valueFound, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Canvas.getTraceLog");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::TypeBuilder::Canvas::TraceLog> out_traceLog;
    m_agent->getTraceLog(&error, in_traceLogId, startOffset_valueFound ? &in_startOffset : nullptr, maxLength_valueFound ? &in_maxLength : nullptr, out_traceLog);

    if (!error.length())
        result->setValue(ASCIILiteral("traceLog"), out_traceLog);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorCanvasBackendDispatcher::replayTraceLog(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_traceLogId = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("traceLogId"), nullptr, protocolErrorsPtr);
    int in_stepNo = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("stepNo"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Canvas.replayTraceLog");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::TypeBuilder::Canvas::ResourceState> out_resourceState;
    m_agent->replayTraceLog(&error, in_traceLogId, in_stepNo, out_resourceState);

    if (!error.length())
        result->setValue(ASCIILiteral("resourceState"), out_resourceState);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorCanvasBackendDispatcher::getResourceInfo(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_resourceId = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("resourceId"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Canvas.getResourceInfo");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::TypeBuilder::Canvas::ResourceInfo> out_resourceInfo;
    m_agent->getResourceInfo(&error, in_resourceId, out_resourceInfo);

    if (!error.length())
        result->setValue(ASCIILiteral("resourceInfo"), out_resourceInfo);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorCanvasBackendDispatcher::getResourceState(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_traceLogId = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("traceLogId"), nullptr, protocolErrorsPtr);
    String in_resourceId = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("resourceId"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Canvas.getResourceState");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::TypeBuilder::Canvas::ResourceState> out_resourceState;
    m_agent->getResourceState(&error, in_traceLogId, in_resourceId, out_resourceState);

    if (!error.length())
        result->setValue(ASCIILiteral("resourceState"), out_resourceState);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

PassRefPtr<InspectorConsoleBackendDispatcher> InspectorConsoleBackendDispatcher::create(InspectorBackendDispatcher* backendDispatcher, InspectorConsoleBackendDispatcherHandler* agent)
{
    return adoptRef(new InspectorConsoleBackendDispatcher(backendDispatcher, agent));
}

InspectorConsoleBackendDispatcher::InspectorConsoleBackendDispatcher(InspectorBackendDispatcher* backendDispatcher, InspectorConsoleBackendDispatcherHandler* agent)
    : InspectorSupplementalBackendDispatcher(backendDispatcher)
    , m_agent(agent)
{
    m_backendDispatcher->registerDispatcherForDomain(ASCIILiteral("Console"), this);
}

void InspectorConsoleBackendDispatcher::dispatch(long callId, const String& method, PassRefPtr<InspectorObject> message)
{
    Ref<InspectorConsoleBackendDispatcher> protect(*this);

    typedef void (InspectorConsoleBackendDispatcher::*CallHandler)(long callId, const Inspector::InspectorObject& message);
    typedef HashMap<String, CallHandler> DispatchMap;
    DEFINE_STATIC_LOCAL(DispatchMap, dispatchMap, ());
    if (dispatchMap.isEmpty()) {
        static const struct MethodTable {
            const char* name;
            CallHandler handler;
        } commands[] = {
            { "enable", &InspectorConsoleBackendDispatcher::enable },
            { "disable", &InspectorConsoleBackendDispatcher::disable },
            { "clearMessages", &InspectorConsoleBackendDispatcher::clearMessages },
            { "setMonitoringXHREnabled", &InspectorConsoleBackendDispatcher::setMonitoringXHREnabled },
            { "addInspectedNode", &InspectorConsoleBackendDispatcher::addInspectedNode },
            { "addInspectedHeapObject", &InspectorConsoleBackendDispatcher::addInspectedHeapObject },
        };
        size_t length = WTF_ARRAY_LENGTH(commands);
        for (size_t i = 0; i < length; ++i)
            dispatchMap.add(commands[i].name, commands[i].handler);
    }

    HashMap<String, CallHandler>::iterator it = dispatchMap.find(method);
    if (it == dispatchMap.end()) {
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::MethodNotFound, String("'") + "Console" + '.' + method + "' was not found");
        return;
    }

    ((*this).*it->value)(callId, *message.get());
}

void InspectorConsoleBackendDispatcher::enable(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->enable(&error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorConsoleBackendDispatcher::disable(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->disable(&error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorConsoleBackendDispatcher::clearMessages(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->clearMessages(&error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorConsoleBackendDispatcher::setMonitoringXHREnabled(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    bool in_enabled = InspectorBackendDispatcher::getBoolean(paramsContainerPtr, ASCIILiteral("enabled"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Console.setMonitoringXHREnabled");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->setMonitoringXHREnabled(&error, in_enabled);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorConsoleBackendDispatcher::addInspectedNode(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("nodeId"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Console.addInspectedNode");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->addInspectedNode(&error, in_nodeId);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorConsoleBackendDispatcher::addInspectedHeapObject(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_heapObjectId = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("heapObjectId"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Console.addInspectedHeapObject");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->addInspectedHeapObject(&error, in_heapObjectId);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

PassRefPtr<InspectorDOMBackendDispatcher> InspectorDOMBackendDispatcher::create(InspectorBackendDispatcher* backendDispatcher, InspectorDOMBackendDispatcherHandler* agent)
{
    return adoptRef(new InspectorDOMBackendDispatcher(backendDispatcher, agent));
}

InspectorDOMBackendDispatcher::InspectorDOMBackendDispatcher(InspectorBackendDispatcher* backendDispatcher, InspectorDOMBackendDispatcherHandler* agent)
    : InspectorSupplementalBackendDispatcher(backendDispatcher)
    , m_agent(agent)
{
    m_backendDispatcher->registerDispatcherForDomain(ASCIILiteral("DOM"), this);
}

void InspectorDOMBackendDispatcher::dispatch(long callId, const String& method, PassRefPtr<InspectorObject> message)
{
    Ref<InspectorDOMBackendDispatcher> protect(*this);

    typedef void (InspectorDOMBackendDispatcher::*CallHandler)(long callId, const Inspector::InspectorObject& message);
    typedef HashMap<String, CallHandler> DispatchMap;
    DEFINE_STATIC_LOCAL(DispatchMap, dispatchMap, ());
    if (dispatchMap.isEmpty()) {
        static const struct MethodTable {
            const char* name;
            CallHandler handler;
        } commands[] = {
            { "getDocument", &InspectorDOMBackendDispatcher::getDocument },
            { "requestChildNodes", &InspectorDOMBackendDispatcher::requestChildNodes },
            { "querySelector", &InspectorDOMBackendDispatcher::querySelector },
            { "querySelectorAll", &InspectorDOMBackendDispatcher::querySelectorAll },
            { "setNodeName", &InspectorDOMBackendDispatcher::setNodeName },
            { "setNodeValue", &InspectorDOMBackendDispatcher::setNodeValue },
            { "removeNode", &InspectorDOMBackendDispatcher::removeNode },
            { "setAttributeValue", &InspectorDOMBackendDispatcher::setAttributeValue },
            { "setAttributesAsText", &InspectorDOMBackendDispatcher::setAttributesAsText },
            { "removeAttribute", &InspectorDOMBackendDispatcher::removeAttribute },
            { "getEventListenersForNode", &InspectorDOMBackendDispatcher::getEventListenersForNode },
            { "getOuterHTML", &InspectorDOMBackendDispatcher::getOuterHTML },
            { "setOuterHTML", &InspectorDOMBackendDispatcher::setOuterHTML },
            { "performSearch", &InspectorDOMBackendDispatcher::performSearch },
            { "getSearchResults", &InspectorDOMBackendDispatcher::getSearchResults },
            { "discardSearchResults", &InspectorDOMBackendDispatcher::discardSearchResults },
            { "requestNode", &InspectorDOMBackendDispatcher::requestNode },
            { "setInspectModeEnabled", &InspectorDOMBackendDispatcher::setInspectModeEnabled },
            { "highlightRect", &InspectorDOMBackendDispatcher::highlightRect },
            { "highlightQuad", &InspectorDOMBackendDispatcher::highlightQuad },
            { "highlightNode", &InspectorDOMBackendDispatcher::highlightNode },
            { "hideHighlight", &InspectorDOMBackendDispatcher::hideHighlight },
            { "highlightFrame", &InspectorDOMBackendDispatcher::highlightFrame },
            { "pushNodeByPathToFrontend", &InspectorDOMBackendDispatcher::pushNodeByPathToFrontend },
            { "pushNodeByBackendIdToFrontend", &InspectorDOMBackendDispatcher::pushNodeByBackendIdToFrontend },
            { "releaseBackendNodeIds", &InspectorDOMBackendDispatcher::releaseBackendNodeIds },
            { "resolveNode", &InspectorDOMBackendDispatcher::resolveNode },
            { "getAttributes", &InspectorDOMBackendDispatcher::getAttributes },
            { "moveTo", &InspectorDOMBackendDispatcher::moveTo },
            { "undo", &InspectorDOMBackendDispatcher::undo },
            { "redo", &InspectorDOMBackendDispatcher::redo },
            { "markUndoableState", &InspectorDOMBackendDispatcher::markUndoableState },
            { "focus", &InspectorDOMBackendDispatcher::focus },
        };
        size_t length = WTF_ARRAY_LENGTH(commands);
        for (size_t i = 0; i < length; ++i)
            dispatchMap.add(commands[i].name, commands[i].handler);
    }

    HashMap<String, CallHandler>::iterator it = dispatchMap.find(method);
    if (it == dispatchMap.end()) {
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::MethodNotFound, String("'") + "DOM" + '.' + method + "' was not found");
        return;
    }

    ((*this).*it->value)(callId, *message.get());
}

void InspectorDOMBackendDispatcher::getDocument(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::TypeBuilder::DOM::Node> out_root;
    m_agent->getDocument(&error, out_root);

    if (!error.length())
        result->setValue(ASCIILiteral("root"), out_root);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorDOMBackendDispatcher::requestChildNodes(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("nodeId"), nullptr, protocolErrorsPtr);
    bool depth_valueFound = false;
    int in_depth = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("depth"), &depth_valueFound, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.requestChildNodes");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->requestChildNodes(&error, in_nodeId, depth_valueFound ? &in_depth : nullptr);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorDOMBackendDispatcher::querySelector(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("nodeId"), nullptr, protocolErrorsPtr);
    String in_selector = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("selector"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.querySelector");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    int out_nodeId;
    m_agent->querySelector(&error, in_nodeId, in_selector, &out_nodeId);

    if (!error.length())
        result->setNumber(ASCIILiteral("nodeId"), out_nodeId);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorDOMBackendDispatcher::querySelectorAll(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("nodeId"), nullptr, protocolErrorsPtr);
    String in_selector = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("selector"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.querySelectorAll");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::TypeBuilder::Array<int> > out_nodeIds;
    m_agent->querySelectorAll(&error, in_nodeId, in_selector, out_nodeIds);

    if (!error.length())
        result->setValue(ASCIILiteral("nodeIds"), out_nodeIds);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorDOMBackendDispatcher::setNodeName(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("nodeId"), nullptr, protocolErrorsPtr);
    String in_name = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("name"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.setNodeName");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    int out_nodeId;
    m_agent->setNodeName(&error, in_nodeId, in_name, &out_nodeId);

    if (!error.length())
        result->setNumber(ASCIILiteral("nodeId"), out_nodeId);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorDOMBackendDispatcher::setNodeValue(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("nodeId"), nullptr, protocolErrorsPtr);
    String in_value = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("value"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.setNodeValue");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->setNodeValue(&error, in_nodeId, in_value);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorDOMBackendDispatcher::removeNode(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("nodeId"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.removeNode");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->removeNode(&error, in_nodeId);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorDOMBackendDispatcher::setAttributeValue(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("nodeId"), nullptr, protocolErrorsPtr);
    String in_name = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("name"), nullptr, protocolErrorsPtr);
    String in_value = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("value"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.setAttributeValue");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->setAttributeValue(&error, in_nodeId, in_name, in_value);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorDOMBackendDispatcher::setAttributesAsText(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("nodeId"), nullptr, protocolErrorsPtr);
    String in_text = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("text"), nullptr, protocolErrorsPtr);
    bool name_valueFound = false;
    String in_name = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("name"), &name_valueFound, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.setAttributesAsText");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->setAttributesAsText(&error, in_nodeId, in_text, name_valueFound ? &in_name : nullptr);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorDOMBackendDispatcher::removeAttribute(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("nodeId"), nullptr, protocolErrorsPtr);
    String in_name = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("name"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.removeAttribute");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->removeAttribute(&error, in_nodeId, in_name);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorDOMBackendDispatcher::getEventListenersForNode(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("nodeId"), nullptr, protocolErrorsPtr);
    bool objectGroup_valueFound = false;
    String in_objectGroup = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("objectGroup"), &objectGroup_valueFound, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.getEventListenersForNode");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::DOM::EventListener> > out_listeners;
    m_agent->getEventListenersForNode(&error, in_nodeId, objectGroup_valueFound ? &in_objectGroup : nullptr, out_listeners);

    if (!error.length())
        result->setValue(ASCIILiteral("listeners"), out_listeners);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorDOMBackendDispatcher::getOuterHTML(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("nodeId"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.getOuterHTML");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    String out_outerHTML;
    m_agent->getOuterHTML(&error, in_nodeId, &out_outerHTML);

    if (!error.length())
        result->setString(ASCIILiteral("outerHTML"), out_outerHTML);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorDOMBackendDispatcher::setOuterHTML(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("nodeId"), nullptr, protocolErrorsPtr);
    String in_outerHTML = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("outerHTML"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.setOuterHTML");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->setOuterHTML(&error, in_nodeId, in_outerHTML);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorDOMBackendDispatcher::performSearch(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_query = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("query"), nullptr, protocolErrorsPtr);
    bool nodeIds_valueFound = false;
    RefPtr<Inspector::InspectorArray> in_nodeIds = InspectorBackendDispatcher::getArray(paramsContainerPtr, ASCIILiteral("nodeIds"), &nodeIds_valueFound, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.performSearch");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    String out_searchId;
    int out_resultCount;
    m_agent->performSearch(&error, in_query, nodeIds_valueFound ? &in_nodeIds : nullptr, &out_searchId, &out_resultCount);

    if (!error.length()) {
        result->setString(ASCIILiteral("searchId"), out_searchId);
        result->setNumber(ASCIILiteral("resultCount"), out_resultCount);
    }

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorDOMBackendDispatcher::getSearchResults(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_searchId = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("searchId"), nullptr, protocolErrorsPtr);
    int in_fromIndex = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("fromIndex"), nullptr, protocolErrorsPtr);
    int in_toIndex = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("toIndex"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.getSearchResults");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::TypeBuilder::Array<int> > out_nodeIds;
    m_agent->getSearchResults(&error, in_searchId, in_fromIndex, in_toIndex, out_nodeIds);

    if (!error.length())
        result->setValue(ASCIILiteral("nodeIds"), out_nodeIds);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorDOMBackendDispatcher::discardSearchResults(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_searchId = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("searchId"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.discardSearchResults");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->discardSearchResults(&error, in_searchId);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorDOMBackendDispatcher::requestNode(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_objectId = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("objectId"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.requestNode");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    int out_nodeId;
    m_agent->requestNode(&error, in_objectId, &out_nodeId);

    if (!error.length())
        result->setNumber(ASCIILiteral("nodeId"), out_nodeId);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorDOMBackendDispatcher::setInspectModeEnabled(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    bool in_enabled = InspectorBackendDispatcher::getBoolean(paramsContainerPtr, ASCIILiteral("enabled"), nullptr, protocolErrorsPtr);
    bool highlightConfig_valueFound = false;
    RefPtr<Inspector::InspectorObject> in_highlightConfig = InspectorBackendDispatcher::getObject(paramsContainerPtr, ASCIILiteral("highlightConfig"), &highlightConfig_valueFound, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.setInspectModeEnabled");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->setInspectModeEnabled(&error, in_enabled, highlightConfig_valueFound ? &in_highlightConfig : nullptr);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorDOMBackendDispatcher::highlightRect(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_x = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("x"), nullptr, protocolErrorsPtr);
    int in_y = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("y"), nullptr, protocolErrorsPtr);
    int in_width = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("width"), nullptr, protocolErrorsPtr);
    int in_height = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("height"), nullptr, protocolErrorsPtr);
    bool color_valueFound = false;
    RefPtr<Inspector::InspectorObject> in_color = InspectorBackendDispatcher::getObject(paramsContainerPtr, ASCIILiteral("color"), &color_valueFound, protocolErrorsPtr);
    bool outlineColor_valueFound = false;
    RefPtr<Inspector::InspectorObject> in_outlineColor = InspectorBackendDispatcher::getObject(paramsContainerPtr, ASCIILiteral("outlineColor"), &outlineColor_valueFound, protocolErrorsPtr);
    bool usePageCoordinates_valueFound = false;
    bool in_usePageCoordinates = InspectorBackendDispatcher::getBoolean(paramsContainerPtr, ASCIILiteral("usePageCoordinates"), &usePageCoordinates_valueFound, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.highlightRect");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->highlightRect(&error, in_x, in_y, in_width, in_height, color_valueFound ? &in_color : nullptr, outlineColor_valueFound ? &in_outlineColor : nullptr, usePageCoordinates_valueFound ? &in_usePageCoordinates : nullptr);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorDOMBackendDispatcher::highlightQuad(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    RefPtr<Inspector::InspectorArray> in_quad = InspectorBackendDispatcher::getArray(paramsContainerPtr, ASCIILiteral("quad"), nullptr, protocolErrorsPtr);
    bool color_valueFound = false;
    RefPtr<Inspector::InspectorObject> in_color = InspectorBackendDispatcher::getObject(paramsContainerPtr, ASCIILiteral("color"), &color_valueFound, protocolErrorsPtr);
    bool outlineColor_valueFound = false;
    RefPtr<Inspector::InspectorObject> in_outlineColor = InspectorBackendDispatcher::getObject(paramsContainerPtr, ASCIILiteral("outlineColor"), &outlineColor_valueFound, protocolErrorsPtr);
    bool usePageCoordinates_valueFound = false;
    bool in_usePageCoordinates = InspectorBackendDispatcher::getBoolean(paramsContainerPtr, ASCIILiteral("usePageCoordinates"), &usePageCoordinates_valueFound, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.highlightQuad");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->highlightQuad(&error, in_quad, color_valueFound ? &in_color : nullptr, outlineColor_valueFound ? &in_outlineColor : nullptr, usePageCoordinates_valueFound ? &in_usePageCoordinates : nullptr);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorDOMBackendDispatcher::highlightNode(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    RefPtr<Inspector::InspectorObject> in_highlightConfig = InspectorBackendDispatcher::getObject(paramsContainerPtr, ASCIILiteral("highlightConfig"), nullptr, protocolErrorsPtr);
    bool nodeId_valueFound = false;
    int in_nodeId = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("nodeId"), &nodeId_valueFound, protocolErrorsPtr);
    bool objectId_valueFound = false;
    String in_objectId = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("objectId"), &objectId_valueFound, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.highlightNode");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->highlightNode(&error, in_highlightConfig, nodeId_valueFound ? &in_nodeId : nullptr, objectId_valueFound ? &in_objectId : nullptr);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorDOMBackendDispatcher::hideHighlight(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->hideHighlight(&error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorDOMBackendDispatcher::highlightFrame(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_frameId = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("frameId"), nullptr, protocolErrorsPtr);
    bool contentColor_valueFound = false;
    RefPtr<Inspector::InspectorObject> in_contentColor = InspectorBackendDispatcher::getObject(paramsContainerPtr, ASCIILiteral("contentColor"), &contentColor_valueFound, protocolErrorsPtr);
    bool contentOutlineColor_valueFound = false;
    RefPtr<Inspector::InspectorObject> in_contentOutlineColor = InspectorBackendDispatcher::getObject(paramsContainerPtr, ASCIILiteral("contentOutlineColor"), &contentOutlineColor_valueFound, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.highlightFrame");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->highlightFrame(&error, in_frameId, contentColor_valueFound ? &in_contentColor : nullptr, contentOutlineColor_valueFound ? &in_contentOutlineColor : nullptr);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorDOMBackendDispatcher::pushNodeByPathToFrontend(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_path = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("path"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.pushNodeByPathToFrontend");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    int out_nodeId;
    m_agent->pushNodeByPathToFrontend(&error, in_path, &out_nodeId);

    if (!error.length())
        result->setNumber(ASCIILiteral("nodeId"), out_nodeId);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorDOMBackendDispatcher::pushNodeByBackendIdToFrontend(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_backendNodeId = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("backendNodeId"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.pushNodeByBackendIdToFrontend");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    int out_nodeId;
    m_agent->pushNodeByBackendIdToFrontend(&error, in_backendNodeId, &out_nodeId);

    if (!error.length())
        result->setNumber(ASCIILiteral("nodeId"), out_nodeId);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorDOMBackendDispatcher::releaseBackendNodeIds(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_nodeGroup = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("nodeGroup"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.releaseBackendNodeIds");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->releaseBackendNodeIds(&error, in_nodeGroup);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorDOMBackendDispatcher::resolveNode(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("nodeId"), nullptr, protocolErrorsPtr);
    bool objectGroup_valueFound = false;
    String in_objectGroup = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("objectGroup"), &objectGroup_valueFound, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.resolveNode");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::TypeBuilder::Runtime::RemoteObject> out_object;
    m_agent->resolveNode(&error, in_nodeId, objectGroup_valueFound ? &in_objectGroup : nullptr, out_object);

    if (!error.length())
        result->setValue(ASCIILiteral("object"), out_object);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorDOMBackendDispatcher::getAttributes(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("nodeId"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.getAttributes");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::TypeBuilder::Array<String> > out_attributes;
    m_agent->getAttributes(&error, in_nodeId, out_attributes);

    if (!error.length())
        result->setValue(ASCIILiteral("attributes"), out_attributes);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorDOMBackendDispatcher::moveTo(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("nodeId"), nullptr, protocolErrorsPtr);
    int in_targetNodeId = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("targetNodeId"), nullptr, protocolErrorsPtr);
    bool insertBeforeNodeId_valueFound = false;
    int in_insertBeforeNodeId = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("insertBeforeNodeId"), &insertBeforeNodeId_valueFound, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.moveTo");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    int out_nodeId;
    m_agent->moveTo(&error, in_nodeId, in_targetNodeId, insertBeforeNodeId_valueFound ? &in_insertBeforeNodeId : nullptr, &out_nodeId);

    if (!error.length())
        result->setNumber(ASCIILiteral("nodeId"), out_nodeId);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorDOMBackendDispatcher::undo(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->undo(&error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorDOMBackendDispatcher::redo(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->redo(&error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorDOMBackendDispatcher::markUndoableState(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->markUndoableState(&error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorDOMBackendDispatcher::focus(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("nodeId"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.focus");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->focus(&error, in_nodeId);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

#if ENABLE(JAVASCRIPT_DEBUGGER)

PassRefPtr<InspectorDOMDebuggerBackendDispatcher> InspectorDOMDebuggerBackendDispatcher::create(InspectorBackendDispatcher* backendDispatcher, InspectorDOMDebuggerBackendDispatcherHandler* agent)
{
    return adoptRef(new InspectorDOMDebuggerBackendDispatcher(backendDispatcher, agent));
}

InspectorDOMDebuggerBackendDispatcher::InspectorDOMDebuggerBackendDispatcher(InspectorBackendDispatcher* backendDispatcher, InspectorDOMDebuggerBackendDispatcherHandler* agent)
    : InspectorSupplementalBackendDispatcher(backendDispatcher)
    , m_agent(agent)
{
    m_backendDispatcher->registerDispatcherForDomain(ASCIILiteral("DOMDebugger"), this);
}

void InspectorDOMDebuggerBackendDispatcher::dispatch(long callId, const String& method, PassRefPtr<InspectorObject> message)
{
    Ref<InspectorDOMDebuggerBackendDispatcher> protect(*this);

    typedef void (InspectorDOMDebuggerBackendDispatcher::*CallHandler)(long callId, const Inspector::InspectorObject& message);
    typedef HashMap<String, CallHandler> DispatchMap;
    DEFINE_STATIC_LOCAL(DispatchMap, dispatchMap, ());
    if (dispatchMap.isEmpty()) {
        static const struct MethodTable {
            const char* name;
            CallHandler handler;
        } commands[] = {
            { "setDOMBreakpoint", &InspectorDOMDebuggerBackendDispatcher::setDOMBreakpoint },
            { "removeDOMBreakpoint", &InspectorDOMDebuggerBackendDispatcher::removeDOMBreakpoint },
            { "setEventListenerBreakpoint", &InspectorDOMDebuggerBackendDispatcher::setEventListenerBreakpoint },
            { "removeEventListenerBreakpoint", &InspectorDOMDebuggerBackendDispatcher::removeEventListenerBreakpoint },
            { "setInstrumentationBreakpoint", &InspectorDOMDebuggerBackendDispatcher::setInstrumentationBreakpoint },
            { "removeInstrumentationBreakpoint", &InspectorDOMDebuggerBackendDispatcher::removeInstrumentationBreakpoint },
            { "setXHRBreakpoint", &InspectorDOMDebuggerBackendDispatcher::setXHRBreakpoint },
            { "removeXHRBreakpoint", &InspectorDOMDebuggerBackendDispatcher::removeXHRBreakpoint },
        };
        size_t length = WTF_ARRAY_LENGTH(commands);
        for (size_t i = 0; i < length; ++i)
            dispatchMap.add(commands[i].name, commands[i].handler);
    }

    HashMap<String, CallHandler>::iterator it = dispatchMap.find(method);
    if (it == dispatchMap.end()) {
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::MethodNotFound, String("'") + "DOMDebugger" + '.' + method + "' was not found");
        return;
    }

    ((*this).*it->value)(callId, *message.get());
}

void InspectorDOMDebuggerBackendDispatcher::setDOMBreakpoint(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("nodeId"), nullptr, protocolErrorsPtr);
    String in_type = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("type"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOMDebugger.setDOMBreakpoint");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->setDOMBreakpoint(&error, in_nodeId, in_type);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorDOMDebuggerBackendDispatcher::removeDOMBreakpoint(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("nodeId"), nullptr, protocolErrorsPtr);
    String in_type = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("type"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOMDebugger.removeDOMBreakpoint");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->removeDOMBreakpoint(&error, in_nodeId, in_type);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorDOMDebuggerBackendDispatcher::setEventListenerBreakpoint(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_eventName = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("eventName"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOMDebugger.setEventListenerBreakpoint");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->setEventListenerBreakpoint(&error, in_eventName);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorDOMDebuggerBackendDispatcher::removeEventListenerBreakpoint(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_eventName = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("eventName"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOMDebugger.removeEventListenerBreakpoint");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->removeEventListenerBreakpoint(&error, in_eventName);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorDOMDebuggerBackendDispatcher::setInstrumentationBreakpoint(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_eventName = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("eventName"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOMDebugger.setInstrumentationBreakpoint");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->setInstrumentationBreakpoint(&error, in_eventName);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorDOMDebuggerBackendDispatcher::removeInstrumentationBreakpoint(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_eventName = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("eventName"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOMDebugger.removeInstrumentationBreakpoint");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->removeInstrumentationBreakpoint(&error, in_eventName);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorDOMDebuggerBackendDispatcher::setXHRBreakpoint(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_url = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("url"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOMDebugger.setXHRBreakpoint");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->setXHRBreakpoint(&error, in_url);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorDOMDebuggerBackendDispatcher::removeXHRBreakpoint(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_url = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("url"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOMDebugger.removeXHRBreakpoint");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->removeXHRBreakpoint(&error, in_url);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

#endif // ENABLE(JAVASCRIPT_DEBUGGER)

PassRefPtr<InspectorDOMStorageBackendDispatcher> InspectorDOMStorageBackendDispatcher::create(InspectorBackendDispatcher* backendDispatcher, InspectorDOMStorageBackendDispatcherHandler* agent)
{
    return adoptRef(new InspectorDOMStorageBackendDispatcher(backendDispatcher, agent));
}

InspectorDOMStorageBackendDispatcher::InspectorDOMStorageBackendDispatcher(InspectorBackendDispatcher* backendDispatcher, InspectorDOMStorageBackendDispatcherHandler* agent)
    : InspectorSupplementalBackendDispatcher(backendDispatcher)
    , m_agent(agent)
{
    m_backendDispatcher->registerDispatcherForDomain(ASCIILiteral("DOMStorage"), this);
}

void InspectorDOMStorageBackendDispatcher::dispatch(long callId, const String& method, PassRefPtr<InspectorObject> message)
{
    Ref<InspectorDOMStorageBackendDispatcher> protect(*this);

    if (method == "enable")
        enable(callId, *message.get());
    else if (method == "disable")
        disable(callId, *message.get());
    else if (method == "getDOMStorageItems")
        getDOMStorageItems(callId, *message.get());
    else if (method == "setDOMStorageItem")
        setDOMStorageItem(callId, *message.get());
    else if (method == "removeDOMStorageItem")
        removeDOMStorageItem(callId, *message.get());
    else
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::MethodNotFound, String("'") + "DOMStorage" + '.' + method + "' was not found");
}

void InspectorDOMStorageBackendDispatcher::enable(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->enable(&error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorDOMStorageBackendDispatcher::disable(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->disable(&error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorDOMStorageBackendDispatcher::getDOMStorageItems(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    RefPtr<Inspector::InspectorObject> in_storageId = InspectorBackendDispatcher::getObject(paramsContainerPtr, ASCIILiteral("storageId"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOMStorage.getDOMStorageItems");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::Array<String> > > out_entries;
    m_agent->getDOMStorageItems(&error, in_storageId, out_entries);

    if (!error.length())
        result->setValue(ASCIILiteral("entries"), out_entries);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorDOMStorageBackendDispatcher::setDOMStorageItem(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    RefPtr<Inspector::InspectorObject> in_storageId = InspectorBackendDispatcher::getObject(paramsContainerPtr, ASCIILiteral("storageId"), nullptr, protocolErrorsPtr);
    String in_key = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("key"), nullptr, protocolErrorsPtr);
    String in_value = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("value"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOMStorage.setDOMStorageItem");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->setDOMStorageItem(&error, in_storageId, in_key, in_value);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorDOMStorageBackendDispatcher::removeDOMStorageItem(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    RefPtr<Inspector::InspectorObject> in_storageId = InspectorBackendDispatcher::getObject(paramsContainerPtr, ASCIILiteral("storageId"), nullptr, protocolErrorsPtr);
    String in_key = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("key"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOMStorage.removeDOMStorageItem");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->removeDOMStorageItem(&error, in_storageId, in_key);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

#if ENABLE(SQL_DATABASE)

PassRefPtr<InspectorDatabaseBackendDispatcher> InspectorDatabaseBackendDispatcher::create(InspectorBackendDispatcher* backendDispatcher, InspectorDatabaseBackendDispatcherHandler* agent)
{
    return adoptRef(new InspectorDatabaseBackendDispatcher(backendDispatcher, agent));
}

InspectorDatabaseBackendDispatcher::InspectorDatabaseBackendDispatcher(InspectorBackendDispatcher* backendDispatcher, InspectorDatabaseBackendDispatcherHandler* agent)
    : InspectorSupplementalBackendDispatcher(backendDispatcher)
    , m_agent(agent)
{
    m_backendDispatcher->registerDispatcherForDomain(ASCIILiteral("Database"), this);
}

void InspectorDatabaseBackendDispatcher::dispatch(long callId, const String& method, PassRefPtr<InspectorObject> message)
{
    Ref<InspectorDatabaseBackendDispatcher> protect(*this);

    if (method == "enable")
        enable(callId, *message.get());
    else if (method == "disable")
        disable(callId, *message.get());
    else if (method == "getDatabaseTableNames")
        getDatabaseTableNames(callId, *message.get());
    else if (method == "executeSQL")
        executeSQL(callId, *message.get());
    else
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::MethodNotFound, String("'") + "Database" + '.' + method + "' was not found");
}

void InspectorDatabaseBackendDispatcher::enable(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->enable(&error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorDatabaseBackendDispatcher::disable(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->disable(&error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorDatabaseBackendDispatcher::getDatabaseTableNames(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_databaseId = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("databaseId"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Database.getDatabaseTableNames");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::TypeBuilder::Array<String> > out_tableNames;
    m_agent->getDatabaseTableNames(&error, in_databaseId, out_tableNames);

    if (!error.length())
        result->setValue(ASCIILiteral("tableNames"), out_tableNames);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

InspectorDatabaseBackendDispatcherHandler::ExecuteSQLCallback::ExecuteSQLCallback(PassRefPtr<InspectorBackendDispatcher> backendDispatcher, int id) : Inspector::InspectorBackendDispatcher::CallbackBase(backendDispatcher, id) { }

void InspectorDatabaseBackendDispatcherHandler::ExecuteSQLCallback::sendSuccess(PassRefPtr<Inspector::TypeBuilder::Array<String> > columnNames, PassRefPtr<Inspector::TypeBuilder::Array<Inspector::InspectorValue> > values, PassRefPtr<Inspector::TypeBuilder::Database::Error> sqlError)
{
    RefPtr<InspectorObject> jsonMessage = InspectorObject::create();
    if (columnNames)
        jsonMessage->setValue(ASCIILiteral("columnNames"), columnNames);
    if (values)
        jsonMessage->setValue(ASCIILiteral("values"), values);
    if (sqlError)
        jsonMessage->setValue(ASCIILiteral("sqlError"), sqlError);
    sendIfActive(jsonMessage, ErrorString());
}

void InspectorDatabaseBackendDispatcher::executeSQL(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_databaseId = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("databaseId"), nullptr, protocolErrorsPtr);
    String in_query = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("query"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Database.executeSQL");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<InspectorDatabaseBackendDispatcherHandler::ExecuteSQLCallback> callback = adoptRef(new InspectorDatabaseBackendDispatcherHandler::ExecuteSQLCallback(m_backendDispatcher,callId));
    m_agent->executeSQL(&error, in_databaseId, in_query, callback);

    if (error.length()) {
        callback->disable();
        m_backendDispatcher->reportProtocolError(&callId, Inspector::InspectorBackendDispatcher::ServerError, error);
        return;
    }
}

#endif // ENABLE(SQL_DATABASE)

PassRefPtr<InspectorHeapProfilerBackendDispatcher> InspectorHeapProfilerBackendDispatcher::create(InspectorBackendDispatcher* backendDispatcher, InspectorHeapProfilerBackendDispatcherHandler* agent)
{
    return adoptRef(new InspectorHeapProfilerBackendDispatcher(backendDispatcher, agent));
}

InspectorHeapProfilerBackendDispatcher::InspectorHeapProfilerBackendDispatcher(InspectorBackendDispatcher* backendDispatcher, InspectorHeapProfilerBackendDispatcherHandler* agent)
    : InspectorSupplementalBackendDispatcher(backendDispatcher)
    , m_agent(agent)
{
    m_backendDispatcher->registerDispatcherForDomain(ASCIILiteral("HeapProfiler"), this);
}

void InspectorHeapProfilerBackendDispatcher::dispatch(long callId, const String& method, PassRefPtr<InspectorObject> message)
{
    Ref<InspectorHeapProfilerBackendDispatcher> protect(*this);

    typedef void (InspectorHeapProfilerBackendDispatcher::*CallHandler)(long callId, const Inspector::InspectorObject& message);
    typedef HashMap<String, CallHandler> DispatchMap;
    DEFINE_STATIC_LOCAL(DispatchMap, dispatchMap, ());
    if (dispatchMap.isEmpty()) {
        static const struct MethodTable {
            const char* name;
            CallHandler handler;
        } commands[] = {
            { "hasHeapProfiler", &InspectorHeapProfilerBackendDispatcher::hasHeapProfiler },
            { "getProfileHeaders", &InspectorHeapProfilerBackendDispatcher::getProfileHeaders },
            { "getHeapSnapshot", &InspectorHeapProfilerBackendDispatcher::getHeapSnapshot },
            { "removeProfile", &InspectorHeapProfilerBackendDispatcher::removeProfile },
            { "clearProfiles", &InspectorHeapProfilerBackendDispatcher::clearProfiles },
            { "takeHeapSnapshot", &InspectorHeapProfilerBackendDispatcher::takeHeapSnapshot },
            { "collectGarbage", &InspectorHeapProfilerBackendDispatcher::collectGarbage },
            { "getObjectByHeapObjectId", &InspectorHeapProfilerBackendDispatcher::getObjectByHeapObjectId },
            { "getHeapObjectId", &InspectorHeapProfilerBackendDispatcher::getHeapObjectId },
        };
        size_t length = WTF_ARRAY_LENGTH(commands);
        for (size_t i = 0; i < length; ++i)
            dispatchMap.add(commands[i].name, commands[i].handler);
    }

    HashMap<String, CallHandler>::iterator it = dispatchMap.find(method);
    if (it == dispatchMap.end()) {
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::MethodNotFound, String("'") + "HeapProfiler" + '.' + method + "' was not found");
        return;
    }

    ((*this).*it->value)(callId, *message.get());
}

void InspectorHeapProfilerBackendDispatcher::hasHeapProfiler(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    bool out_result;
    m_agent->hasHeapProfiler(&error, &out_result);

    if (!error.length())
        result->setBoolean(ASCIILiteral("result"), out_result);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorHeapProfilerBackendDispatcher::getProfileHeaders(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::HeapProfiler::ProfileHeader> > out_headers;
    m_agent->getProfileHeaders(&error, out_headers);

    if (!error.length())
        result->setValue(ASCIILiteral("headers"), out_headers);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorHeapProfilerBackendDispatcher::getHeapSnapshot(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_uid = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("uid"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "HeapProfiler.getHeapSnapshot");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->getHeapSnapshot(&error, in_uid);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorHeapProfilerBackendDispatcher::removeProfile(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_uid = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("uid"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "HeapProfiler.removeProfile");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->removeProfile(&error, in_uid);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorHeapProfilerBackendDispatcher::clearProfiles(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->clearProfiles(&error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorHeapProfilerBackendDispatcher::takeHeapSnapshot(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    bool reportProgress_valueFound = false;
    bool in_reportProgress = InspectorBackendDispatcher::getBoolean(paramsContainerPtr, ASCIILiteral("reportProgress"), &reportProgress_valueFound, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "HeapProfiler.takeHeapSnapshot");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->takeHeapSnapshot(&error, reportProgress_valueFound ? &in_reportProgress : nullptr);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorHeapProfilerBackendDispatcher::collectGarbage(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->collectGarbage(&error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorHeapProfilerBackendDispatcher::getObjectByHeapObjectId(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_objectId = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("objectId"), nullptr, protocolErrorsPtr);
    bool objectGroup_valueFound = false;
    String in_objectGroup = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("objectGroup"), &objectGroup_valueFound, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "HeapProfiler.getObjectByHeapObjectId");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::TypeBuilder::Runtime::RemoteObject> out_result;
    m_agent->getObjectByHeapObjectId(&error, in_objectId, objectGroup_valueFound ? &in_objectGroup : nullptr, out_result);

    if (!error.length())
        result->setValue(ASCIILiteral("result"), out_result);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorHeapProfilerBackendDispatcher::getHeapObjectId(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_objectId = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("objectId"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "HeapProfiler.getHeapObjectId");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    Inspector::TypeBuilder::HeapProfiler::HeapSnapshotObjectId out_heapSnapshotObjectId;
    m_agent->getHeapObjectId(&error, in_objectId, &out_heapSnapshotObjectId);

    if (!error.length())
        result->setString(ASCIILiteral("heapSnapshotObjectId"), out_heapSnapshotObjectId);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

#if ENABLE(INDEXED_DATABASE)

PassRefPtr<InspectorIndexedDBBackendDispatcher> InspectorIndexedDBBackendDispatcher::create(InspectorBackendDispatcher* backendDispatcher, InspectorIndexedDBBackendDispatcherHandler* agent)
{
    return adoptRef(new InspectorIndexedDBBackendDispatcher(backendDispatcher, agent));
}

InspectorIndexedDBBackendDispatcher::InspectorIndexedDBBackendDispatcher(InspectorBackendDispatcher* backendDispatcher, InspectorIndexedDBBackendDispatcherHandler* agent)
    : InspectorSupplementalBackendDispatcher(backendDispatcher)
    , m_agent(agent)
{
    m_backendDispatcher->registerDispatcherForDomain(ASCIILiteral("IndexedDB"), this);
}

void InspectorIndexedDBBackendDispatcher::dispatch(long callId, const String& method, PassRefPtr<InspectorObject> message)
{
    Ref<InspectorIndexedDBBackendDispatcher> protect(*this);

    typedef void (InspectorIndexedDBBackendDispatcher::*CallHandler)(long callId, const Inspector::InspectorObject& message);
    typedef HashMap<String, CallHandler> DispatchMap;
    DEFINE_STATIC_LOCAL(DispatchMap, dispatchMap, ());
    if (dispatchMap.isEmpty()) {
        static const struct MethodTable {
            const char* name;
            CallHandler handler;
        } commands[] = {
            { "enable", &InspectorIndexedDBBackendDispatcher::enable },
            { "disable", &InspectorIndexedDBBackendDispatcher::disable },
            { "requestDatabaseNames", &InspectorIndexedDBBackendDispatcher::requestDatabaseNames },
            { "requestDatabase", &InspectorIndexedDBBackendDispatcher::requestDatabase },
            { "requestData", &InspectorIndexedDBBackendDispatcher::requestData },
            { "clearObjectStore", &InspectorIndexedDBBackendDispatcher::clearObjectStore },
        };
        size_t length = WTF_ARRAY_LENGTH(commands);
        for (size_t i = 0; i < length; ++i)
            dispatchMap.add(commands[i].name, commands[i].handler);
    }

    HashMap<String, CallHandler>::iterator it = dispatchMap.find(method);
    if (it == dispatchMap.end()) {
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::MethodNotFound, String("'") + "IndexedDB" + '.' + method + "' was not found");
        return;
    }

    ((*this).*it->value)(callId, *message.get());
}

void InspectorIndexedDBBackendDispatcher::enable(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->enable(&error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorIndexedDBBackendDispatcher::disable(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->disable(&error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

InspectorIndexedDBBackendDispatcherHandler::RequestDatabaseNamesCallback::RequestDatabaseNamesCallback(PassRefPtr<InspectorBackendDispatcher> backendDispatcher, int id) : Inspector::InspectorBackendDispatcher::CallbackBase(backendDispatcher, id) { }

void InspectorIndexedDBBackendDispatcherHandler::RequestDatabaseNamesCallback::sendSuccess(PassRefPtr<Inspector::TypeBuilder::Array<String> > databaseNames)
{
    RefPtr<InspectorObject> jsonMessage = InspectorObject::create();
    jsonMessage->setValue(ASCIILiteral("databaseNames"), databaseNames);
    sendIfActive(jsonMessage, ErrorString());
}

void InspectorIndexedDBBackendDispatcher::requestDatabaseNames(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_securityOrigin = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("securityOrigin"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "IndexedDB.requestDatabaseNames");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<InspectorIndexedDBBackendDispatcherHandler::RequestDatabaseNamesCallback> callback = adoptRef(new InspectorIndexedDBBackendDispatcherHandler::RequestDatabaseNamesCallback(m_backendDispatcher,callId));
    m_agent->requestDatabaseNames(&error, in_securityOrigin, callback);

    if (error.length()) {
        callback->disable();
        m_backendDispatcher->reportProtocolError(&callId, Inspector::InspectorBackendDispatcher::ServerError, error);
        return;
    }
}

InspectorIndexedDBBackendDispatcherHandler::RequestDatabaseCallback::RequestDatabaseCallback(PassRefPtr<InspectorBackendDispatcher> backendDispatcher, int id) : Inspector::InspectorBackendDispatcher::CallbackBase(backendDispatcher, id) { }

void InspectorIndexedDBBackendDispatcherHandler::RequestDatabaseCallback::sendSuccess(PassRefPtr<Inspector::TypeBuilder::IndexedDB::DatabaseWithObjectStores> databaseWithObjectStores)
{
    RefPtr<InspectorObject> jsonMessage = InspectorObject::create();
    jsonMessage->setValue(ASCIILiteral("databaseWithObjectStores"), databaseWithObjectStores);
    sendIfActive(jsonMessage, ErrorString());
}

void InspectorIndexedDBBackendDispatcher::requestDatabase(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_securityOrigin = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("securityOrigin"), nullptr, protocolErrorsPtr);
    String in_databaseName = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("databaseName"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "IndexedDB.requestDatabase");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<InspectorIndexedDBBackendDispatcherHandler::RequestDatabaseCallback> callback = adoptRef(new InspectorIndexedDBBackendDispatcherHandler::RequestDatabaseCallback(m_backendDispatcher,callId));
    m_agent->requestDatabase(&error, in_securityOrigin, in_databaseName, callback);

    if (error.length()) {
        callback->disable();
        m_backendDispatcher->reportProtocolError(&callId, Inspector::InspectorBackendDispatcher::ServerError, error);
        return;
    }
}

InspectorIndexedDBBackendDispatcherHandler::RequestDataCallback::RequestDataCallback(PassRefPtr<InspectorBackendDispatcher> backendDispatcher, int id) : Inspector::InspectorBackendDispatcher::CallbackBase(backendDispatcher, id) { }

void InspectorIndexedDBBackendDispatcherHandler::RequestDataCallback::sendSuccess(PassRefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::IndexedDB::DataEntry> > objectStoreDataEntries, bool hasMore)
{
    RefPtr<InspectorObject> jsonMessage = InspectorObject::create();
    jsonMessage->setValue(ASCIILiteral("objectStoreDataEntries"), objectStoreDataEntries);
    jsonMessage->setBoolean(ASCIILiteral("hasMore"), hasMore);
    sendIfActive(jsonMessage, ErrorString());
}

void InspectorIndexedDBBackendDispatcher::requestData(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_securityOrigin = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("securityOrigin"), nullptr, protocolErrorsPtr);
    String in_databaseName = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("databaseName"), nullptr, protocolErrorsPtr);
    String in_objectStoreName = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("objectStoreName"), nullptr, protocolErrorsPtr);
    String in_indexName = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("indexName"), nullptr, protocolErrorsPtr);
    int in_skipCount = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("skipCount"), nullptr, protocolErrorsPtr);
    int in_pageSize = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("pageSize"), nullptr, protocolErrorsPtr);
    bool keyRange_valueFound = false;
    RefPtr<Inspector::InspectorObject> in_keyRange = InspectorBackendDispatcher::getObject(paramsContainerPtr, ASCIILiteral("keyRange"), &keyRange_valueFound, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "IndexedDB.requestData");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<InspectorIndexedDBBackendDispatcherHandler::RequestDataCallback> callback = adoptRef(new InspectorIndexedDBBackendDispatcherHandler::RequestDataCallback(m_backendDispatcher,callId));
    m_agent->requestData(&error, in_securityOrigin, in_databaseName, in_objectStoreName, in_indexName, in_skipCount, in_pageSize, keyRange_valueFound ? &in_keyRange : nullptr, callback);

    if (error.length()) {
        callback->disable();
        m_backendDispatcher->reportProtocolError(&callId, Inspector::InspectorBackendDispatcher::ServerError, error);
        return;
    }
}

InspectorIndexedDBBackendDispatcherHandler::ClearObjectStoreCallback::ClearObjectStoreCallback(PassRefPtr<InspectorBackendDispatcher> backendDispatcher, int id) : Inspector::InspectorBackendDispatcher::CallbackBase(backendDispatcher, id) { }

void InspectorIndexedDBBackendDispatcherHandler::ClearObjectStoreCallback::sendSuccess()
{
    RefPtr<InspectorObject> jsonMessage = InspectorObject::create();
    sendIfActive(jsonMessage, ErrorString());
}

void InspectorIndexedDBBackendDispatcher::clearObjectStore(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_securityOrigin = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("securityOrigin"), nullptr, protocolErrorsPtr);
    String in_databaseName = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("databaseName"), nullptr, protocolErrorsPtr);
    String in_objectStoreName = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("objectStoreName"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "IndexedDB.clearObjectStore");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<InspectorIndexedDBBackendDispatcherHandler::ClearObjectStoreCallback> callback = adoptRef(new InspectorIndexedDBBackendDispatcherHandler::ClearObjectStoreCallback(m_backendDispatcher,callId));
    m_agent->clearObjectStore(&error, in_securityOrigin, in_databaseName, in_objectStoreName, callback);

    if (error.length()) {
        callback->disable();
        m_backendDispatcher->reportProtocolError(&callId, Inspector::InspectorBackendDispatcher::ServerError, error);
        return;
    }
}

#endif // ENABLE(INDEXED_DATABASE)

PassRefPtr<InspectorInputBackendDispatcher> InspectorInputBackendDispatcher::create(InspectorBackendDispatcher* backendDispatcher, InspectorInputBackendDispatcherHandler* agent)
{
    return adoptRef(new InspectorInputBackendDispatcher(backendDispatcher, agent));
}

InspectorInputBackendDispatcher::InspectorInputBackendDispatcher(InspectorBackendDispatcher* backendDispatcher, InspectorInputBackendDispatcherHandler* agent)
    : InspectorSupplementalBackendDispatcher(backendDispatcher)
    , m_agent(agent)
{
    m_backendDispatcher->registerDispatcherForDomain(ASCIILiteral("Input"), this);
}

void InspectorInputBackendDispatcher::dispatch(long callId, const String& method, PassRefPtr<InspectorObject> message)
{
    Ref<InspectorInputBackendDispatcher> protect(*this);

    if (method == "dispatchKeyEvent")
        dispatchKeyEvent(callId, *message.get());
    else if (method == "dispatchMouseEvent")
        dispatchMouseEvent(callId, *message.get());
    else
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::MethodNotFound, String("'") + "Input" + '.' + method + "' was not found");
}

void InspectorInputBackendDispatcher::dispatchKeyEvent(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_type = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("type"), nullptr, protocolErrorsPtr);
    bool modifiers_valueFound = false;
    int in_modifiers = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("modifiers"), &modifiers_valueFound, protocolErrorsPtr);
    bool timestamp_valueFound = false;
    double in_timestamp = InspectorBackendDispatcher::getDouble(paramsContainerPtr, ASCIILiteral("timestamp"), &timestamp_valueFound, protocolErrorsPtr);
    bool text_valueFound = false;
    String in_text = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("text"), &text_valueFound, protocolErrorsPtr);
    bool unmodifiedText_valueFound = false;
    String in_unmodifiedText = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("unmodifiedText"), &unmodifiedText_valueFound, protocolErrorsPtr);
    bool keyIdentifier_valueFound = false;
    String in_keyIdentifier = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("keyIdentifier"), &keyIdentifier_valueFound, protocolErrorsPtr);
    bool windowsVirtualKeyCode_valueFound = false;
    int in_windowsVirtualKeyCode = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("windowsVirtualKeyCode"), &windowsVirtualKeyCode_valueFound, protocolErrorsPtr);
    bool nativeVirtualKeyCode_valueFound = false;
    int in_nativeVirtualKeyCode = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("nativeVirtualKeyCode"), &nativeVirtualKeyCode_valueFound, protocolErrorsPtr);
    bool macCharCode_valueFound = false;
    int in_macCharCode = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("macCharCode"), &macCharCode_valueFound, protocolErrorsPtr);
    bool autoRepeat_valueFound = false;
    bool in_autoRepeat = InspectorBackendDispatcher::getBoolean(paramsContainerPtr, ASCIILiteral("autoRepeat"), &autoRepeat_valueFound, protocolErrorsPtr);
    bool isKeypad_valueFound = false;
    bool in_isKeypad = InspectorBackendDispatcher::getBoolean(paramsContainerPtr, ASCIILiteral("isKeypad"), &isKeypad_valueFound, protocolErrorsPtr);
    bool isSystemKey_valueFound = false;
    bool in_isSystemKey = InspectorBackendDispatcher::getBoolean(paramsContainerPtr, ASCIILiteral("isSystemKey"), &isSystemKey_valueFound, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Input.dispatchKeyEvent");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->dispatchKeyEvent(&error, in_type, modifiers_valueFound ? &in_modifiers : nullptr, timestamp_valueFound ? &in_timestamp : nullptr, text_valueFound ? &in_text : nullptr, unmodifiedText_valueFound ? &in_unmodifiedText : nullptr, keyIdentifier_valueFound ? &in_keyIdentifier : nullptr, windowsVirtualKeyCode_valueFound ? &in_windowsVirtualKeyCode : nullptr, nativeVirtualKeyCode_valueFound ? &in_nativeVirtualKeyCode : nullptr, macCharCode_valueFound ? &in_macCharCode : nullptr, autoRepeat_valueFound ? &in_autoRepeat : nullptr, isKeypad_valueFound ? &in_isKeypad : nullptr, isSystemKey_valueFound ? &in_isSystemKey : nullptr);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorInputBackendDispatcher::dispatchMouseEvent(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_type = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("type"), nullptr, protocolErrorsPtr);
    int in_x = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("x"), nullptr, protocolErrorsPtr);
    int in_y = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("y"), nullptr, protocolErrorsPtr);
    bool modifiers_valueFound = false;
    int in_modifiers = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("modifiers"), &modifiers_valueFound, protocolErrorsPtr);
    bool timestamp_valueFound = false;
    double in_timestamp = InspectorBackendDispatcher::getDouble(paramsContainerPtr, ASCIILiteral("timestamp"), &timestamp_valueFound, protocolErrorsPtr);
    bool button_valueFound = false;
    String in_button = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("button"), &button_valueFound, protocolErrorsPtr);
    bool clickCount_valueFound = false;
    int in_clickCount = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("clickCount"), &clickCount_valueFound, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Input.dispatchMouseEvent");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->dispatchMouseEvent(&error, in_type, in_x, in_y, modifiers_valueFound ? &in_modifiers : nullptr, timestamp_valueFound ? &in_timestamp : nullptr, button_valueFound ? &in_button : nullptr, clickCount_valueFound ? &in_clickCount : nullptr);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

PassRefPtr<InspectorLayerTreeBackendDispatcher> InspectorLayerTreeBackendDispatcher::create(InspectorBackendDispatcher* backendDispatcher, InspectorLayerTreeBackendDispatcherHandler* agent)
{
    return adoptRef(new InspectorLayerTreeBackendDispatcher(backendDispatcher, agent));
}

InspectorLayerTreeBackendDispatcher::InspectorLayerTreeBackendDispatcher(InspectorBackendDispatcher* backendDispatcher, InspectorLayerTreeBackendDispatcherHandler* agent)
    : InspectorSupplementalBackendDispatcher(backendDispatcher)
    , m_agent(agent)
{
    m_backendDispatcher->registerDispatcherForDomain(ASCIILiteral("LayerTree"), this);
}

void InspectorLayerTreeBackendDispatcher::dispatch(long callId, const String& method, PassRefPtr<InspectorObject> message)
{
    Ref<InspectorLayerTreeBackendDispatcher> protect(*this);

    if (method == "enable")
        enable(callId, *message.get());
    else if (method == "disable")
        disable(callId, *message.get());
    else if (method == "layersForNode")
        layersForNode(callId, *message.get());
    else if (method == "reasonsForCompositingLayer")
        reasonsForCompositingLayer(callId, *message.get());
    else
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::MethodNotFound, String("'") + "LayerTree" + '.' + method + "' was not found");
}

void InspectorLayerTreeBackendDispatcher::enable(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->enable(&error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorLayerTreeBackendDispatcher::disable(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->disable(&error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorLayerTreeBackendDispatcher::layersForNode(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("nodeId"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "LayerTree.layersForNode");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::LayerTree::Layer> > out_layers;
    m_agent->layersForNode(&error, in_nodeId, out_layers);

    if (!error.length())
        result->setValue(ASCIILiteral("layers"), out_layers);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorLayerTreeBackendDispatcher::reasonsForCompositingLayer(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_layerId = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("layerId"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "LayerTree.reasonsForCompositingLayer");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::TypeBuilder::LayerTree::CompositingReasons> out_compositingReasons;
    m_agent->reasonsForCompositingLayer(&error, in_layerId, out_compositingReasons);

    if (!error.length())
        result->setValue(ASCIILiteral("compositingReasons"), out_compositingReasons);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

PassRefPtr<InspectorMemoryBackendDispatcher> InspectorMemoryBackendDispatcher::create(InspectorBackendDispatcher* backendDispatcher, InspectorMemoryBackendDispatcherHandler* agent)
{
    return adoptRef(new InspectorMemoryBackendDispatcher(backendDispatcher, agent));
}

InspectorMemoryBackendDispatcher::InspectorMemoryBackendDispatcher(InspectorBackendDispatcher* backendDispatcher, InspectorMemoryBackendDispatcherHandler* agent)
    : InspectorSupplementalBackendDispatcher(backendDispatcher)
    , m_agent(agent)
{
    m_backendDispatcher->registerDispatcherForDomain(ASCIILiteral("Memory"), this);
}

void InspectorMemoryBackendDispatcher::dispatch(long callId, const String& method, PassRefPtr<InspectorObject> message)
{
    Ref<InspectorMemoryBackendDispatcher> protect(*this);

    if (method == "getDOMCounters")
        getDOMCounters(callId, *message.get());
    else
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::MethodNotFound, String("'") + "Memory" + '.' + method + "' was not found");
}

void InspectorMemoryBackendDispatcher::getDOMCounters(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    int out_documents;
    int out_nodes;
    int out_jsEventListeners;
    m_agent->getDOMCounters(&error, &out_documents, &out_nodes, &out_jsEventListeners);

    if (!error.length()) {
        result->setNumber(ASCIILiteral("documents"), out_documents);
        result->setNumber(ASCIILiteral("nodes"), out_nodes);
        result->setNumber(ASCIILiteral("jsEventListeners"), out_jsEventListeners);
    }

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

PassRefPtr<InspectorNetworkBackendDispatcher> InspectorNetworkBackendDispatcher::create(InspectorBackendDispatcher* backendDispatcher, InspectorNetworkBackendDispatcherHandler* agent)
{
    return adoptRef(new InspectorNetworkBackendDispatcher(backendDispatcher, agent));
}

InspectorNetworkBackendDispatcher::InspectorNetworkBackendDispatcher(InspectorBackendDispatcher* backendDispatcher, InspectorNetworkBackendDispatcherHandler* agent)
    : InspectorSupplementalBackendDispatcher(backendDispatcher)
    , m_agent(agent)
{
    m_backendDispatcher->registerDispatcherForDomain(ASCIILiteral("Network"), this);
}

void InspectorNetworkBackendDispatcher::dispatch(long callId, const String& method, PassRefPtr<InspectorObject> message)
{
    Ref<InspectorNetworkBackendDispatcher> protect(*this);

    typedef void (InspectorNetworkBackendDispatcher::*CallHandler)(long callId, const Inspector::InspectorObject& message);
    typedef HashMap<String, CallHandler> DispatchMap;
    DEFINE_STATIC_LOCAL(DispatchMap, dispatchMap, ());
    if (dispatchMap.isEmpty()) {
        static const struct MethodTable {
            const char* name;
            CallHandler handler;
        } commands[] = {
            { "enable", &InspectorNetworkBackendDispatcher::enable },
            { "disable", &InspectorNetworkBackendDispatcher::disable },
            { "setExtraHTTPHeaders", &InspectorNetworkBackendDispatcher::setExtraHTTPHeaders },
            { "getResponseBody", &InspectorNetworkBackendDispatcher::getResponseBody },
            { "replayXHR", &InspectorNetworkBackendDispatcher::replayXHR },
            { "canClearBrowserCache", &InspectorNetworkBackendDispatcher::canClearBrowserCache },
            { "clearBrowserCache", &InspectorNetworkBackendDispatcher::clearBrowserCache },
            { "canClearBrowserCookies", &InspectorNetworkBackendDispatcher::canClearBrowserCookies },
            { "clearBrowserCookies", &InspectorNetworkBackendDispatcher::clearBrowserCookies },
            { "setCacheDisabled", &InspectorNetworkBackendDispatcher::setCacheDisabled },
        };
        size_t length = WTF_ARRAY_LENGTH(commands);
        for (size_t i = 0; i < length; ++i)
            dispatchMap.add(commands[i].name, commands[i].handler);
    }

    HashMap<String, CallHandler>::iterator it = dispatchMap.find(method);
    if (it == dispatchMap.end()) {
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::MethodNotFound, String("'") + "Network" + '.' + method + "' was not found");
        return;
    }

    ((*this).*it->value)(callId, *message.get());
}

void InspectorNetworkBackendDispatcher::enable(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->enable(&error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorNetworkBackendDispatcher::disable(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->disable(&error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorNetworkBackendDispatcher::setExtraHTTPHeaders(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    RefPtr<Inspector::InspectorObject> in_headers = InspectorBackendDispatcher::getObject(paramsContainerPtr, ASCIILiteral("headers"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Network.setExtraHTTPHeaders");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->setExtraHTTPHeaders(&error, in_headers);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorNetworkBackendDispatcher::getResponseBody(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_requestId = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("requestId"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Network.getResponseBody");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    String out_body;
    bool out_base64Encoded;
    m_agent->getResponseBody(&error, in_requestId, &out_body, &out_base64Encoded);

    if (!error.length()) {
        result->setString(ASCIILiteral("body"), out_body);
        result->setBoolean(ASCIILiteral("base64Encoded"), out_base64Encoded);
    }

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorNetworkBackendDispatcher::replayXHR(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_requestId = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("requestId"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Network.replayXHR");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->replayXHR(&error, in_requestId);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorNetworkBackendDispatcher::canClearBrowserCache(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    bool out_result;
    m_agent->canClearBrowserCache(&error, &out_result);

    if (!error.length())
        result->setBoolean(ASCIILiteral("result"), out_result);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorNetworkBackendDispatcher::clearBrowserCache(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->clearBrowserCache(&error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorNetworkBackendDispatcher::canClearBrowserCookies(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    bool out_result;
    m_agent->canClearBrowserCookies(&error, &out_result);

    if (!error.length())
        result->setBoolean(ASCIILiteral("result"), out_result);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorNetworkBackendDispatcher::clearBrowserCookies(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->clearBrowserCookies(&error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorNetworkBackendDispatcher::setCacheDisabled(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    bool in_cacheDisabled = InspectorBackendDispatcher::getBoolean(paramsContainerPtr, ASCIILiteral("cacheDisabled"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Network.setCacheDisabled");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->setCacheDisabled(&error, in_cacheDisabled);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

PassRefPtr<InspectorPageBackendDispatcher> InspectorPageBackendDispatcher::create(InspectorBackendDispatcher* backendDispatcher, InspectorPageBackendDispatcherHandler* agent)
{
    return adoptRef(new InspectorPageBackendDispatcher(backendDispatcher, agent));
}

InspectorPageBackendDispatcher::InspectorPageBackendDispatcher(InspectorBackendDispatcher* backendDispatcher, InspectorPageBackendDispatcherHandler* agent)
    : InspectorSupplementalBackendDispatcher(backendDispatcher)
    , m_agent(agent)
{
    m_backendDispatcher->registerDispatcherForDomain(ASCIILiteral("Page"), this);
}

void InspectorPageBackendDispatcher::dispatch(long callId, const String& method, PassRefPtr<InspectorObject> message)
{
    Ref<InspectorPageBackendDispatcher> protect(*this);

    typedef void (InspectorPageBackendDispatcher::*CallHandler)(long callId, const Inspector::InspectorObject& message);
    typedef HashMap<String, CallHandler> DispatchMap;
    DEFINE_STATIC_LOCAL(DispatchMap, dispatchMap, ());
    if (dispatchMap.isEmpty()) {
        static const struct MethodTable {
            const char* name;
            CallHandler handler;
        } commands[] = {
            { "enable", &InspectorPageBackendDispatcher::enable },
            { "disable", &InspectorPageBackendDispatcher::disable },
            { "addScriptToEvaluateOnLoad", &InspectorPageBackendDispatcher::addScriptToEvaluateOnLoad },
            { "removeScriptToEvaluateOnLoad", &InspectorPageBackendDispatcher::removeScriptToEvaluateOnLoad },
            { "reload", &InspectorPageBackendDispatcher::reload },
            { "navigate", &InspectorPageBackendDispatcher::navigate },
            { "getCookies", &InspectorPageBackendDispatcher::getCookies },
            { "deleteCookie", &InspectorPageBackendDispatcher::deleteCookie },
            { "getResourceTree", &InspectorPageBackendDispatcher::getResourceTree },
            { "getResourceContent", &InspectorPageBackendDispatcher::getResourceContent },
            { "searchInResource", &InspectorPageBackendDispatcher::searchInResource },
            { "searchInResources", &InspectorPageBackendDispatcher::searchInResources },
            { "setDocumentContent", &InspectorPageBackendDispatcher::setDocumentContent },
            { "setShowPaintRects", &InspectorPageBackendDispatcher::setShowPaintRects },
            { "canShowDebugBorders", &InspectorPageBackendDispatcher::canShowDebugBorders },
            { "setShowDebugBorders", &InspectorPageBackendDispatcher::setShowDebugBorders },
            { "canShowFPSCounter", &InspectorPageBackendDispatcher::canShowFPSCounter },
            { "setShowFPSCounter", &InspectorPageBackendDispatcher::setShowFPSCounter },
            { "canContinuouslyPaint", &InspectorPageBackendDispatcher::canContinuouslyPaint },
            { "setContinuousPaintingEnabled", &InspectorPageBackendDispatcher::setContinuousPaintingEnabled },
            { "getScriptExecutionStatus", &InspectorPageBackendDispatcher::getScriptExecutionStatus },
            { "setScriptExecutionDisabled", &InspectorPageBackendDispatcher::setScriptExecutionDisabled },
            { "setTouchEmulationEnabled", &InspectorPageBackendDispatcher::setTouchEmulationEnabled },
            { "setEmulatedMedia", &InspectorPageBackendDispatcher::setEmulatedMedia },
            { "getCompositingBordersVisible", &InspectorPageBackendDispatcher::getCompositingBordersVisible },
            { "setCompositingBordersVisible", &InspectorPageBackendDispatcher::setCompositingBordersVisible },
            { "snapshotNode", &InspectorPageBackendDispatcher::snapshotNode },
            { "snapshotRect", &InspectorPageBackendDispatcher::snapshotRect },
            { "handleJavaScriptDialog", &InspectorPageBackendDispatcher::handleJavaScriptDialog },
            { "archive", &InspectorPageBackendDispatcher::archive },
        };
        size_t length = WTF_ARRAY_LENGTH(commands);
        for (size_t i = 0; i < length; ++i)
            dispatchMap.add(commands[i].name, commands[i].handler);
    }

    HashMap<String, CallHandler>::iterator it = dispatchMap.find(method);
    if (it == dispatchMap.end()) {
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::MethodNotFound, String("'") + "Page" + '.' + method + "' was not found");
        return;
    }

    ((*this).*it->value)(callId, *message.get());
}

void InspectorPageBackendDispatcher::enable(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->enable(&error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorPageBackendDispatcher::disable(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->disable(&error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorPageBackendDispatcher::addScriptToEvaluateOnLoad(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_scriptSource = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("scriptSource"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Page.addScriptToEvaluateOnLoad");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    Inspector::TypeBuilder::Page::ScriptIdentifier out_identifier;
    m_agent->addScriptToEvaluateOnLoad(&error, in_scriptSource, &out_identifier);

    if (!error.length())
        result->setString(ASCIILiteral("identifier"), out_identifier);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorPageBackendDispatcher::removeScriptToEvaluateOnLoad(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_identifier = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("identifier"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Page.removeScriptToEvaluateOnLoad");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->removeScriptToEvaluateOnLoad(&error, in_identifier);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorPageBackendDispatcher::reload(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    bool ignoreCache_valueFound = false;
    bool in_ignoreCache = InspectorBackendDispatcher::getBoolean(paramsContainerPtr, ASCIILiteral("ignoreCache"), &ignoreCache_valueFound, protocolErrorsPtr);
    bool scriptToEvaluateOnLoad_valueFound = false;
    String in_scriptToEvaluateOnLoad = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("scriptToEvaluateOnLoad"), &scriptToEvaluateOnLoad_valueFound, protocolErrorsPtr);
    bool scriptPreprocessor_valueFound = false;
    String in_scriptPreprocessor = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("scriptPreprocessor"), &scriptPreprocessor_valueFound, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Page.reload");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->reload(&error, ignoreCache_valueFound ? &in_ignoreCache : nullptr, scriptToEvaluateOnLoad_valueFound ? &in_scriptToEvaluateOnLoad : nullptr, scriptPreprocessor_valueFound ? &in_scriptPreprocessor : nullptr);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorPageBackendDispatcher::navigate(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_url = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("url"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Page.navigate");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->navigate(&error, in_url);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorPageBackendDispatcher::getCookies(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::Page::Cookie> > out_cookies;
    m_agent->getCookies(&error, out_cookies);

    if (!error.length())
        result->setValue(ASCIILiteral("cookies"), out_cookies);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorPageBackendDispatcher::deleteCookie(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_cookieName = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("cookieName"), nullptr, protocolErrorsPtr);
    String in_url = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("url"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Page.deleteCookie");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->deleteCookie(&error, in_cookieName, in_url);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorPageBackendDispatcher::getResourceTree(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::TypeBuilder::Page::FrameResourceTree> out_frameTree;
    m_agent->getResourceTree(&error, out_frameTree);

    if (!error.length())
        result->setValue(ASCIILiteral("frameTree"), out_frameTree);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorPageBackendDispatcher::getResourceContent(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_frameId = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("frameId"), nullptr, protocolErrorsPtr);
    String in_url = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("url"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Page.getResourceContent");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    String out_content;
    bool out_base64Encoded;
    m_agent->getResourceContent(&error, in_frameId, in_url, &out_content, &out_base64Encoded);

    if (!error.length()) {
        result->setString(ASCIILiteral("content"), out_content);
        result->setBoolean(ASCIILiteral("base64Encoded"), out_base64Encoded);
    }

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorPageBackendDispatcher::searchInResource(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_frameId = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("frameId"), nullptr, protocolErrorsPtr);
    String in_url = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("url"), nullptr, protocolErrorsPtr);
    String in_query = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("query"), nullptr, protocolErrorsPtr);
    bool caseSensitive_valueFound = false;
    bool in_caseSensitive = InspectorBackendDispatcher::getBoolean(paramsContainerPtr, ASCIILiteral("caseSensitive"), &caseSensitive_valueFound, protocolErrorsPtr);
    bool isRegex_valueFound = false;
    bool in_isRegex = InspectorBackendDispatcher::getBoolean(paramsContainerPtr, ASCIILiteral("isRegex"), &isRegex_valueFound, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Page.searchInResource");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::GenericTypes::SearchMatch> > out_result;
    m_agent->searchInResource(&error, in_frameId, in_url, in_query, caseSensitive_valueFound ? &in_caseSensitive : nullptr, isRegex_valueFound ? &in_isRegex : nullptr, out_result);

    if (!error.length())
        result->setValue(ASCIILiteral("result"), out_result);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorPageBackendDispatcher::searchInResources(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_text = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("text"), nullptr, protocolErrorsPtr);
    bool caseSensitive_valueFound = false;
    bool in_caseSensitive = InspectorBackendDispatcher::getBoolean(paramsContainerPtr, ASCIILiteral("caseSensitive"), &caseSensitive_valueFound, protocolErrorsPtr);
    bool isRegex_valueFound = false;
    bool in_isRegex = InspectorBackendDispatcher::getBoolean(paramsContainerPtr, ASCIILiteral("isRegex"), &isRegex_valueFound, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Page.searchInResources");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::Page::SearchResult> > out_result;
    m_agent->searchInResources(&error, in_text, caseSensitive_valueFound ? &in_caseSensitive : nullptr, isRegex_valueFound ? &in_isRegex : nullptr, out_result);

    if (!error.length())
        result->setValue(ASCIILiteral("result"), out_result);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorPageBackendDispatcher::setDocumentContent(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_frameId = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("frameId"), nullptr, protocolErrorsPtr);
    String in_html = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("html"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Page.setDocumentContent");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->setDocumentContent(&error, in_frameId, in_html);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorPageBackendDispatcher::setShowPaintRects(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    bool in_result = InspectorBackendDispatcher::getBoolean(paramsContainerPtr, ASCIILiteral("result"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Page.setShowPaintRects");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->setShowPaintRects(&error, in_result);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorPageBackendDispatcher::canShowDebugBorders(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    bool out_show;
    m_agent->canShowDebugBorders(&error, &out_show);

    if (!error.length())
        result->setBoolean(ASCIILiteral("show"), out_show);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorPageBackendDispatcher::setShowDebugBorders(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    bool in_show = InspectorBackendDispatcher::getBoolean(paramsContainerPtr, ASCIILiteral("show"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Page.setShowDebugBorders");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->setShowDebugBorders(&error, in_show);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorPageBackendDispatcher::canShowFPSCounter(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    bool out_show;
    m_agent->canShowFPSCounter(&error, &out_show);

    if (!error.length())
        result->setBoolean(ASCIILiteral("show"), out_show);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorPageBackendDispatcher::setShowFPSCounter(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    bool in_show = InspectorBackendDispatcher::getBoolean(paramsContainerPtr, ASCIILiteral("show"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Page.setShowFPSCounter");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->setShowFPSCounter(&error, in_show);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorPageBackendDispatcher::canContinuouslyPaint(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    bool out_value;
    m_agent->canContinuouslyPaint(&error, &out_value);

    if (!error.length())
        result->setBoolean(ASCIILiteral("value"), out_value);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorPageBackendDispatcher::setContinuousPaintingEnabled(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    bool in_enabled = InspectorBackendDispatcher::getBoolean(paramsContainerPtr, ASCIILiteral("enabled"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Page.setContinuousPaintingEnabled");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->setContinuousPaintingEnabled(&error, in_enabled);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorPageBackendDispatcher::getScriptExecutionStatus(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    InspectorPageBackendDispatcherHandler::Result::Enum out_result;
    m_agent->getScriptExecutionStatus(&error, &out_result);

    if (!error.length())
        result->setString(ASCIILiteral("result"), Inspector::TypeBuilder::getWebEnumConstantValue(out_result));

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorPageBackendDispatcher::setScriptExecutionDisabled(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    bool in_value = InspectorBackendDispatcher::getBoolean(paramsContainerPtr, ASCIILiteral("value"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Page.setScriptExecutionDisabled");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->setScriptExecutionDisabled(&error, in_value);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorPageBackendDispatcher::setTouchEmulationEnabled(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    bool in_enabled = InspectorBackendDispatcher::getBoolean(paramsContainerPtr, ASCIILiteral("enabled"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Page.setTouchEmulationEnabled");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->setTouchEmulationEnabled(&error, in_enabled);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorPageBackendDispatcher::setEmulatedMedia(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_media = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("media"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Page.setEmulatedMedia");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->setEmulatedMedia(&error, in_media);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorPageBackendDispatcher::getCompositingBordersVisible(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    bool out_result;
    m_agent->getCompositingBordersVisible(&error, &out_result);

    if (!error.length())
        result->setBoolean(ASCIILiteral("result"), out_result);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorPageBackendDispatcher::setCompositingBordersVisible(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    bool in_visible = InspectorBackendDispatcher::getBoolean(paramsContainerPtr, ASCIILiteral("visible"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Page.setCompositingBordersVisible");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->setCompositingBordersVisible(&error, in_visible);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorPageBackendDispatcher::snapshotNode(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("nodeId"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Page.snapshotNode");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    String out_dataURL;
    m_agent->snapshotNode(&error, in_nodeId, &out_dataURL);

    if (!error.length())
        result->setString(ASCIILiteral("dataURL"), out_dataURL);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorPageBackendDispatcher::snapshotRect(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_x = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("x"), nullptr, protocolErrorsPtr);
    int in_y = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("y"), nullptr, protocolErrorsPtr);
    int in_width = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("width"), nullptr, protocolErrorsPtr);
    int in_height = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("height"), nullptr, protocolErrorsPtr);
    String in_coordinateSystem = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("coordinateSystem"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Page.snapshotRect");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    String out_dataURL;
    m_agent->snapshotRect(&error, in_x, in_y, in_width, in_height, in_coordinateSystem, &out_dataURL);

    if (!error.length())
        result->setString(ASCIILiteral("dataURL"), out_dataURL);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorPageBackendDispatcher::handleJavaScriptDialog(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    bool in_accept = InspectorBackendDispatcher::getBoolean(paramsContainerPtr, ASCIILiteral("accept"), nullptr, protocolErrorsPtr);
    bool promptText_valueFound = false;
    String in_promptText = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("promptText"), &promptText_valueFound, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Page.handleJavaScriptDialog");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->handleJavaScriptDialog(&error, in_accept, promptText_valueFound ? &in_promptText : nullptr);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorPageBackendDispatcher::archive(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    String out_data;
    m_agent->archive(&error, &out_data);

    if (!error.length())
        result->setString(ASCIILiteral("data"), out_data);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

#if ENABLE(JAVASCRIPT_DEBUGGER)

PassRefPtr<InspectorProfilerBackendDispatcher> InspectorProfilerBackendDispatcher::create(InspectorBackendDispatcher* backendDispatcher, InspectorProfilerBackendDispatcherHandler* agent)
{
    return adoptRef(new InspectorProfilerBackendDispatcher(backendDispatcher, agent));
}

InspectorProfilerBackendDispatcher::InspectorProfilerBackendDispatcher(InspectorBackendDispatcher* backendDispatcher, InspectorProfilerBackendDispatcherHandler* agent)
    : InspectorSupplementalBackendDispatcher(backendDispatcher)
    , m_agent(agent)
{
    m_backendDispatcher->registerDispatcherForDomain(ASCIILiteral("Profiler"), this);
}

void InspectorProfilerBackendDispatcher::dispatch(long callId, const String& method, PassRefPtr<InspectorObject> message)
{
    Ref<InspectorProfilerBackendDispatcher> protect(*this);

    typedef void (InspectorProfilerBackendDispatcher::*CallHandler)(long callId, const Inspector::InspectorObject& message);
    typedef HashMap<String, CallHandler> DispatchMap;
    DEFINE_STATIC_LOCAL(DispatchMap, dispatchMap, ());
    if (dispatchMap.isEmpty()) {
        static const struct MethodTable {
            const char* name;
            CallHandler handler;
        } commands[] = {
            { "causesRecompilation", &InspectorProfilerBackendDispatcher::causesRecompilation },
            { "isSampling", &InspectorProfilerBackendDispatcher::isSampling },
            { "hasHeapProfiler", &InspectorProfilerBackendDispatcher::hasHeapProfiler },
            { "enable", &InspectorProfilerBackendDispatcher::enable },
            { "disable", &InspectorProfilerBackendDispatcher::disable },
            { "start", &InspectorProfilerBackendDispatcher::start },
            { "stop", &InspectorProfilerBackendDispatcher::stop },
            { "getProfileHeaders", &InspectorProfilerBackendDispatcher::getProfileHeaders },
            { "getCPUProfile", &InspectorProfilerBackendDispatcher::getCPUProfile },
            { "getHeapSnapshot", &InspectorProfilerBackendDispatcher::getHeapSnapshot },
            { "removeProfile", &InspectorProfilerBackendDispatcher::removeProfile },
            { "clearProfiles", &InspectorProfilerBackendDispatcher::clearProfiles },
            { "takeHeapSnapshot", &InspectorProfilerBackendDispatcher::takeHeapSnapshot },
            { "collectGarbage", &InspectorProfilerBackendDispatcher::collectGarbage },
            { "getObjectByHeapObjectId", &InspectorProfilerBackendDispatcher::getObjectByHeapObjectId },
            { "getHeapObjectId", &InspectorProfilerBackendDispatcher::getHeapObjectId },
        };
        size_t length = WTF_ARRAY_LENGTH(commands);
        for (size_t i = 0; i < length; ++i)
            dispatchMap.add(commands[i].name, commands[i].handler);
    }

    HashMap<String, CallHandler>::iterator it = dispatchMap.find(method);
    if (it == dispatchMap.end()) {
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::MethodNotFound, String("'") + "Profiler" + '.' + method + "' was not found");
        return;
    }

    ((*this).*it->value)(callId, *message.get());
}

void InspectorProfilerBackendDispatcher::causesRecompilation(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    bool out_result;
    m_agent->causesRecompilation(&error, &out_result);

    if (!error.length())
        result->setBoolean(ASCIILiteral("result"), out_result);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorProfilerBackendDispatcher::isSampling(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    bool out_result;
    m_agent->isSampling(&error, &out_result);

    if (!error.length())
        result->setBoolean(ASCIILiteral("result"), out_result);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorProfilerBackendDispatcher::hasHeapProfiler(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    bool out_result;
    m_agent->hasHeapProfiler(&error, &out_result);

    if (!error.length())
        result->setBoolean(ASCIILiteral("result"), out_result);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorProfilerBackendDispatcher::enable(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->enable(&error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorProfilerBackendDispatcher::disable(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->disable(&error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorProfilerBackendDispatcher::start(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->start(&error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorProfilerBackendDispatcher::stop(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->stop(&error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorProfilerBackendDispatcher::getProfileHeaders(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::TypeBuilder::Array<Inspector::TypeBuilder::Profiler::ProfileHeader> > out_headers;
    m_agent->getProfileHeaders(&error, out_headers);

    if (!error.length())
        result->setValue(ASCIILiteral("headers"), out_headers);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorProfilerBackendDispatcher::getCPUProfile(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_uid = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("uid"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Profiler.getCPUProfile");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::TypeBuilder::Profiler::CPUProfile> out_profile;
    m_agent->getCPUProfile(&error, in_uid, out_profile);

    if (!error.length())
        result->setValue(ASCIILiteral("profile"), out_profile);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorProfilerBackendDispatcher::getHeapSnapshot(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_uid = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("uid"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Profiler.getHeapSnapshot");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->getHeapSnapshot(&error, in_uid);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorProfilerBackendDispatcher::removeProfile(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_type = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("type"), nullptr, protocolErrorsPtr);
    int in_uid = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("uid"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Profiler.removeProfile");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->removeProfile(&error, in_type, in_uid);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorProfilerBackendDispatcher::clearProfiles(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->clearProfiles(&error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorProfilerBackendDispatcher::takeHeapSnapshot(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    bool reportProgress_valueFound = false;
    bool in_reportProgress = InspectorBackendDispatcher::getBoolean(paramsContainerPtr, ASCIILiteral("reportProgress"), &reportProgress_valueFound, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Profiler.takeHeapSnapshot");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->takeHeapSnapshot(&error, reportProgress_valueFound ? &in_reportProgress : nullptr);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorProfilerBackendDispatcher::collectGarbage(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->collectGarbage(&error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorProfilerBackendDispatcher::getObjectByHeapObjectId(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_objectId = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("objectId"), nullptr, protocolErrorsPtr);
    bool objectGroup_valueFound = false;
    String in_objectGroup = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("objectGroup"), &objectGroup_valueFound, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Profiler.getObjectByHeapObjectId");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::TypeBuilder::Runtime::RemoteObject> out_result;
    m_agent->getObjectByHeapObjectId(&error, in_objectId, objectGroup_valueFound ? &in_objectGroup : nullptr, out_result);

    if (!error.length())
        result->setValue(ASCIILiteral("result"), out_result);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorProfilerBackendDispatcher::getHeapObjectId(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_objectId = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("objectId"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Profiler.getHeapObjectId");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    Inspector::TypeBuilder::Profiler::HeapSnapshotObjectId out_heapSnapshotObjectId;
    m_agent->getHeapObjectId(&error, in_objectId, &out_heapSnapshotObjectId);

    if (!error.length())
        result->setString(ASCIILiteral("heapSnapshotObjectId"), out_heapSnapshotObjectId);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

#endif // ENABLE(JAVASCRIPT_DEBUGGER)

PassRefPtr<InspectorTimelineBackendDispatcher> InspectorTimelineBackendDispatcher::create(InspectorBackendDispatcher* backendDispatcher, InspectorTimelineBackendDispatcherHandler* agent)
{
    return adoptRef(new InspectorTimelineBackendDispatcher(backendDispatcher, agent));
}

InspectorTimelineBackendDispatcher::InspectorTimelineBackendDispatcher(InspectorBackendDispatcher* backendDispatcher, InspectorTimelineBackendDispatcherHandler* agent)
    : InspectorSupplementalBackendDispatcher(backendDispatcher)
    , m_agent(agent)
{
    m_backendDispatcher->registerDispatcherForDomain(ASCIILiteral("Timeline"), this);
}

void InspectorTimelineBackendDispatcher::dispatch(long callId, const String& method, PassRefPtr<InspectorObject> message)
{
    Ref<InspectorTimelineBackendDispatcher> protect(*this);

    if (method == "start")
        start(callId, *message.get());
    else if (method == "stop")
        stop(callId, *message.get());
    else if (method == "supportsFrameInstrumentation")
        supportsFrameInstrumentation(callId, *message.get());
    else if (method == "canMonitorMainThread")
        canMonitorMainThread(callId, *message.get());
    else
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::MethodNotFound, String("'") + "Timeline" + '.' + method + "' was not found");
}

void InspectorTimelineBackendDispatcher::start(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    bool maxCallStackDepth_valueFound = false;
    int in_maxCallStackDepth = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("maxCallStackDepth"), &maxCallStackDepth_valueFound, protocolErrorsPtr);
    bool includeDomCounters_valueFound = false;
    bool in_includeDomCounters = InspectorBackendDispatcher::getBoolean(paramsContainerPtr, ASCIILiteral("includeDomCounters"), &includeDomCounters_valueFound, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Timeline.start");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->start(&error, maxCallStackDepth_valueFound ? &in_maxCallStackDepth : nullptr, includeDomCounters_valueFound ? &in_includeDomCounters : nullptr);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorTimelineBackendDispatcher::stop(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->stop(&error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorTimelineBackendDispatcher::supportsFrameInstrumentation(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    bool out_result;
    m_agent->supportsFrameInstrumentation(&error, &out_result);

    if (!error.length())
        result->setBoolean(ASCIILiteral("result"), out_result);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorTimelineBackendDispatcher::canMonitorMainThread(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    bool out_result;
    m_agent->canMonitorMainThread(&error, &out_result);

    if (!error.length())
        result->setBoolean(ASCIILiteral("result"), out_result);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

PassRefPtr<InspectorWorkerBackendDispatcher> InspectorWorkerBackendDispatcher::create(InspectorBackendDispatcher* backendDispatcher, InspectorWorkerBackendDispatcherHandler* agent)
{
    return adoptRef(new InspectorWorkerBackendDispatcher(backendDispatcher, agent));
}

InspectorWorkerBackendDispatcher::InspectorWorkerBackendDispatcher(InspectorBackendDispatcher* backendDispatcher, InspectorWorkerBackendDispatcherHandler* agent)
    : InspectorSupplementalBackendDispatcher(backendDispatcher)
    , m_agent(agent)
{
    m_backendDispatcher->registerDispatcherForDomain(ASCIILiteral("Worker"), this);
}

void InspectorWorkerBackendDispatcher::dispatch(long callId, const String& method, PassRefPtr<InspectorObject> message)
{
    Ref<InspectorWorkerBackendDispatcher> protect(*this);

    typedef void (InspectorWorkerBackendDispatcher::*CallHandler)(long callId, const Inspector::InspectorObject& message);
    typedef HashMap<String, CallHandler> DispatchMap;
    DEFINE_STATIC_LOCAL(DispatchMap, dispatchMap, ());
    if (dispatchMap.isEmpty()) {
        static const struct MethodTable {
            const char* name;
            CallHandler handler;
        } commands[] = {
            { "enable", &InspectorWorkerBackendDispatcher::enable },
            { "disable", &InspectorWorkerBackendDispatcher::disable },
            { "sendMessageToWorker", &InspectorWorkerBackendDispatcher::sendMessageToWorker },
            { "canInspectWorkers", &InspectorWorkerBackendDispatcher::canInspectWorkers },
            { "connectToWorker", &InspectorWorkerBackendDispatcher::connectToWorker },
            { "disconnectFromWorker", &InspectorWorkerBackendDispatcher::disconnectFromWorker },
            { "setAutoconnectToWorkers", &InspectorWorkerBackendDispatcher::setAutoconnectToWorkers },
        };
        size_t length = WTF_ARRAY_LENGTH(commands);
        for (size_t i = 0; i < length; ++i)
            dispatchMap.add(commands[i].name, commands[i].handler);
    }

    HashMap<String, CallHandler>::iterator it = dispatchMap.find(method);
    if (it == dispatchMap.end()) {
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::MethodNotFound, String("'") + "Worker" + '.' + method + "' was not found");
        return;
    }

    ((*this).*it->value)(callId, *message.get());
}

void InspectorWorkerBackendDispatcher::enable(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->enable(&error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorWorkerBackendDispatcher::disable(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->disable(&error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorWorkerBackendDispatcher::sendMessageToWorker(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_workerId = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("workerId"), nullptr, protocolErrorsPtr);
    RefPtr<Inspector::InspectorObject> in_message = InspectorBackendDispatcher::getObject(paramsContainerPtr, ASCIILiteral("message"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Worker.sendMessageToWorker");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->sendMessageToWorker(&error, in_workerId, in_message);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorWorkerBackendDispatcher::canInspectWorkers(long callId, const InspectorObject&)
{
    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    bool out_result;
    m_agent->canInspectWorkers(&error, &out_result);

    if (!error.length())
        result->setBoolean(ASCIILiteral("result"), out_result);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorWorkerBackendDispatcher::connectToWorker(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_workerId = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("workerId"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Worker.connectToWorker");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->connectToWorker(&error, in_workerId);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorWorkerBackendDispatcher::disconnectFromWorker(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_workerId = InspectorBackendDispatcher::getInt(paramsContainerPtr, ASCIILiteral("workerId"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Worker.disconnectFromWorker");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->disconnectFromWorker(&error, in_workerId);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorWorkerBackendDispatcher::setAutoconnectToWorkers(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    bool in_value = InspectorBackendDispatcher::getBoolean(paramsContainerPtr, ASCIILiteral("value"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Worker.setAutoconnectToWorkers");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->setAutoconnectToWorkers(&error, in_value);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

} // namespace Inspector

#endif // ENABLE(INSPECTOR)
